# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-25 10:27+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../Doc/library/asyncio-stream.rst:7
msgid "Streams"
msgstr "스트림"

#: ../Doc/library/asyncio-stream.rst:9
msgid ""
"Streams are high-level async/await-ready primitives to work with network "
"connections.  Streams allow sending and receiving data without using "
"callbacks or low-level protocols and transports."
msgstr ""
"스트림은 네트워크 연결로 작업하기 위해, async/await에서 사용할 수 있는 고수준 프리미티브입니다. 스트림은 콜백이나 저수준"
" 프로토콜과 트랜스포트를 사용하지 않고 데이터를 송수신할 수 있게 합니다."

#: ../Doc/library/asyncio-stream.rst:15
msgid "Here is an example of a TCP echo client written using asyncio streams::"
msgstr "다음은 asyncio 스트림을 사용하여 작성된 TCP 메아리 클라이언트의 예입니다::"

#: ../Doc/library/asyncio-stream.rst:37
msgid "See also the `Examples`_ section below."
msgstr "아래의 `예제 <Examples_>`_ 절도 참조하십시오."

#: ../Doc/library/asyncio-stream.rst:41
msgid "Stream Functions"
msgstr "스트림 함수"

#: ../Doc/library/asyncio-stream.rst:42
msgid ""
"The following top-level asyncio functions can be used to create and work "
"with streams:"
msgstr "다음 최상위 asyncio 함수를 사용하여 스트림을 만들고 작업할 수 있습니다.:"

#: ../Doc/library/asyncio-stream.rst:51
msgid ""
"Establish a network connection and return a pair of ``(reader, writer)`` "
"objects."
msgstr "네트워크 연결을 만들고 ``(reader, writer)`` 객체 쌍을 반환합니다."

#: ../Doc/library/asyncio-stream.rst:54
msgid ""
"The returned *reader* and *writer* objects are instances of "
":class:`StreamReader` and :class:`StreamWriter` classes."
msgstr ""
"반환된 *reader* 와 *writer* 객체는 :class:`StreamReader` 와 :class:`StreamWriter`"
" 클래스의 인스턴스입니다."

#: ../Doc/library/asyncio-stream.rst:57
msgid ""
"The *loop* argument is optional and can always be determined "
"automatically when this function is awaited from a coroutine."
msgstr "*loop* 인자는 선택적이며 이 함수를 코루틴에서 기다릴 때 언제나 자동으로 결정될 수 있습니다."

#: ../Doc/library/asyncio-stream.rst:60 ../Doc/library/asyncio-stream.rst:93
msgid ""
"*limit* determines the buffer size limit used by the returned "
":class:`StreamReader` instance.  By default the *limit* is set to 64 KiB."
msgstr ""
"*limit*\\는 반환된 :class:`StreamReader` 인스턴스가 사용하는 버퍼 크기 한계를 결정합니다. 기본적으로 "
"*limit*\\는 64KB로 설정됩니다."

#: ../Doc/library/asyncio-stream.rst:64
msgid ""
"The rest of the arguments are passed directly to "
":meth:`loop.create_connection`."
msgstr "나머지 인자는 :meth:`loop.create_connection`\\로 직접 전달됩니다."

#: ../Doc/library/asyncio-stream.rst:69 ../Doc/library/asyncio-stream.rst:122
msgid "The *ssl_handshake_timeout* parameter."
msgstr "*ssl_handshake_timeout* 매개 변수."

#: ../Doc/library/asyncio-stream.rst:79
msgid "Start a socket server."
msgstr "소켓 서버를 시작합니다."

#: ../Doc/library/asyncio-stream.rst:81
msgid ""
"The *client_connected_cb* callback is called whenever a new client "
"connection is established.  It receives a ``(reader, writer)`` pair as "
"two arguments, instances of the :class:`StreamReader` and "
":class:`StreamWriter` classes."
msgstr ""
"새 클라이언트 연결이 만들어질 때마다 *client_connected_cb* 콜백이 호출됩니다. 이 콜백은 두 개의 인자로 "
"``(reader, writer)`` 쌍을 받는데, :class:`StreamReader` 와 "
":class:`StreamWriter` 클래스의 인스턴스입니다."

#: ../Doc/library/asyncio-stream.rst:86
msgid ""
"*client_connected_cb* can be a plain callable or a :ref:`coroutine "
"function <coroutine>`; if it is a coroutine function, it will be "
"automatically scheduled as a :class:`Task`."
msgstr ""
"*client_connected_cb*\\는 일반 콜러블이나 :ref:`코루틴 함수 <coroutine>` 일 수 있습니다; 코루틴"
" 함수면, 자동으로 :class:`Task`\\로 예약됩니다."

#: ../Doc/library/asyncio-stream.rst:90
msgid ""
"The *loop* argument is optional and can always be determined "
"automatically when this method is awaited from a coroutine."
msgstr "*loop* 인자는 선택적이며, 이 메서드를 코루틴이 기다릴 때 항상 자동으로 결정될 수 있습니다."

#: ../Doc/library/asyncio-stream.rst:97
msgid ""
"The rest of the arguments are passed directly to "
":meth:`loop.create_server`."
msgstr "나머지 인자는 :meth:`loop.create_server`\\로 직접 전달됩니다."

#: ../Doc/library/asyncio-stream.rst:102 ../Doc/library/asyncio-stream.rst:144
msgid "The *ssl_handshake_timeout* and *start_serving* parameters."
msgstr "*ssl_handshake_timeout* 와 *start_serving* 매개 변수."

#: ../Doc/library/asyncio-stream.rst:106
msgid "Unix Sockets"
msgstr "유닉스 소켓"

#: ../Doc/library/asyncio-stream.rst:111
msgid ""
"Establish a Unix socket connection and return a pair of ``(reader, "
"writer)``."
msgstr "유닉스 소켓 연결을 만들고 ``(reader, writer)`` 쌍을 반환합니다."

#: ../Doc/library/asyncio-stream.rst:114
msgid "Similar to :func:`open_connection` but operates on Unix sockets."
msgstr ":func:`open_connection`\\과 비슷하지만, 유닉스 소켓에서 작동합니다."

#: ../Doc/library/asyncio-stream.rst:116
msgid "See also the documentation of :meth:`loop.create_unix_connection`."
msgstr ":meth:`loop.create_unix_connection`\\의 설명서도 참조하십시오."

#: ../Doc/library/asyncio-stream.rst:119 ../Doc/library/asyncio-stream.rst:141
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`가용성 <availability>`: 유닉스."

#: ../Doc/library/asyncio-stream.rst:126
msgid "The *path* parameter can now be a :term:`path-like object`"
msgstr "*path* 매개 변수는 이제 :term:`경로류 객체 <path-like object>`\\가 될 수 있습니다."

#: ../Doc/library/asyncio-stream.rst:134
msgid "Start a Unix socket server."
msgstr "유닉스 소켓 서버를 시작합니다."

#: ../Doc/library/asyncio-stream.rst:136
msgid "Similar to :func:`start_server` but works with Unix sockets."
msgstr ":func:`start_server`\\와 비슷하지만, 유닉스 소켓에서 작동합니다."

#: ../Doc/library/asyncio-stream.rst:138
msgid "See also the documentation of :meth:`loop.create_unix_server`."
msgstr ":meth:`loop.create_unix_server`\\의 설명서도 참조하십시오."

#: ../Doc/library/asyncio-stream.rst:148
msgid "The *path* parameter can now be a :term:`path-like object`."
msgstr "*path* 매개 변수는 이제 :term:`경로류 객체 <path-like object>`\\가 될 수 있습니다."

#: ../Doc/library/asyncio-stream.rst:155
msgid "StreamReader"
msgstr "StreamReader"

#: ../Doc/library/asyncio-stream.rst:159
msgid ""
"Represents a reader object that provides APIs to read data from the IO "
"stream."
msgstr "IO 스트림에서 데이터를 읽는 API를 제공하는 판독기(reader) 객체를 나타냅니다."

#: ../Doc/library/asyncio-stream.rst:162
msgid ""
"It is not recommended to instantiate *StreamReader* objects directly; use"
" :func:`open_connection` and :func:`start_server` instead."
msgstr ""
"*StreamReader* 객체를 직접 인스턴스로 만드는 것은 권장되지 않습니다. 대신 "
":func:`open_connection`\\과 :func:`start_server`\\를 사용하십시오."

#: ../Doc/library/asyncio-stream.rst:168
msgid ""
"Read up to *n* bytes.  If *n* is not provided, or set to ``-1``, read "
"until EOF and return all read bytes."
msgstr ""
"최대 *n* 바이트를 읽습니다. *n*\\이 제공되지 않거나 ``-1``\\로 설정되면, EOF까지 읽은 후 모든 읽은 바이트를 "
"반환합니다."

#: ../Doc/library/asyncio-stream.rst:171
msgid ""
"If EOF was received and the internal buffer is empty, return an empty "
"``bytes`` object."
msgstr "EOF를 수신했고 내부 버퍼가 비어 있으면, 빈 ``bytes`` 객체를 반환합니다."

#: ../Doc/library/asyncio-stream.rst:176
msgid "Read one line, where \"line\" is a sequence of bytes ending with ``\\n``."
msgstr "한 줄을 읽습니다. 여기서 \"줄\"은 ``\\n``\\로 끝나는 바이트의 시퀀스입니다."

#: ../Doc/library/asyncio-stream.rst:179
msgid ""
"If EOF is received and ``\\n`` was not found, the method returns "
"partially read data."
msgstr "EOF를 수신했고, ``\\n``\\를 찾을 수 없으면, 이 메서드는 부분적으로 읽은 데이터를 반환합니다."

#: ../Doc/library/asyncio-stream.rst:182
msgid ""
"If EOF is received and the internal buffer is empty, return an empty "
"``bytes`` object."
msgstr "EOF를 수신했고, 내부 버퍼가 비어 있으면 빈 ``bytes`` 객체를 반환합니다."

#: ../Doc/library/asyncio-stream.rst:187
msgid "Read exactly *n* bytes."
msgstr "정확히 *n* 바이트를 읽습니다."

#: ../Doc/library/asyncio-stream.rst:189
msgid ""
"Raise an :exc:`IncompleteReadError` if EOF is reached before *n* can be "
"read.  Use the :attr:`IncompleteReadError.partial` attribute to get the "
"partially read data."
msgstr ""
"*n* 바이트를 읽기 전에 EOF에 도달하면, :exc:`IncompleteReadError`\\를 일으킵니다. 부분적으로 읽은 "
"데이터를 가져오려면 :attr:`IncompleteReadError.partial` 어트리뷰트를 사용하십시오."

#: ../Doc/library/asyncio-stream.rst:195
msgid "Read data from the stream until *separator* is found."
msgstr "*separator*\\가 발견될 때까지 스트림에서 데이터를 읽습니다."

#: ../Doc/library/asyncio-stream.rst:197
msgid ""
"On success, the data and separator will be removed from the internal "
"buffer (consumed). Returned data will include the separator at the end."
msgstr ""
"성공하면, 데이터와 separator가 내부 버퍼에서 제거됩니다 (소비됩니다). 반환된 데이터에는 끝에 separator가 "
"포함됩니다."

#: ../Doc/library/asyncio-stream.rst:201
msgid ""
"If the amount of data read exceeds the configured stream limit, a "
":exc:`LimitOverrunError` exception is raised, and the data is left in the"
" internal buffer and can be read again."
msgstr ""
"읽은 데이터의 양이 구성된 스트림 제한을 초과하면 :exc:`LimitOverrunError` 예외가 발생하고, 데이터는 내부 "
"버퍼에 그대로 남아 있으며 다시 읽을 수 있습니다."

#: ../Doc/library/asyncio-stream.rst:205
msgid ""
"If EOF is reached before the complete separator is found, an "
":exc:`IncompleteReadError` exception is raised, and the internal buffer "
"is reset.  The :attr:`IncompleteReadError.partial` attribute may contain "
"a portion of the separator."
msgstr ""
"완전한 separator가 발견되기 전에 EOF에 도달하면 :exc:`IncompleteReadError` 예외가 발생하고, 내부 "
"버퍼가 재설정됩니다. :attr:`IncompleteReadError.partial` 어트리뷰트에는 separator 일부가 포함될"
" 수 있습니다."

#: ../Doc/library/asyncio-stream.rst:214
msgid "Return ``True`` if the buffer is empty and :meth:`feed_eof` was called."
msgstr "버퍼가 비어 있고 :meth:`feed_eof`\\가 호출되었으면 ``True``\\를 반환합니다."

#: ../Doc/library/asyncio-stream.rst:219
msgid "StreamWriter"
msgstr "StreamWriter"

#: ../Doc/library/asyncio-stream.rst:223
msgid ""
"Represents a writer object that provides APIs to write data to the IO "
"stream."
msgstr "IO 스트림에 데이터를 쓰는 API를 제공하는 기록기(writer) 객체를 나타냅니다."

#: ../Doc/library/asyncio-stream.rst:226
msgid ""
"It is not recommended to instantiate *StreamWriter* objects directly; use"
" :func:`open_connection` and :func:`start_server` instead."
msgstr ""
"*StreamWriter* 객체를 직접 인스턴스로 만드는 것은 권장되지 않습니다. 대신 "
":func:`open_connection`\\과 :func:`start_server`\\를 사용하십시오."

#: ../Doc/library/asyncio-stream.rst:232
msgid ""
"Return *True* if the underlying transport supports the :meth:`write_eof` "
"method, *False* otherwise."
msgstr ""
"하부 트랜스포트가 :meth:`write_eof` 메서드를 지원하면 *True*\\를 반환하고, 그렇지 않으면 *False*\\를 "
"반환합니다."

#: ../Doc/library/asyncio-stream.rst:237
msgid ""
"Close the write end of the stream after the buffered write data is "
"flushed."
msgstr "버퍼링 된 쓰기 데이터가 플러시 된 후에 스트림의 쓰기 끝을 닫습니다."

#: ../Doc/library/asyncio-stream.rst:242
msgid "Return the underlying asyncio transport."
msgstr "하부 asyncio 트랜스포트를 돌려줍니다."

#: ../Doc/library/asyncio-stream.rst:246
msgid ""
"Access optional transport information; see "
":meth:`BaseTransport.get_extra_info` for details."
msgstr ""
"선택적 트랜스포트 정보에 액세스합니다; 자세한 내용은 :meth:`BaseTransport.get_extra_info`\\를 "
"참조하십시오."

#: ../Doc/library/asyncio-stream.rst:251
msgid "Write *data* to the stream."
msgstr "스트림에 *data*\\를 기록합니다."

#: ../Doc/library/asyncio-stream.rst:253
msgid ""
"This method is not subject to flow control.  Calls to ``write()`` should "
"be followed by :meth:`drain`."
msgstr "이 메서드는 흐름 제어의 대상이 아닙니다. ``write()`` 호출 뒤에는 :meth:`drain`\\이 와야 합니다."

#: ../Doc/library/asyncio-stream.rst:258
msgid "Write a list (or any iterable) of bytes to the stream."
msgstr "스트림에 바이트열의 리스트(또는 임의의 이터러블)를 기록합니다."

#: ../Doc/library/asyncio-stream.rst:260
msgid ""
"This method is not subject to flow control. Calls to ``writelines()`` "
"should be followed by :meth:`drain`."
msgstr "이 메서드는 흐름 제어의 대상이 아닙니다. ``writelines()`` 호출 뒤에는 :meth:`drain`\\이 와야 합니다."

#: ../Doc/library/asyncio-stream.rst:265
msgid "Wait until it is appropriate to resume writing to the stream. Example::"
msgstr "스트림에 기록을 다시 시작하는 것이 적절할 때까지 기다립니다. 예::"

#: ../Doc/library/asyncio-stream.rst:271
msgid ""
"This is a flow control method that interacts with the underlying IO write"
" buffer.  When the size of the buffer reaches the high watermark, "
"*drain()* blocks until the size of the buffer is drained down to the low "
"watermark and writing can be resumed.  When there is nothing to wait for,"
" the :meth:`drain` returns immediately."
msgstr ""
"이것은 하부 IO 쓰기 버퍼와 상호 작용하는 흐름 제어 메서드입니다. 버퍼의 크기가 높은 수위에 도달하면, 버퍼 크기가 낮은 "
"수위까지 내려가서 쓰기가 다시 시작될 수 있을 때까지 *drain()*\\은 블록합니다. 기다릴 것이 없으면, "
":meth:`drain`\\은 즉시 반환합니다."

#: ../Doc/library/asyncio-stream.rst:280
msgid "Close the stream."
msgstr "스트림을 닫습니다."

#: ../Doc/library/asyncio-stream.rst:284
msgid "Return ``True`` if the stream is closed or in the process of being closed."
msgstr "스트림이 닫혔거나 닫히고 있으면 ``True``\\를 반환합니다."

#: ../Doc/library/asyncio-stream.rst:291
msgid "Wait until the stream is closed."
msgstr "스트림이 닫힐 때까지 기다립니다."

#: ../Doc/library/asyncio-stream.rst:293
msgid ""
"Should be called after :meth:`close` to wait until the underlying "
"connection is closed."
msgstr "하부 연결이 닫힐 때까지 기다리려면 :meth:`close` 뒤에 호출해야 합니다."

#: ../Doc/library/asyncio-stream.rst:300
msgid "Examples"
msgstr "예제"

#: ../Doc/library/asyncio-stream.rst:305
msgid "TCP echo client using streams"
msgstr "스트림을 사용하는 TCP 메아리 클라이언트"

#: ../Doc/library/asyncio-stream.rst:307
msgid "TCP echo client using the :func:`asyncio.open_connection` function::"
msgstr ":func:`asyncio.open_connection` 함수를 사용하는 TCP 메아리 클라이언트::"

#: ../Doc/library/asyncio-stream.rst:329
msgid ""
"The :ref:`TCP echo client protocol "
"<asyncio_example_tcp_echo_client_protocol>` example uses the low-level "
":meth:`loop.create_connection` method."
msgstr ""
":ref:`TCP 메아리 클라이언트 프로토콜 <asyncio_example_tcp_echo_client_protocol>` 예제는 "
"저수준 :meth:`loop.create_connection` 메서드를 사용합니다."

#: ../Doc/library/asyncio-stream.rst:336
msgid "TCP echo server using streams"
msgstr "스트림을 사용하는 TCP 메아리 서버"

#: ../Doc/library/asyncio-stream.rst:338
msgid "TCP echo server using the :func:`asyncio.start_server` function::"
msgstr ":func:`asyncio.start_server` 함수를 사용하는 TCP 메아리 서버::"

#: ../Doc/library/asyncio-stream.rst:371
msgid ""
"The :ref:`TCP echo server protocol "
"<asyncio_example_tcp_echo_server_protocol>` example uses the "
":meth:`loop.create_server` method."
msgstr ""
":ref:`TCP 메아리 서버 프로토콜 <asyncio_example_tcp_echo_server_protocol>` 예제는 "
":meth:`loop.create_server` 메서드를 사용합니다."

#: ../Doc/library/asyncio-stream.rst:376
msgid "Get HTTP headers"
msgstr "HTTP 헤더 가져오기"

#: ../Doc/library/asyncio-stream.rst:378
msgid ""
"Simple example querying HTTP headers of the URL passed on the command "
"line::"
msgstr "명령 줄로 전달된 URL의 HTTP 헤더를 조회하는 간단한 예제::"

#: ../Doc/library/asyncio-stream.rst:416
msgid "Usage::"
msgstr "사용법::"

#: ../Doc/library/asyncio-stream.rst:420
msgid "or with HTTPS::"
msgstr "또는 HTTPS를 사용하면::"

#: ../Doc/library/asyncio-stream.rst:428
msgid "Register an open socket to wait for data using streams"
msgstr "스트림을 사용하여 데이터를 기다리는 열린 소켓 등록"

#: ../Doc/library/asyncio-stream.rst:430
msgid ""
"Coroutine waiting until a socket receives data using the "
":func:`open_connection` function::"
msgstr "소켓이 :func:`open_connection` 함수를 사용하여 데이터를 수신할 때까지 기다리는 코루틴::"

#: ../Doc/library/asyncio-stream.rst:464
msgid ""
"The :ref:`register an open socket to wait for data using a protocol "
"<asyncio_example_create_connection>` example uses a low-level protocol "
"and the :meth:`loop.create_connection` method."
msgstr ""
":ref:`프로토콜을 사용하여 데이터를 기다리는 열린 소켓 등록 <asyncio_example_create_connection>` "
"예제는 저수준 프로토콜과 :meth:`loop.create_connection` 메서드를 사용합니다."

#: ../Doc/library/asyncio-stream.rst:468
msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level "
":meth:`loop.add_reader` method to watch a file descriptor."
msgstr ""
":ref:`파일 기술자에서 읽기 이벤트를 관찰하기 <asyncio_example_watch_fd>` 예제는 저수준 "
":meth:`loop.add_reader` 메서드를 사용하여 파일 기술자를 관찰합니다."
