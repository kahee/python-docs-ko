# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-25 10:27+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../Doc/library/asyncio-eventloop.rst:6
msgid "Event Loop"
msgstr "이벤트 루프"

#: ../Doc/library/asyncio-eventloop.rst:10
msgid "Preface"
msgstr "머리말"

#: ../Doc/library/asyncio-eventloop.rst:11
msgid ""
"The event loop is the core of every asyncio application. Event loops run "
"asynchronous tasks and callbacks, perform network IO operations, and run "
"subprocesses."
msgstr ""
"이벤트 루프는 모든 asyncio 응용 프로그램의 핵심입니다. 이벤트 루프는 비동기 태스크 및 콜백을 실행하고 네트워크 IO 연산을"
" 수행하며 자식 프로세스를 실행합니다."

#: ../Doc/library/asyncio-eventloop.rst:15
msgid ""
"Application developers should typically use the high-level asyncio "
"functions, such as :func:`asyncio.run`, and should rarely need to "
"reference the loop object or call its methods.  This section is intended "
"mostly for authors of lower-level code, libraries, and frameworks, who "
"need finer control over the event loop behavior."
msgstr ""
"응용 프로그램 개발자는 일반적으로 :func:`asyncio.run`\\과 같은 고수준의 asyncio 함수를 사용해야 하며, 루프"
" 객체를 참조하거나 메서드를 호출할 필요가 거의 없습니다. 이 절은 주로 이벤트 루프 동작을 세부적으로 제어해야 하는 저수준 코드,"
" 라이브러리 및 프레임워크의 작성자를 대상으로 합니다."

#: ../Doc/library/asyncio-eventloop.rst:22
msgid "Obtaining the Event Loop"
msgstr "이벤트 루프 얻기"

#: ../Doc/library/asyncio-eventloop.rst:23
msgid ""
"The following low-level functions can be used to get, set, or create an "
"event loop:"
msgstr "다음 저수준 함수를 사용하여 이벤트 루프를 가져오거나 설정하거나 만들 수 있습니다.:"

#: ../Doc/library/asyncio-eventloop.rst:28
msgid "Return the running event loop in the current OS thread."
msgstr "현재 OS 스레드에서 실행 중인 이벤트 루프를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:30
msgid ""
"If there is no running event loop a :exc:`RuntimeError` is raised. This "
"function can only be called from a coroutine or a callback."
msgstr ""
"실행 중인 이벤트 루프가 없으면 :exc:`RuntimeError`\\가 발생합니다. 이 함수는 코루틴이나 콜백에서만 호출할 수 "
"있습니다."

#: ../Doc/library/asyncio-eventloop.rst:37
msgid ""
"Get the current event loop.  If there is no current event loop set in the"
" current OS thread and :func:`set_event_loop` has not yet been called, "
"asyncio will create a new event loop and set it as the current one."
msgstr ""
"현재의 이벤트 루프를 가져옵니다. 현재 OS 스레드에 현재 이벤트 루프가 설정되어 있지 않고 "
":func:`set_event_loop`\\가 아직 호출되지 않았으면, asyncio는 새 이벤트 루프를 만들어 현재 이벤트 루프로"
" 설정합니다."

#: ../Doc/library/asyncio-eventloop.rst:42
msgid ""
"Because this function has rather complex behavior (especially when custom"
" event loop policies are in use), using the :func:`get_running_loop` "
"function is preferred to :func:`get_event_loop` in coroutines and "
"callbacks."
msgstr ""
"이 함수는 (특히 사용자 정의 이벤트 루프 정책을 사용할 때) 다소 복잡한 동작을 하므로, 코루틴과 콜백에서 "
":func:`get_event_loop`\\보다 :func:`get_running_loop` 함수를 사용하는 것이 좋습니다."

#: ../Doc/library/asyncio-eventloop.rst:47
msgid ""
"Consider also using the :func:`asyncio.run` function instead of using "
"lower level functions to manually create and close an event loop."
msgstr ""
"저수준 함수를 사용하여 수동으로 이벤트 루프를 만들고 닫는 대신 :func:`asyncio.run` 함수를 사용하는 것도 "
"고려하십시오."

#: ../Doc/library/asyncio-eventloop.rst:52
msgid "Set *loop* as a current event loop for the current OS thread."
msgstr "*loop*\\를 현재 OS 스레드의 현재 이벤트 루프로 설정합니다."

#: ../Doc/library/asyncio-eventloop.rst:56
msgid "Create a new event loop object."
msgstr "새 이벤트 루프 객체를 만듭니다."

#: ../Doc/library/asyncio-eventloop.rst:58
msgid ""
"Note that the behaviour of :func:`get_event_loop`, "
":func:`set_event_loop`, and :func:`new_event_loop` functions can be "
"altered by :ref:`setting a custom event loop policy <asyncio-policies>`."
msgstr ""
":func:`get_event_loop`, :func:`set_event_loop` 및 :func:`new_event_loop` "
"함수의 동작은 :ref:`사용자 정의 이벤트 루프 정책 설정 <asyncio-policies>`\\에 의해 변경될 수 있음에 "
"유의하십시오."

#: ../Doc/library/asyncio-eventloop.rst:64
msgid "Contents"
msgstr "목차"

#: ../Doc/library/asyncio-eventloop.rst:65
msgid "This documentation page contains the following sections:"
msgstr "이 설명서 페이지는 다음과 같은 절로 구성됩니다:"

#: ../Doc/library/asyncio-eventloop.rst:67
msgid ""
"The `Event Loop Methods`_ section is the reference documentation of the "
"event loop APIs;"
msgstr "`이벤트 루프 메서드 <Event Loop Methods_>`_ 절은 이벤트 루프 API의 레퍼런스 설명서입니다."

#: ../Doc/library/asyncio-eventloop.rst:70
msgid ""
"The `Callback Handles`_ section documents the :class:`Handle` and "
":class:`TimerHandle` instances which are returned from scheduling methods"
" such as :meth:`loop.call_soon` and :meth:`loop.call_later`;"
msgstr ""
"`콜백 핸들 <Callback Handles_>`_ 절은 :meth:`loop.call_soon` 및 "
":meth:`loop.call_later`\\와 같은 예약 메서드에서 반환된 :class:`Handle` 및 "
":class:`TimerHandle` 인스턴스를 설명합니다."

#: ../Doc/library/asyncio-eventloop.rst:74
msgid ""
"The `Server Objects`_ section documents types returned from event loop "
"methods like :meth:`loop.create_server`;"
msgstr ""
"`서버 객체 <Server Objects_>`_ 절은 :meth:`loop.create_server`\\와 같은 이벤트 루프 "
"메서드에서 반환되는 형을 설명합니다."

#: ../Doc/library/asyncio-eventloop.rst:77
msgid ""
"The `Event Loop Implementations`_ section documents the "
":class:`SelectorEventLoop` and :class:`ProactorEventLoop` classes;"
msgstr ""
"`이벤트 루프 구현 <Event Loop Implementations_>`_ 절은 :class:`SelectorEventLoop` "
"및 :class:`ProactorEventLoop` 클래스를 설명합니다."

#: ../Doc/library/asyncio-eventloop.rst:80
msgid "The `Examples`_ section showcases how to work with some event loop APIs."
msgstr "`예제 <Examples_>`_ 절에서는 일부 이벤트 루프 API로 작업하는 방법을 보여줍니다."

#: ../Doc/library/asyncio-eventloop.rst:87
msgid "Event Loop Methods"
msgstr "이벤트 루프 메서드"

#: ../Doc/library/asyncio-eventloop.rst:89
msgid "Event loops have **low-level** APIs for the following:"
msgstr "이벤트 루프에는 다음과 같은 **저수준** API가 있습니다:"

#: ../Doc/library/asyncio-eventloop.rst:97
msgid "Running and stopping the loop"
msgstr "루프 실행 및 중지"

#: ../Doc/library/asyncio-eventloop.rst:101
msgid "Run until the *future* (an instance of :class:`Future`) has completed."
msgstr "*future*\\(:class:`Future`\\의 인스턴스)가 완료할 때까지 실행합니다."

#: ../Doc/library/asyncio-eventloop.rst:104
msgid ""
"If the argument is a :ref:`coroutine object <coroutine>` it is implicitly"
" scheduled to run as a :class:`asyncio.Task`."
msgstr ""
"인자가 :ref:`코루틴 객체 <coroutine>` 면, :class:`asyncio.Task`\\로 실행되도록 묵시적으로 예약 "
"됩니다."

#: ../Doc/library/asyncio-eventloop.rst:107
msgid "Return the Future's result or raise its exception."
msgstr "퓨처의 결과를 반환하거나 퓨처의 예외를 일으킵니다."

#: ../Doc/library/asyncio-eventloop.rst:111
msgid "Run the event loop until :meth:`stop` is called."
msgstr ":meth:`stop`\\가 호출될 때까지 이벤트 루프를 실행합니다."

#: ../Doc/library/asyncio-eventloop.rst:113
msgid ""
"If :meth:`stop` is called before :meth:`run_forever()` is called, the "
"loop will poll the I/O selector once with a timeout of zero, run all "
"callbacks scheduled in response to I/O events (and those that were "
"already scheduled), and then exit."
msgstr ""
":meth:`run_forever()` 가 호출되기 전에 :meth:`stop` 이 호출되었으면, 루프는 시간제한 0으로 I/O "
"셀렉터를 한 번 폴링하고, I/O 이벤트에 따라 예약된 모든 콜백(과 이미 예약된 것들)을 실행한 다음 종료합니다."

#: ../Doc/library/asyncio-eventloop.rst:118
msgid ""
"If :meth:`stop` is called while :meth:`run_forever` is running, the loop "
"will run the current batch of callbacks and then exit. Note that new "
"callbacks scheduled by callbacks will not run in this case; instead, they"
" will run the next time :meth:`run_forever` or :meth:`run_until_complete`"
" is called."
msgstr ""
"만약 :meth:`stop` 이 :meth:`run_forever` 가 실행 중일 때 호출되면, 루프는 현재 걸려있는 콜백들을 "
"실행한 다음 종료합니다. 콜백에 의해 예약되는 새 콜백은 이 경우 실행되지 않습니다; 대신 그것들은 다음에 "
":meth:`run_forever`\\나 :meth:`run_until_complete`\\가 호출될 때 실행됩니다."

#: ../Doc/library/asyncio-eventloop.rst:126
msgid "Stop the event loop."
msgstr "이벤트 루프를 중지합니다."

#: ../Doc/library/asyncio-eventloop.rst:130
msgid "Return ``True`` if the event loop is currently running."
msgstr "이벤트 루프가 현재 실행 중이면 ``True`` 를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:134
msgid "Return ``True`` if the event loop was closed."
msgstr "이벤트 루프가 닫혔으면 ``True`` 를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:138
msgid "Close the event loop."
msgstr "이벤트 루프를 닫습니다."

#: ../Doc/library/asyncio-eventloop.rst:140
msgid ""
"The loop must not be running when this function is called. Any pending "
"callbacks will be discarded."
msgstr "이 함수를 호출할 때 루프는 반드시 실행 중이지 않아야 합니다. 계류 중인 모든 콜백을 버립니다."

#: ../Doc/library/asyncio-eventloop.rst:143
msgid ""
"This method clears all queues and shuts down the executor, but does not "
"wait for the executor to finish."
msgstr "이 메서드는 모든 큐를 비우고 실행기를 종료하지만, 실행기가 완료할 때까지 기다리지 않습니다."

#: ../Doc/library/asyncio-eventloop.rst:146
msgid ""
"This method is idempotent and irreversible.  No other methods should be "
"called after the event loop is closed."
msgstr ""
"이 메서드는 멱등적(itempotent)이고 되돌릴 수 없습니다. 이벤트 루프가 닫힌 후에 다른 메서드를 호출해서는 안 됩니다."

#: ../Doc/library/asyncio-eventloop.rst:151
msgid ""
"Schedule all currently open :term:`asynchronous generator` objects to "
"close with an :meth:`~agen.aclose()` call.  After calling this method, "
"the event loop will issue a warning if a new asynchronous generator is "
"iterated. This should be used to reliably finalize all scheduled "
"asynchronous generators."
msgstr ""
"현재 열려있는 :term:`비동기 제너레이터 <asynchronous generator>` 객체를 모두 "
":meth:`~agen.aclose()` 호출로 닫도록 예약 합니다. 이 메서드를 호출한 후에는, 새 비동기 생성기가 이터레이트 "
"되면 이벤트 루프에서 경고를 보냅니다. 예약된 모든 비동기 제너레이터를 신뢰성 있게 종료하는 데 사용해야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:157
msgid ""
"Note that there is no need to call this function when :func:`asyncio.run`"
" is used."
msgstr ":func:`asyncio.run`\\가 사용될 때 이 함수를 호출할 필요는 없다는 점에 유의하세요."

#: ../Doc/library/asyncio-eventloop.rst:160
#: ../Doc/library/asyncio-eventloop.rst:1001
#: ../Doc/library/asyncio-eventloop.rst:1363
msgid "Example::"
msgstr "예::"

#: ../Doc/library/asyncio-eventloop.rst:172
msgid "Scheduling callbacks"
msgstr "콜백 예약하기"

#: ../Doc/library/asyncio-eventloop.rst:176
msgid ""
"Schedule a *callback* to be called with *args* arguments at the next "
"iteration of the event loop."
msgstr "이벤트 루프의 다음 이터레이션 때 *args* 인자로 호출할 *callback*\\을 예약합니다."

#: ../Doc/library/asyncio-eventloop.rst:179
msgid ""
"Callbacks are called in the order in which they are registered. Each "
"callback will be called exactly once."
msgstr "콜백은 등록된 순서대로 호출됩니다. 각 콜백은 정확히 한 번 호출됩니다."

#: ../Doc/library/asyncio-eventloop.rst:182
#: ../Doc/library/asyncio-eventloop.rst:245
msgid ""
"An optional keyword-only *context* argument allows specifying a custom "
":class:`contextvars.Context` for the *callback* to run in. The current "
"context is used when no *context* is provided."
msgstr ""
"선택적인 키워드 전용 *context* 인자는 *callback* 을 실행할 사용자 정의 "
":class:`contextvars.Context` 를 지정할 수 있게 합니다. *context* 가 제공되지 않을 때는 현재 "
"컨텍스트가 사용됩니다."

#: ../Doc/library/asyncio-eventloop.rst:186
msgid ""
"An instance of :class:`asyncio.Handle` is returned, which can be used "
"later to cancel the callback."
msgstr ":class:`asyncio.Handle` 인스턴스가 반환되는데, 나중에 콜백을 취소하는 데 사용할 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:189
msgid "This method is not thread-safe."
msgstr "이 메서드는 스레드 안전하지 않습니다."

#: ../Doc/library/asyncio-eventloop.rst:193
msgid ""
"A thread-safe variant of :meth:`call_soon`.  Must be used to schedule "
"callbacks *from another thread*."
msgstr "스레드 안전한 :meth:`call_soon` 변형입니다. *다른 스레드에서* 콜백을 예약하는 데 사용해야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:196
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr "설명서의 :ref:`동시성과 다중 스레딩 <asyncio-multithreading>` 절을 참고하십시오."

#: ../Doc/library/asyncio-eventloop.rst:199
#: ../Doc/library/asyncio-eventloop.rst:249
#: ../Doc/library/asyncio-eventloop.rst:269
msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr "*context* 키워드 전용 매개 변수가 추가되었습니다. 자세한 정보는 :pep:`567`\\을 보십시오."

#: ../Doc/library/asyncio-eventloop.rst:207
msgid ""
"Most :mod:`asyncio` scheduling functions don't allow passing keyword "
"arguments.  To do that, use :func:`functools.partial`::"
msgstr ""
"대부분 :mod:`asyncio` 예약 함수는 키워드 인자 전달을 허용하지 않습니다. 그렇게 하려면 "
":func:`functools.partial`\\을 사용하십시오::"

#: ../Doc/library/asyncio-eventloop.rst:214
msgid ""
"Using partial objects is usually more convenient than using lambdas, as "
"asyncio can render partial objects better in debug and error messages."
msgstr ""
"asyncio는 디버그 및 오류 메시지에서 partial 객체를 더욱 잘 표시할 수 있으므로, partial 객체를 사용하는 것이 "
"람다를 사용하는 것보다 편리합니다."

#: ../Doc/library/asyncio-eventloop.rst:222
msgid "Scheduling delayed callbacks"
msgstr "지연된 콜백 예약"

#: ../Doc/library/asyncio-eventloop.rst:224
msgid ""
"Event loop provides mechanisms to schedule callback functions to be "
"called at some point in the future.  Event loop uses monotonic clocks to "
"track time."
msgstr ""
"이벤트 루프는 콜백 함수가 미래의 어떤 시점에서 호출되도록 예약하는 메커니즘을 제공합니다. 이벤트 루프는 단조 시계를 사용하여 "
"시간을 추적합니다."

#: ../Doc/library/asyncio-eventloop.rst:231
msgid ""
"Schedule *callback* to be called after the given *delay* number of "
"seconds (can be either an int or a float)."
msgstr "지정된 *delay* 초 (int 또는 float) 뒤에 *callback* 이 호출되도록 예약합니다."

#: ../Doc/library/asyncio-eventloop.rst:234
#: ../Doc/library/asyncio-eventloop.rst:266
msgid ""
"An instance of :class:`asyncio.TimerHandle` is returned which can be used"
" to cancel the callback."
msgstr ":class:`asyncio.TimerHandle` 의 인스턴스가 반환되는데, 콜백을 취소하는 데 사용할 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:237
msgid ""
"*callback* will be called exactly once.  If two callbacks are scheduled "
"for exactly the same time, the order in which they are called is "
"undefined."
msgstr ""
"*callback* 은 정확히 한번 호출됩니다. 두 콜백이 정확히 같은 시간에 예약되면, 어떤 것이 먼저 호출되는지는 정의되지 "
"않습니다."

#: ../Doc/library/asyncio-eventloop.rst:241
msgid ""
"The optional positional *args* will be passed to the callback when it is "
"called. If you want the callback to be called with keyword arguments use "
":func:`functools.partial`."
msgstr ""
"선택적 위치 *args* 는 호출 될 때 콜백에 전달됩니다. 콜백을 키워드 인자로 호출하고 싶으면 "
":func:`functools.partial` 를 사용하십시오."

#: ../Doc/library/asyncio-eventloop.rst:253
msgid ""
"In Python 3.7.0 and earlier with the default event loop implementation, "
"the *delay* could not exceed one day. This has been fixed in Python "
"3.7.1."
msgstr ""
"파이썬 3.7.0 및 이전 버전에서 기본 이벤트 루프 구현을 사용할 때, *delay*\\는 하루를 초과할 수 없었습니다. 이 "
"문제는 파이썬 3.7.1에서 수정되었습니다."

#: ../Doc/library/asyncio-eventloop.rst:260
msgid ""
"Schedule *callback* to be called at the given absolute timestamp *when* "
"(an int or a float), using the same time reference as :meth:`loop.time`."
msgstr ""
"지정된 절대 타임스탬프 *when*\\(int 또는 float)에 *callback* 이 호출되도록 예약합니다. "
":meth:`loop.time` 과 같은 시간 참조를 사용하십시오."

#: ../Doc/library/asyncio-eventloop.rst:264
msgid "This method's behavior is the same as :meth:`call_later`."
msgstr "이 메서드의 동작은 :meth:`call_later`\\와 같습니다."

#: ../Doc/library/asyncio-eventloop.rst:273
msgid ""
"In Python 3.7.0 and earlier with the default event loop implementation, "
"the difference between *when* and the current time could not exceed one "
"day.  This has been fixed in Python 3.7.1."
msgstr ""
"파이썬 3.7.0 및 이전 버전에서 기본 이벤트 루프 구현을 사용할 때, *when*\\와 현재 시각의 차이는 하루를 초과할 수 "
"없었습니다. 이 문제는 파이썬 3.7.1에서 수정되었습니다."

#: ../Doc/library/asyncio-eventloop.rst:280
msgid ""
"Return the current time, as a :class:`float` value, according to the "
"event loop's internal monotonic clock."
msgstr "이벤트 루프의 내부 단조 시계에 따라, :class:`float` 값으로 현재 시각을 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:285
msgid "Timeouts (relative *delay* or absolute *when*) should not exceed one day."
msgstr "제한 시간(상대적인 *delay* 나 절대적인 *when*)은 1일을 초과하지 않아야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:290
msgid "The :func:`asyncio.sleep` function."
msgstr ":func:`asyncio.sleep` 함수."

#: ../Doc/library/asyncio-eventloop.rst:294
msgid "Creating Futures and Tasks"
msgstr "퓨처와 태스크 만들기"

#: ../Doc/library/asyncio-eventloop.rst:298
msgid "Create an :class:`asyncio.Future` object attached to the event loop."
msgstr "이벤트 루프에 연결된 :class:`asyncio.Future` 객체를 만듭니다."

#: ../Doc/library/asyncio-eventloop.rst:300
msgid ""
"This is the preferred way to create Futures in asyncio. This lets third-"
"party event loops provide alternative implementations of the Future "
"object (with better performance or instrumentation)."
msgstr ""
"이것이 asyncio에서 퓨처를 만드는 데 선호되는 방법입니다. 이렇게 하면 제삼자 이벤트 루프가 Future 객체의 다른 구현(더"
" 나은 성능이나 인스트루멘테이션)을 제공할 수 있습니다"

#: ../Doc/library/asyncio-eventloop.rst:308
msgid ""
"Schedule the execution of a :ref:`coroutine`. Return a :class:`Task` "
"object."
msgstr ":ref:`coroutine` 의 실행을 예약합니다. :class:`Task` 객체를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:311
msgid ""
"Third-party event loops can use their own subclass of :class:`Task` for "
"interoperability. In this case, the result type is a subclass of "
":class:`Task`."
msgstr ""
"제삼자 이벤트 루프는 상호 운용성을 위해 자신만의 :class:`Task` 의 서브 클래스를 사용할 수 있습니다. 이 경우, 결과 "
"형은 :class:`Task` 의 서브 클래스입니다."

#: ../Doc/library/asyncio-eventloop.rst:317
msgid "Set a task factory that will be used by :meth:`loop.create_task`."
msgstr ":meth:`loop.create_task` 에 의해 사용되는 태스크 팩토리를 설정합니다."

#: ../Doc/library/asyncio-eventloop.rst:320
msgid ""
"If *factory* is ``None`` the default task factory will be set. Otherwise,"
" *factory* must be a *callable* with the signature matching ``(loop, "
"coro)``, where *loop* is a reference to the active event loop, and *coro*"
" is a coroutine object.  The callable must return a "
":class:`asyncio.Future`-compatible object."
msgstr ""
"*factory* 가 ``None`` 이면 기본 태스크 팩토리가 설정됩니다. 그렇지 않으면, *factory* 는 반드시 *콜러블*"
" 이어야 하고, ``(loop, coro)`` 과 일치하는 서명을 가져야 합니다. 여기서 *loop* 는 활성 이벤트 루프에 대한 "
"참조가 되고, *coro* 는 코루틴 객체가 됩니다. 콜러블은 :class:`asyncio.Future` 호환 객체를 반환해야 "
"합니다."

#: ../Doc/library/asyncio-eventloop.rst:328
msgid "Return a task factory or ``None`` if the default one is in use."
msgstr "태스크 팩토리를 반환하거나, 기본값이 사용 중이면 ``None`` 을 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:332
msgid "Opening network connections"
msgstr "네트워크 연결 열기"

#: ../Doc/library/asyncio-eventloop.rst:340
msgid ""
"Open a streaming transport connection to a given address specified by "
"*host* and *port*."
msgstr "주어진 *host* 와 *port*\\로 지정된 주소로의 스트리밍 트랜스포트 연결을 엽니다."

#: ../Doc/library/asyncio-eventloop.rst:343
msgid ""
"The socket family can be either :py:data:`~socket.AF_INET` or "
":py:data:`~socket.AF_INET6` depending on *host* (or the *family* "
"argument, if provided)."
msgstr ""
"소켓 패밀리는 *host*\\(또는 지정된 경우 *family*)에 따라 :py:data:`~socket.AF_INET` 또는 "
":py:data:`~socket.AF_INET6`\\일 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:347
msgid "The socket type will be :py:data:`~socket.SOCK_STREAM`."
msgstr "소켓 유형은 :py:data:`~socket.SOCK_STREAM`\\이 됩니다."

#: ../Doc/library/asyncio-eventloop.rst:349
#: ../Doc/library/asyncio-eventloop.rst:917
#: ../Doc/library/asyncio-eventloop.rst:933
msgid ""
"*protocol_factory* must be a callable returning an :ref:`asyncio protocol"
" <asyncio-protocol>` implementation."
msgstr ""
"*protocol_factory* 는 반드시 :ref:`asyncio 프로토콜 <asyncio-protocol>` 구현을 반환하는 "
"콜러블이어야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:352
msgid ""
"This method will try to establish the connection in the background. When "
"successful, it returns a ``(transport, protocol)`` pair."
msgstr ""
"이 메서드는 백그라운드에서 연결을 맺으려고 시도합니다. 성공하면, ``(transport, protocol)`` 쌍을 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:355
msgid "The chronological synopsis of the underlying operation is as follows:"
msgstr "하부 연산의 시간순 개요는 다음과 같습니다:"

#: ../Doc/library/asyncio-eventloop.rst:357
msgid ""
"The connection is established and a :ref:`transport <asyncio-transport>` "
"is created for it."
msgstr "연결이 맺어지고, 이를 위한 :ref:`트랜스포트(transport) <asyncio-transport>` 가 만들어집니다."

#: ../Doc/library/asyncio-eventloop.rst:360
msgid ""
"*protocol_factory* is called without arguments and is expected to return "
"a :ref:`protocol <asyncio-protocol>` instance."
msgstr ""
"*protocol_factory* 가 인자 없이 호출되고, :ref:`프로토콜(protocol) <asyncio-protocol>`"
" 인스턴스를 반환할 것으로 기대됩니다."

#: ../Doc/library/asyncio-eventloop.rst:363
msgid ""
"The protocol instance is coupled with the transport by calling its "
":meth:`~BaseProtocol.connection_made` method."
msgstr "프로토콜 인스턴스는 :meth:`connection_made` 메서드를 호출함으로써 트랜스포트와 연결됩니다."

#: ../Doc/library/asyncio-eventloop.rst:366
msgid "A ``(transport, protocol)`` tuple is returned on success."
msgstr "성공하면 ``(transport, protocol)`` 튜플이 반환됩니다."

#: ../Doc/library/asyncio-eventloop.rst:368
msgid "The created transport is an implementation-dependent bidirectional stream."
msgstr "만들어진 트랜스포트는 구현 의존적인 양방향 스트림입니다."

#: ../Doc/library/asyncio-eventloop.rst:371
#: ../Doc/library/asyncio-eventloop.rst:445
msgid "Other arguments:"
msgstr "다른 인자들:"

#: ../Doc/library/asyncio-eventloop.rst:373
msgid ""
"*ssl*: if given and not false, a SSL/TLS transport is created (by default"
" a plain TCP transport is created).  If *ssl* is a "
":class:`ssl.SSLContext` object, this context is used to create the "
"transport; if *ssl* is :const:`True`, a default context returned from "
":func:`ssl.create_default_context` is used."
msgstr ""
"*ssl*: 주어지고 거짓이 아니면, SSL/TLS 트랜스포트가 만들어집니다 (기본적으로는 평범한 TCP 트랜스포트가 "
"만들어집니다). *ssl* 이 :class:`ssl.SSLContext` 객체면, 트랜스포트를 만들 때 이 컨텍스트가 사용됩니다; "
"*ssl* 이 :const:`True` 면, :func:`ssl.create_default_context` 가 반환하는 기본 "
"컨텍스트가 사용됩니다."

#: ../Doc/library/asyncio-eventloop.rst:379
msgid ":ref:`SSL/TLS security considerations <ssl-security>`"
msgstr ":ref:`SSL/TLS 보안 고려 사항 <ssl-security>`"

#: ../Doc/library/asyncio-eventloop.rst:381
msgid ""
"*server_hostname* sets or overrides the hostname that the target server's"
" certificate will be matched against.  Should only be passed if *ssl* is "
"not ``None``.  By default the value of the *host* argument is used.  If "
"*host* is empty, there is no default and you must pass a value for "
"*server_hostname*.  If *server_hostname* is an empty string, hostname "
"matching is disabled (which is a serious security risk, allowing for "
"potential man-in-the-middle attacks)."
msgstr ""
"*server_hostname*\\는 대상 서버의 인증서가 일치될 호스트 이름을 설정하거나 대체합니다. *ssl*\\이 "
"``None``\\이 아닐 때만 전달되어야 합니다. 기본적으로 *host* 인자의 값이 사용됩니다. *host* 가 비어 있으면, "
"기본값이 없고 *server_hostname* 값을 전달해야 합니다. *server_hostname* 이 빈 문자열이면, 호스트 "
"이름 일치가 비활성화됩니다 (이것은 심각한 보안 위험으로, 잠재적인 중간자 공격을 허용하게 됩니다)."

#: ../Doc/library/asyncio-eventloop.rst:389
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to getaddrinfo() for *host* resolution. If "
"given, these should all be integers from the corresponding :mod:`socket` "
"module constants."
msgstr ""
"*family*, *proto*, *flags* 는 *host* 결정을 위해 getaddrinfo() 에 전달할 선택적 주소 "
"패밀리, 프로토콜, 플래그입니다. 주어지면, 이것들은 모두 해당하는 :mod:`socket` 모듈 상수에 대응하는 정수여야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:394
msgid ""
"*sock*, if given, should be an existing, already connected "
":class:`socket.socket` object to be used by the transport. If *sock* is "
"given, none of *host*, *port*, *family*, *proto*, *flags* and "
"*local_addr* should be specified."
msgstr ""
"*sock* 이 주어지면, 트랜스포트가 사용할, 기존의 이미 연결된 :class:`socket.socket` 객체여야 합니다. "
"*sock* 이 주어지면, *host*, *port*, *family*, *proto*, *flags*, *local_addr* 를"
" 지정해서는 안 됩니다."

#: ../Doc/library/asyncio-eventloop.rst:399
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to "
"bind the socket to locally.  The *local_host* and *local_port* are looked"
" up using ``getaddrinfo()``, similarly to *host* and *port*."
msgstr ""
"*local_addr* 이 주어지면, 소켓을 로컬에 바인드 하는데 사용되는 ``(local_host, local_port)`` "
"튜플이어야 합니다. *local_host* 와 *local_port* 는 *host* 및 *port* 와 유사하게 "
"``getaddrinfo()`` 를 사용하여 조회됩니다."

#: ../Doc/library/asyncio-eventloop.rst:403
#: ../Doc/library/asyncio-eventloop.rst:726
msgid ""
"*ssl_handshake_timeout* is (for a TLS connection) the time in seconds to "
"wait for the TLS handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* 은 (TLS 연결의 경우) 연결을 중단하기 전에 TLS 핸드 셰이크가 완료될 때까지 "
"대기하는 시간(초)입니다. ``None`` (기본값) 이면 ``60.0`` 초가 사용됩니다."

#: ../Doc/library/asyncio-eventloop.rst:409
#: ../Doc/library/asyncio-eventloop.rst:511
#: ../Doc/library/asyncio-eventloop.rst:664
msgid "The *ssl_handshake_timeout* parameter."
msgstr "*ssl_handshake_timeout* 매개 변수."

#: ../Doc/library/asyncio-eventloop.rst:413
#: ../Doc/library/asyncio-eventloop.rst:594
msgid ""
"The socket option :py:data:`~socket.TCP_NODELAY` is set by default for "
"all TCP connections."
msgstr "소켓 옵션 :py:data:`~socket.TCP_NODELAY`\\는 기본적으로 모든 TCP 연결에 대해 설정됩니다."

#: ../Doc/library/asyncio-eventloop.rst:418
#: ../Doc/library/asyncio-eventloop.rst:599
msgid "Added support for SSL/TLS in :class:`ProactorEventLoop`."
msgstr ":class:`ProactorEventLoop`\\에 SSL/TLS에 대한 지원이 추가되었습니다."

#: ../Doc/library/asyncio-eventloop.rst:422
msgid ""
"The :func:`open_connection` function is a high-level alternative API.  It"
" returns a pair of (:class:`StreamReader`, :class:`StreamWriter`) that "
"can be used directly in async/await code."
msgstr ""
":func:`open_connection` 함수는 고수준 대안 API입니다. async/await 코드에서 직접 사용할 수 있는 "
"(:class:`StreamReader`, :class:`StreamWriter`) 쌍을 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:432
msgid "Create a datagram connection."
msgstr "데이터 그램 연결을 만듭니다."

#: ../Doc/library/asyncio-eventloop.rst:434
msgid ""
"The socket family can be either :py:data:`~socket.AF_INET`, "
":py:data:`~socket.AF_INET6`, or :py:data:`~socket.AF_UNIX`, depending on "
"*host* (or the *family* argument, if provided)."
msgstr ""
"소켓 패밀리는 *host*\\(또는 주어지면 *family*)에 따라 :py:data:`~socket.AF_INET`, "
":py:data:`~socket.AF_INET6` 또는 :py:data:`~socket.AF_UNIX`\\일 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:438
msgid "The socket type will be :py:data:`~socket.SOCK_DGRAM`."
msgstr "소켓 유형은 :py:data:`~socket.SOCK_DGRAM`\\이 됩니다."

#: ../Doc/library/asyncio-eventloop.rst:440
#: ../Doc/library/asyncio-eventloop.rst:536
#: ../Doc/library/asyncio-eventloop.rst:647
msgid ""
"*protocol_factory* must be a callable returning a :ref:`protocol "
"<asyncio-protocol>` implementation."
msgstr ""
"*protocol_factory* 는 반드시 :ref:`프로토콜 <asyncio-protocol>` 구현을 반환하는 콜러블이어야 "
"합니다."

#: ../Doc/library/asyncio-eventloop.rst:443
#: ../Doc/library/asyncio-eventloop.rst:497
msgid "A tuple of ``(transport, protocol)`` is returned on success."
msgstr "성공하면 ``(transport, protocol)`` 튜플이 반환됩니다."

#: ../Doc/library/asyncio-eventloop.rst:447
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to "
"bind the socket to locally.  The *local_host* and *local_port* are looked"
" up using :meth:`getaddrinfo`."
msgstr ""
"*local_addr* 이 주어지면, 소켓을 로컬에 바인드 하는 데 사용되는 ``(local_host, local_port)`` "
"튜플입니다. *local_host* 와 *local_port* 는 :meth:`getaddrinfo`\\를 사용하여 조회됩니다."

#: ../Doc/library/asyncio-eventloop.rst:451
msgid ""
"*remote_addr*, if given, is a ``(remote_host, remote_port)`` tuple used "
"to connect the socket to a remote address.  The *remote_host* and "
"*remote_port* are looked up using :meth:`getaddrinfo`."
msgstr ""
"*remote_addr* 이 주어지면, 소켓을 원격 주소에 연결하는 데 사용되는 ``(remote_host, "
"remote_port)`` 튜플입니다. *remote_host* 와 *remote_port* 는 "
":meth:`getaddrinfo`\\를 사용하여 조회됩니다."

#: ../Doc/library/asyncio-eventloop.rst:455
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to :meth:`getaddrinfo` for *host* resolution. "
"If given, these should all be integers from the corresponding "
":mod:`socket` module constants."
msgstr ""
"*family*, *proto*, *flags* 는 *host* 결정을 위해 :meth:`getaddrinfo` 에 전달할 선택적 "
"주소 패밀리, 프로토콜, 플래그입니다. 주어지면, 이것들은 모두 해당하는 :mod:`socket` 모듈 상수에 대응하는 정수여야 "
"합니다."

#: ../Doc/library/asyncio-eventloop.rst:460
#: ../Doc/library/asyncio-eventloop.rst:568
msgid ""
"*reuse_address* tells the kernel to reuse a local socket in ``TIME_WAIT``"
" state, without waiting for its natural timeout to expire. If not "
"specified will automatically be set to ``True`` on Unix."
msgstr ""
"*reuse_address* 는, 일반적인 시간제한이 만료될 때까지 기다리지 않고, ``TIME_WAIT`` 상태의 로컬 소켓을 "
"재사용하도록 커널에 알려줍니다. 지정하지 않으면 유닉스에서 자동으로 ``True`` 로 설정됩니다."

#: ../Doc/library/asyncio-eventloop.rst:465
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the "
"same port as other existing endpoints are bound to, so long as they all "
"set this flag when being created. This option is not supported on Windows"
" and some Unixes. If the :py:data:`~socket.SO_REUSEPORT` constant is not "
"defined then this capability is unsupported."
msgstr ""
"*reuse_port* 는 모두 만들 때 이 플래그를 설정하는 한, 이 말단이 다른 기존 말단이 바인드 된 것과 같은 포트에 바인드"
" 되도록 허용하도록 커널에 알려줍니다. 이 옵션은 윈도우나 일부 유닉스에서는 지원되지 않습니다. "
":py:data:`~socket.SO_REUSEPORT` 상수가 정의되어 있지 않으면, 이 기능은 지원되지 않는 것입니다."

#: ../Doc/library/asyncio-eventloop.rst:471
msgid ""
"*allow_broadcast* tells the kernel to allow this endpoint to send "
"messages to the broadcast address."
msgstr "*allow_broadcast* 는 이 말단이 브로드캐스트 주소로 메시지를 보낼 수 있도록 커널에 알립니다."

#: ../Doc/library/asyncio-eventloop.rst:474
msgid ""
"*sock* can optionally be specified in order to use a preexisting, already"
" connected, :class:`socket.socket` object to be used by the transport. If"
" specified, *local_addr* and *remote_addr* should be omitted (must be "
":const:`None`)."
msgstr ""
"*sock* 은 트랜스포트가 사용할 소켓 객체로, 기존의 이미 연결된 :class:`socket.socket` 객체를 사용하기 위해"
" 선택적으로 지정할 수 있습니다. 지정되면 *local_addr* 과 *remote_addr* 를 생략해야 합니다 (반드시 "
":const:`None` 이어야 합니다)."

#: ../Doc/library/asyncio-eventloop.rst:479
msgid "On Windows, with :class:`ProactorEventLoop`, this method is not supported."
msgstr "윈도우에서, :class:`ProactorEventLoop`\\를 사용할 때, 이 메서드는 지원되지 않습니다."

#: ../Doc/library/asyncio-eventloop.rst:481
msgid ""
"See :ref:`UDP echo client protocol <asyncio-udp-echo-client-protocol>` "
"and :ref:`UDP echo server protocol <asyncio-udp-echo-server-protocol>` "
"examples."
msgstr ""
":ref:`UDP 메아리 클라이언트 프로토콜 <asyncio-udp-echo-client-protocol>` 과 :ref:`UDP "
"메아리 서버 프로토콜 <asyncio-udp-echo-server-protocol>` 예제를 참고하세요."

#: ../Doc/library/asyncio-eventloop.rst:484
msgid ""
"The *family*, *proto*, *flags*, *reuse_address*, *reuse_port, "
"*allow_broadcast*, and *sock* parameters were added."
msgstr ""
"*family*, *proto*, *flags*, *reuse_address*, *reuse_port*, "
"*allow_broadcast*, *sock* 매개 변수가 추가되었습니다."

#: ../Doc/library/asyncio-eventloop.rst:492
msgid "Create a Unix connection."
msgstr "유닉스 연결을 만듭니다."

#: ../Doc/library/asyncio-eventloop.rst:494
msgid ""
"The socket family will be :py:data:`~socket.AF_UNIX`; socket type will be"
" :py:data:`~socket.SOCK_STREAM`."
msgstr ""
"소켓 패밀리는 :py:data:`~socket.AF_UNIX`\\가 됩니다; 소켓 유형은 "
":py:data:`~socket.SOCK_STREAM`\\이 됩니다."

#: ../Doc/library/asyncio-eventloop.rst:499
msgid ""
"*path* is the name of a Unix domain socket and is required, unless a "
"*sock* parameter is specified.  Abstract Unix sockets, :class:`str`, "
":class:`bytes`, and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* 는 유닉스 도메인 소켓의 이름이며, *sock* 매개 변수가 지정되지 않으면 필수입니다. 추상 유닉스 소켓, "
":class:`str`, :class:`bytes`, :class:`~pathlib.Path` 경로가 지원됩니다."

#: ../Doc/library/asyncio-eventloop.rst:504
msgid ""
"See the documentation of the :meth:`loop.create_connection` method for "
"information about arguments to this method."
msgstr "이 메서드의 인자에 관한 정보는 :meth:`loop.create_connection` 메서드의 설명서를 참조하십시오."

#: ../Doc/library/asyncio-eventloop.rst:508
#: ../Doc/library/asyncio-eventloop.rst:628
#: ../Doc/library/asyncio-eventloop.rst:984
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`가용성 <availability>`: 유닉스."

#: ../Doc/library/asyncio-eventloop.rst:515
msgid "The *path* parameter can now be a :term:`path-like object`."
msgstr "*path* 매개 변수는 이제 :term:`경로류 객체 <path-like object>` 가 될 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:519
msgid "Creating network servers"
msgstr "네트워크 서버 만들기"

#: ../Doc/library/asyncio-eventloop.rst:529
msgid ""
"Create a TCP server (socket type :data:`~socket.SOCK_STREAM`) listening "
"on *port* of the *host* address."
msgstr ""
"*host* 주소의 *port* 에서 리스닝하는 TCP 서버(소켓 유형 :data:`~socket.SOCK_STREAM`)를 "
"만듭니다."

#: ../Doc/library/asyncio-eventloop.rst:532
msgid "Returns a :class:`Server` object."
msgstr ":class:`Server` 객체를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:534
msgid "Arguments:"
msgstr "인자:"

#: ../Doc/library/asyncio-eventloop.rst:539
msgid ""
"The *host* parameter can be set to several types which determine where "
"the server would be listening:"
msgstr "*host* 매개 변수는 서버가 리스닝할 위치를 결정하는 여러 형으로 설정할 수 있습니다.:"

#: ../Doc/library/asyncio-eventloop.rst:542
msgid ""
"If *host* is a string, the TCP server is bound to a single network "
"interface specified by *host*."
msgstr "*host*\\가 문자열이면, TCP 서버는 *host*\\로 지정된 단일 네트워크 인터페이스에 바인딩 됩니다."

#: ../Doc/library/asyncio-eventloop.rst:545
msgid ""
"If *host* is a sequence of strings, the TCP server is bound to all "
"network interfaces specified by the sequence."
msgstr "*host*\\가 문자열의 시퀀스면, TCP 서버는 시퀀스로 지정된 모든 네트워크 인터페이스에 바인딩 됩니다."

#: ../Doc/library/asyncio-eventloop.rst:548
msgid ""
"If *host* is an empty string or ``None``, all interfaces are assumed and "
"a list of multiple sockets will be returned (most likely one for IPv4 and"
" another one for IPv6)."
msgstr ""
"*host*\\가 빈 문자열이거나 ``None``\\이면, 모든 인터페이스가 사용되는 것으로 가정하고, 여러 소켓의 리스트가 "
"반환됩니다 (대체로 IPv4 하나와 IPv6 하나)."

#: ../Doc/library/asyncio-eventloop.rst:552
msgid ""
"*family* can be set to either :data:`socket.AF_INET` or "
":data:`~socket.AF_INET6` to force the socket to use IPv4 or IPv6. If not "
"set, the *family* will be determined from host name (defaults to "
":data:`~socket.AF_UNSPEC`)."
msgstr ""
"*family* 는 :data:`socket.AF_INET` 또는 :data:`~socket.AF_INET6` 중 하나로 설정되어,"
" 소켓이 IPv4 또는 IPv6을 사용하게 할 수 있습니다. 설정되지 않으면, *family* 는 호스트 이름에 의해 "
"결정됩니다(기본값 :data:`socket.AF_UNSPEC`)."

#: ../Doc/library/asyncio-eventloop.rst:557
msgid "*flags* is a bitmask for :meth:`getaddrinfo`."
msgstr "*flags* 은 :meth:`getaddrinfo`\\를 위한 비트 마스크입니다."

#: ../Doc/library/asyncio-eventloop.rst:559
msgid ""
"*sock* can optionally be specified in order to use a preexisting socket "
"object. If specified, *host* and *port* must not be specified."
msgstr ""
"*sock* 은 기존 소켓 객체를 사용하기 위해 선택적으로 지정할 수 있습니다. 지정되면, *host* 및 *port* 는 지정할 "
"수 없습니다."

#: ../Doc/library/asyncio-eventloop.rst:562
msgid ""
"*backlog* is the maximum number of queued connections passed to "
":meth:`~socket.socket.listen` (defaults to 100)."
msgstr ""
"*backlog* 는 :meth:`~socket.socket.listen` 으로 전달되는 최대 대기 연결 수 입니다 (기본값은 "
"100)."

#: ../Doc/library/asyncio-eventloop.rst:565
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` instance to enable TLS "
"over the accepted connections."
msgstr "*ssl* 을 :class:`~ssl.SSLContext` 인스턴스로 설정하면, 들어오는 연결에 TLS를 사용합니다."

#: ../Doc/library/asyncio-eventloop.rst:573
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the "
"same port as other existing endpoints are bound to, so long as they all "
"set this flag when being created. This option is not supported on "
"Windows."
msgstr ""
"*reuse_port* 는 모두 만들 때 이 플래그를 설정하는 한, 이 말단이 다른 기존 말단이 바인드 된 것과 같은 포트에 바인드"
" 되도록 허용하도록 커널에 알려줍니다. 이 옵션은 윈도우에서 지원되지 않습니다."

#: ../Doc/library/asyncio-eventloop.rst:578
msgid ""
"*ssl_handshake_timeout* is (for a TLS server) the time in seconds to wait"
" for the TLS handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* 은 (TLS 서버의 경우) 연결을 중단하기 전에 TLS 핸드 셰이크가 완료될 때까지 "
"대기하는 시간(초)입니다. ``None`` (기본값) 이면 ``60.0`` 초가 사용됩니다."

#: ../Doc/library/asyncio-eventloop.rst:582
msgid ""
"*start_serving* set to ``True`` (the default) causes the created server "
"to start accepting connections immediately.  When set to ``False``, the "
"user should await on :meth:`Server.start_serving` or "
":meth:`Server.serve_forever` to make the server to start accepting "
"connections."
msgstr ""
"*start_serving* 을 ``True`` (기본값) 로 설정하면, 생성된 서버가 즉시 연결을 받아들입니다. ``False``"
" 로 설정되면, 사용자는 서버가 연결을 받기 시작하도록 :meth:`Server.start_serving` 이나 "
":meth:`Server.serve_forever`\\를 await 해야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:590
msgid "Added *ssl_handshake_timeout* and *start_serving* parameters."
msgstr "*ssl_handshake_timeout* 과 *start_serving* 매개 변수 추가."

#: ../Doc/library/asyncio-eventloop.rst:603
msgid "The *host* parameter can be a sequence of strings."
msgstr "*host* 매개 변수는 문자열의 시퀀스가 될 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:607
msgid ""
"The :func:`start_server` function is a higher-level alternative API that "
"returns a pair of :class:`StreamReader` and :class:`StreamWriter` that "
"can be used in an async/await code."
msgstr ""
":func:`start_server` 함수는 async/await 코드에서 사용할 수 있는 :class:`StreamReader` "
"및 :class:`StreamWriter` 쌍을 반환하는 고수준의 대체 API입니다."

#: ../Doc/library/asyncio-eventloop.rst:616
msgid ""
"Similar to :meth:`loop.create_server` but works with the "
":py:data:`~socket.AF_UNIX` socket family."
msgstr ""
":meth:`loop.create_server`\\와 유사하지만, 소켓 패밀리 :py:data:`~socket.AF_UNIX` "
"용입니다."

#: ../Doc/library/asyncio-eventloop.rst:619
msgid ""
"*path* is the name of a Unix domain socket, and is required, unless a "
"*sock* argument is provided.  Abstract Unix sockets, :class:`str`, "
":class:`bytes`, and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* 는 유닉스 도메인 소켓의 이름이며, *sock* 매개 변수가 제공되지 않으면 필수입니다. 추상 유닉스 소켓, "
":class:`str`, :class:`bytes`, :class:`~pathlib.Path` 경로가 지원됩니다."

#: ../Doc/library/asyncio-eventloop.rst:624
msgid ""
"See the documentation of the :meth:`loop.create_server` method for "
"information about arguments to this method."
msgstr "이 메서드의 인자에 대한 정보는 :meth:`loop.create_server` 메서드의 설명서를 참조하십시오."

#: ../Doc/library/asyncio-eventloop.rst:631
msgid "The *ssl_handshake_timeout* and *start_serving* parameters."
msgstr "*ssl_handshake_timeout* 과 *start_serving* 매개 변수."

#: ../Doc/library/asyncio-eventloop.rst:635
msgid "The *path* parameter can now be a :class:`~pathlib.Path` object."
msgstr "*path* 매개 변수는 이제 :class:`~pathlib.Path` 객체일 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:640
msgid "Wrap an already accepted connection into a transport/protocol pair."
msgstr "이미 받아들인 연결을 트랜스포트/프로토콜 쌍으로 래핑합니다."

#: ../Doc/library/asyncio-eventloop.rst:642
msgid ""
"This method can be used by servers that accept connections outside of "
"asyncio but that use asyncio to handle them."
msgstr "이 메서드는 asyncio 밖에서 연결을 받아들이지만, 그 연결을 처리하는데 asyncio 를 사용하는 서버에서 사용됩니다."

#: ../Doc/library/asyncio-eventloop.rst:645
#: ../Doc/library/asyncio-eventloop.rst:712
msgid "Parameters:"
msgstr "매개 변수:"

#: ../Doc/library/asyncio-eventloop.rst:650
msgid ""
"*sock* is a preexisting socket object returned from :meth:`socket.accept "
"<socket.socket.accept>`."
msgstr ""
"*sock* 은 :meth:`socket.accept <socket.socket.accept>` 가 반환한 기존 소켓 객체입니다."

#: ../Doc/library/asyncio-eventloop.rst:653
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` to enable SSL over the "
"accepted connections."
msgstr "*ssl* 을 :class:`~ssl.SSLContext` 로 설정하면, 들어오는 연결에 SSL을 사용합니다."

#: ../Doc/library/asyncio-eventloop.rst:656
msgid ""
"*ssl_handshake_timeout* is (for an SSL connection) the time in seconds to"
" wait for the SSL handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* 은 (SSL 연결의 경우) 연결을 중단하기 전에 SSL 핸드 셰이크가 완료될 때까지 "
"대기하는 시간(초)입니다. ``None`` (기본값) 이면 ``60.0`` 초가 사용됩니다."

#: ../Doc/library/asyncio-eventloop.rst:660
msgid "Returns a ``(transport, protocol)`` pair."
msgstr "``(transport, protocol)`` 쌍을 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:670
msgid "Transferring files"
msgstr "파일 전송"

#: ../Doc/library/asyncio-eventloop.rst:675
msgid "Send a *file* over a *transport*.  Return the total number of bytes sent."
msgstr "*file* 을 *transport* 로 보냅니다. 전송된 총 바이트 수를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:678
msgid "The method uses high-performance :meth:`os.sendfile` if available."
msgstr "이 메서드는 가능한 경우 고성능 :meth:`os.sendfile` 을 사용합니다."

#: ../Doc/library/asyncio-eventloop.rst:680
msgid "*file* must be a regular file object opened in binary mode."
msgstr "*file* 는 바이너리 모드로 열린 일반 파일 객체여야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:682
#: ../Doc/library/asyncio-eventloop.rst:872
msgid ""
"*offset* tells from where to start reading the file. If specified, "
"*count* is the total number of bytes to transmit as opposed to sending "
"the file until EOF is reached. File position is always updated, even when"
" this method raises an error, and :meth:`file.tell() <io.IOBase.tell>` "
"can be used to obtain the actual number of bytes sent."
msgstr ""
"*offset* 은 파일 읽기 시작할 위치를 알려줍니다. *count* 를 제공하면, EOF에 도달할 때까지 파일을 보내는 대신, "
"전송할 총 바이트 수를 지정합니다. 파일의 위치가 갱신됩니다, 이 메서드가 에러를 일으킬 때조차. 그리고, "
":meth:`file.tell() <io.IOBase.tell>` 는 실제 전송된 바이트 수를 얻는 데 사용될 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:689
msgid ""
"*fallback* set to ``True`` makes asyncio to manually read and send the "
"file when the platform does not support the sendfile system call (e.g. "
"Windows or SSL socket on Unix)."
msgstr ""
"*fallback* 을 ``True`` 로 설정하면, 플랫폼이 sendfile 시스템 호출을 지원하지 않을 때 (가령 유닉스에서 "
"SSL 소켓을 사용하거나 윈도우인 경우), asyncio 가 파일을 수동으로 읽고 보내도록 합니다."

#: ../Doc/library/asyncio-eventloop.rst:693
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support the"
" *sendfile* syscall and *fallback* is ``False``."
msgstr ""
"시스템이 *sendfile* 시스템 호출을 지원하지 않고 *fallback* 이 ``False`` 면 "
":exc:`SendfileNotAvailableError` 를 발생시킵니다."

#: ../Doc/library/asyncio-eventloop.rst:700
msgid "TLS Upgrade"
msgstr "TLS 업그레이드"

#: ../Doc/library/asyncio-eventloop.rst:706
msgid "Upgrade an existing transport-based connection to TLS."
msgstr "기존 트랜스포트 기반 연결을 TLS로 업그레이드합니다."

#: ../Doc/library/asyncio-eventloop.rst:708
msgid ""
"Return a new transport instance, that the *protocol* must start using "
"immediately after the *await*.  The *transport* instance passed to the "
"*start_tls* method should never be used again."
msgstr ""
"*protocol* 이 *await* 의 직후에 사용해야 하는 새로운 트랜스포트 인스턴스를 반환합니다. *start_tls* "
"메서드에 전달된 *transport* 인스턴스는 절대로 다시 사용해서는 안 됩니다."

#: ../Doc/library/asyncio-eventloop.rst:714
msgid ""
"*transport* and *protocol* instances that methods like "
":meth:`~loop.create_server` and :meth:`~loop.create_connection` return."
msgstr ""
":meth:`~loop.create_server`\\와 :meth:`~loop.create_connection` 같은 메서드가 "
"반환하는 *transport* 와 *protocol* 인스턴스."

#: ../Doc/library/asyncio-eventloop.rst:718
msgid "*sslcontext*: a configured instance of :class:`~ssl.SSLContext`."
msgstr "*sslcontext*: 구성된 :class:`~ssl.SSLContext` 의 인스턴스."

#: ../Doc/library/asyncio-eventloop.rst:720
msgid ""
"*server_side* pass ``True`` when a server-side connection is being "
"upgraded (like the one created by :meth:`~loop.create_server`)."
msgstr ""
"(:meth:`~loop.create_server` 에 의해 생성된 것과 같은) 서버 측 연결이 업그레이드될 때 "
"*server_side* 에 ``True`` 를 전달합니다."

#: ../Doc/library/asyncio-eventloop.rst:723
msgid ""
"*server_hostname*: sets or overrides the host name that the target "
"server's certificate will be matched against."
msgstr "*server_hostname*: 대상 서버의 인증서가 일치될 호스트 이름을 설정하거나 대체합니다."

#: ../Doc/library/asyncio-eventloop.rst:734
msgid "Watching file descriptors"
msgstr "파일 기술자 관찰하기"

#: ../Doc/library/asyncio-eventloop.rst:738
msgid ""
"Start monitoring the *fd* file descriptor for read availability and "
"invoke *callback* with the specified arguments once *fd* is available for"
" reading."
msgstr ""
"*fd* 파일 기술자가 읽기 가능한지 관찰하기 시작하고, 일단 *fd*\\가 읽기 가능해지면 지정한 인자로 *callback* 을 "
"호출합니다."

#: ../Doc/library/asyncio-eventloop.rst:744
msgid "Stop monitoring the *fd* file descriptor for read availability."
msgstr "*fd* 파일 기술자가 읽기 가능한지 관찰하는 것을 중단합니다."

#: ../Doc/library/asyncio-eventloop.rst:748
msgid ""
"Start monitoring the *fd* file descriptor for write availability and "
"invoke *callback* with the specified arguments once *fd* is available for"
" writing."
msgstr ""
"*fd* 파일 기술자가 쓰기 가능한지 관찰하기 시작하고, 일단 *fd*\\가 쓰기 가능해지면 지정한 인자로 *callback* 을 "
"호출합니다."

#: ../Doc/library/asyncio-eventloop.rst:752
#: ../Doc/library/asyncio-eventloop.rst:971
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-"
"pass-keywords>` to *callback*."
msgstr ""
"*callback* 에 :ref:`키워드 인자를 전달하려면 <asyncio-pass-keywords>` "
":func:`functools.partial`\\를 사용하십시오."

#: ../Doc/library/asyncio-eventloop.rst:757
msgid "Stop monitoring the *fd* file descriptor for write availability."
msgstr "*fd* 파일 기술자가 쓰기 가능한지 관찰하는 것을 중단합니다."

#: ../Doc/library/asyncio-eventloop.rst:759
msgid ""
"See also :ref:`Platform Support <asyncio-platform-support>` section for "
"some limitations of these methods."
msgstr "이 메서드의 일부 제한 사항은 :ref:`플랫폼 지원 <asyncio-platform-support>` 절을 참조하십시오."

#: ../Doc/library/asyncio-eventloop.rst:764
msgid "Working with socket objects directly"
msgstr "소켓 객체로 직접 작업하기"

#: ../Doc/library/asyncio-eventloop.rst:766
msgid ""
"In general, protocol implementations that use transport-based APIs such "
"as :meth:`loop.create_connection` and :meth:`loop.create_server` are "
"faster than implementations that work with sockets directly. However, "
"there are some use cases when performance is not critical, and working "
"with :class:`~socket.socket` objects directly is more convenient."
msgstr ""
"일반적으로 :meth:`loop.create_connection` 및 :meth:`loop.create_server`\\와 같은 "
"트랜스포트 기반 API를 사용하는 프로토콜 구현은 소켓을 직접 사용하는 구현보다 빠릅니다. 그러나, 성능이 결정적이지 않고 "
":class:`~socket.socket` 객체로 직접 작업하는 것이 더 편리한 사용 사례가 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:775
msgid ""
"Receive up to *nbytes* from *sock*.  Asynchronous version of "
":meth:`socket.recv() <socket.socket.recv>`."
msgstr ""
"*sock* 에서 최대 *nbytes* 를 수신합니다. :meth:`socket.recv() <socket.socket.recv>`"
" 의 비동기 버전."

#: ../Doc/library/asyncio-eventloop.rst:778
msgid "Return the received data as a bytes object."
msgstr "수신한 데이터를 바이트열 객체로 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:780
#: ../Doc/library/asyncio-eventloop.rst:794
#: ../Doc/library/asyncio-eventloop.rst:809
#: ../Doc/library/asyncio-eventloop.rst:822
#: ../Doc/library/asyncio-eventloop.rst:848
#: ../Doc/library/asyncio-eventloop.rst:886
msgid "*sock* must be a non-blocking socket."
msgstr "*sock* 은 반드시 비 블로킹 소켓이어야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:782
msgid ""
"Even though this method was always documented as a coroutine method, "
"releases before Python 3.7 returned a :class:`Future`. Since Python 3.7 "
"this is an ``async def`` method."
msgstr ""
"이 메서드가 항상 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에는 :class:`Future`\\를 반환했습니다. 파이썬 "
"3.7부터, 이것은 ``async def`` 메서드입니다."

#: ../Doc/library/asyncio-eventloop.rst:789
msgid ""
"Receive data from *sock* into the *buf* buffer.  Modeled after the "
"blocking :meth:`socket.recv_into() <socket.socket.recv_into>` method."
msgstr ""
"*sock* 에서 *buf* 버퍼로 데이터를 수신합니다. 블로킹 :meth:`socket.recv_into() "
"<socket.socket.recv_into>` 메서드를 따라 만들어졌습니다."

#: ../Doc/library/asyncio-eventloop.rst:792
msgid "Return the number of bytes written to the buffer."
msgstr "버퍼에 기록된 바이트 수를 돌려줍니다."

#: ../Doc/library/asyncio-eventloop.rst:800
msgid ""
"Send *data* to the *sock* socket. Asynchronous version of "
":meth:`socket.sendall() <socket.socket.sendall>`."
msgstr ""
"*data* 를 *sock* 소켓으로 보냅니다. :meth:`socket.sendall() "
"<socket.socket.sendall>` 의 비동기 버전."

#: ../Doc/library/asyncio-eventloop.rst:803
msgid ""
"This method continues to send to the socket until either all data in "
"*data* has been sent or an error occurs.  ``None`` is returned on "
"success.  On error, an exception is raised. Additionally, there is no way"
" to determine how much data, if any, was successfully processed by the "
"receiving end of the connection."
msgstr ""
"이 메서드는 *data* 의 모든 데이터가 송신되거나 에러가 발생할 때까지 소켓으로 계속 송신합니다. 성공하면 ``None`` 이 "
"반환됩니다. 에러가 발생하면 예외가 발생합니다. 또한, 연결의 수신 단에서 성공적으로 처리한 (있기는 하다면) 데이터의 크기를 "
"확인하는 방법은 없습니다."

#: ../Doc/library/asyncio-eventloop.rst:811
msgid ""
"Even though the method was always documented as a coroutine method, "
"before Python 3.7 it returned an :class:`Future`. Since Python 3.7, this "
"is an ``async def`` method."
msgstr ""
"이 메서드가 항상 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에는 :class:`Future`\\를 반환했습니다. 파이썬 "
"3.7부터, 이것은 ``async def`` 메서드입니다."

#: ../Doc/library/asyncio-eventloop.rst:818
msgid "Connect *sock* to a remote socket at *address*."
msgstr "*sock*\\을 *address*\\에 있는 원격 소켓에 연결합니다."

#: ../Doc/library/asyncio-eventloop.rst:820
msgid "Asynchronous version of :meth:`socket.connect() <socket.socket.connect>`."
msgstr ":meth:`socket.connect() <socket.socket.connect>` 의 비동기 버전."

#: ../Doc/library/asyncio-eventloop.rst:824
msgid ""
"``address`` no longer needs to be resolved.  ``sock_connect`` will try to"
" check if the *address* is already resolved by calling "
":func:`socket.inet_pton`.  If not, :meth:`loop.getaddrinfo` will be used "
"to resolve the *address*."
msgstr ""
"``address`` 는 더는 결정될 필요가 없습니다. ``sock_connect`` 는 "
":func:`socket.inet_pton`\\을 호출하여 *address* 가 이미 결정되었는지를 검사합니다. 그렇지 않으면, "
":meth:`loop.getaddrinfo` 가 *address* 를 결정하는 데 사용됩니다."

#: ../Doc/library/asyncio-eventloop.rst:833
msgid ""
":meth:`loop.create_connection` and  :func:`asyncio.open_connection() "
"<open_connection>`."
msgstr ""
":meth:`loop.create_connection`\\과 :func:`asyncio.open_connection() "
"<open_connection>`."

#: ../Doc/library/asyncio-eventloop.rst:839
msgid ""
"Accept a connection.  Modeled after the blocking :meth:`socket.accept() "
"<socket.socket.accept>` method."
msgstr ""
"연결을 받아들입니다. 블로킹 :meth:`socket.accept() <socket.socket.accept>` 메서드를 따라 "
"만들어졌습니다."

#: ../Doc/library/asyncio-eventloop.rst:842
msgid ""
"The socket must be bound to an address and listening for connections. The"
" return value is a pair ``(conn, address)`` where *conn* is a *new* "
"socket object usable to send and receive data on the connection, and "
"*address* is the address bound to the socket on the other end of the "
"connection."
msgstr ""
"소켓은 주소에 바인드 되어 연결을 리스닝해야 합니다. 반환 값은 ``(conn, address)`` 쌍인데, *conn* 은 연결로"
" 데이터를 주고받을 수 있는 *새* 소켓 객체이고, *address* 는 연결의 반대편 끝의 소켓에 바인드 된 주소입니다."

#: ../Doc/library/asyncio-eventloop.rst:850
msgid ""
"Even though the method was always documented as a coroutine method, "
"before Python 3.7 it returned a :class:`Future`. Since Python 3.7, this "
"is an ``async def`` method."
msgstr ""
"이 메서드가 항상 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에는 :class:`Future`\\를 반환했습니다. 파이썬 "
"3.7부터, 이것은 ``async def`` 메서드입니다."

#: ../Doc/library/asyncio-eventloop.rst:857
msgid ":meth:`loop.create_server` and :func:`start_server`."
msgstr ":meth:`loop.create_server`\\와 :func:`start_server`."

#: ../Doc/library/asyncio-eventloop.rst:862
msgid ""
"Send a file using high-performance :mod:`os.sendfile` if possible. Return"
" the total number of bytes sent."
msgstr "가능하면 고성능 :mod:`os.sendfile` 을 사용하여 파일을 보냅니다. 전송된 총 바이트 수를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:865
msgid ""
"Asynchronous version of :meth:`socket.sendfile() "
"<socket.socket.sendfile>`."
msgstr ":meth:`socket.sendfile() <socket.socket.sendfile>`\\의 비동기 버전."

#: ../Doc/library/asyncio-eventloop.rst:867
msgid ""
"*sock* must be a non-blocking :const:`socket.SOCK_STREAM` "
":class:`~socket.socket`."
msgstr ""
"*sock* 은 반드시 비 블로킹 :const:`socket.SOCK_STREAM` :class:`~socket.socket` "
"이어야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:870
msgid "*file* must be a regular file object open in binary mode."
msgstr "*file* 는 바이너리 모드로 열린 일반 파일 객체여야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:879
msgid ""
"*fallback*, when set to ``True``, makes asyncio manually read and send "
"the file when the platform does not support the sendfile syscall (e.g. "
"Windows or SSL socket on Unix)."
msgstr ""
"*fallback* 을 ``True`` 로 설정하면, 플랫폼이 sendfile 시스템 호출을 지원하지 않을 때 (가령 유닉스에서 "
"SSL 소켓을 사용하거나 윈도우인 경우), asyncio 가 파일을 수동으로 읽고 보내도록 합니다."

#: ../Doc/library/asyncio-eventloop.rst:883
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"시스템이 *sendfile* 시스템 호출을 지원하지 않고 *fallback* 이 ``False`` 면 "
":exc:`SendfileNotAvailableError` 를 발생시킵니다."

#: ../Doc/library/asyncio-eventloop.rst:892
msgid "DNS"
msgstr "DNS"

#: ../Doc/library/asyncio-eventloop.rst:897
msgid "Asynchronous version of :meth:`socket.getaddrinfo`."
msgstr ":meth:`socket.getaddrinfo` 의 비동기 버전."

#: ../Doc/library/asyncio-eventloop.rst:901
msgid "Asynchronous version of :meth:`socket.getnameinfo`."
msgstr ":meth:`socket.getnameinfo` 의 비동기 버전."

#: ../Doc/library/asyncio-eventloop.rst:903
msgid ""
"Both *getaddrinfo* and *getnameinfo* methods were always documented to "
"return a coroutine, but prior to Python 3.7 they were, in fact, returning"
" :class:`asyncio.Future` objects.  Starting with Python 3.7 both methods "
"are coroutines."
msgstr ""
"*getaddrinfo* 와 *getnameinfo* 메서드는 모두 코루틴 메서드라고 설명되어왔지만, 파이썬 3.7 이전에 실제로는"
" :class:`asyncio.Future` 객체를 반환했습니다. 파이썬 3.7부터 두 가지 메서드 모두 코루틴입니다."

#: ../Doc/library/asyncio-eventloop.rst:911
msgid "Working with pipes"
msgstr "파이프로 작업하기"

#: ../Doc/library/asyncio-eventloop.rst:915
msgid "Register the read end of *pipe* in the event loop."
msgstr "이벤트 루프에 *pipe*\\의 읽기용 끝을 등록합니다."

#: ../Doc/library/asyncio-eventloop.rst:920
msgid "*pipe* is a :term:`file-like object <file object>`."
msgstr "*pipe*\\는 :term:`파일류 객체 <file object>`\\입니다."

#: ../Doc/library/asyncio-eventloop.rst:922
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports the "
":class:`ReadTransport` interface and *protocol* is an object instantiated"
" by the *protocol_factory*."
msgstr ""
"쌍 ``(transport, protocol)``\\를 반환합니다. 여기서 *transport*\\는 "
":class:`ReadTransport` 인터페이스를 지원하고, *protocol*\\은 *protocol_factory*\\에 "
"의해 인스턴스로 만들어진 객체입니다."

#: ../Doc/library/asyncio-eventloop.rst:926
#: ../Doc/library/asyncio-eventloop.rst:942
msgid ""
"With :class:`SelectorEventLoop` event loop, the *pipe* is set to non-"
"blocking mode."
msgstr ":class:`SelectorEventLoop` 이벤트 루프를 사용하면, *pipe* 는 비 블로킹 모드로 설정됩니다."

#: ../Doc/library/asyncio-eventloop.rst:931
msgid "Register the write end of *pipe* in the event loop."
msgstr "이벤트 루프에 *pipe*\\의 쓰기용 끝을 등록합니다."

#: ../Doc/library/asyncio-eventloop.rst:936
msgid "*pipe* is :term:`file-like object <file object>`."
msgstr "*pipe*\\는 :term:`파일류 객체 <file object>`\\입니다."

#: ../Doc/library/asyncio-eventloop.rst:938
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports "
":class:`WriteTransport` interface and *protocol* is an object "
"instantiated by the *protocol_factory*."
msgstr ""
"쌍 ``(transport, protocol)``\\를 반환합니다. 여기서 *transport*\\는 "
":class:`WriteTransport` 인터페이스를 지원하고, *protocol*\\은 *protocol_factory*\\에 "
"의해 인스턴스로 만들어진 객체입니다."

#: ../Doc/library/asyncio-eventloop.rst:947
msgid ""
":class:`SelectorEventLoop` does not support the above methods on Windows."
"  Use :class:`ProactorEventLoop` instead for Windows."
msgstr ""
"윈도우에서 :class:`SelectorEventLoop`\\는 위의 메서드들을 지원하지 않습니다. 윈도우에서는 대신 "
":class:`ProactorEventLoop`\\를 사용하십시오."

#: ../Doc/library/asyncio-eventloop.rst:952
msgid ""
"The :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` "
"methods."
msgstr ":meth:`loop.subprocess_exec` 와 :meth:`loop.subprocess_shell` 메서드."

#: ../Doc/library/asyncio-eventloop.rst:957
msgid "Unix signals"
msgstr "유닉스 시그널"

#: ../Doc/library/asyncio-eventloop.rst:961
msgid "Set *callback* as the handler for the *signum* signal."
msgstr "*callback*\\을 *signum* 시그널의 처리기로 설정합니다."

#: ../Doc/library/asyncio-eventloop.rst:963
msgid ""
"The callback will be invoked by *loop*, along with other queued callbacks"
" and runnable coroutines of that event loop. Unlike signal handlers "
"registered using :func:`signal.signal`, a callback registered with this "
"function is allowed to interact with the event loop."
msgstr ""
"콜백은 다른 대기 중인 콜백과 해당 이벤트 루프의 실행 가능한 코루틴과 함께 *loop*\\에 의해 호출됩니다. "
":func:`signal.signal`\\을 사용하여 등록된 시그널 처리기와 달리, 이 함수로 등록된 콜백은 이벤트 루프와 상호 작용할 "
"수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:968
msgid ""
"Raise :exc:`ValueError` if the signal number is invalid or uncatchable. "
"Raise :exc:`RuntimeError` if there is a problem setting up the handler."
msgstr ""
"시그널 번호가 유효하지 않거나 잡을 수 없으면 :exc:`ValueError` 를 발생시킵니다. 처리기를 설정하는 데 문제가 있는 "
"경우 :exc:`RuntimeError` 를 발생시킵니다."

#: ../Doc/library/asyncio-eventloop.rst:974
msgid ""
"Like :func:`signal.signal`, this function must be invoked in the main "
"thread."
msgstr ":func:`signal.signal`\\와 마찬가지로, 이 함수는 메인 스레드에서 호출되어야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:979
msgid "Remove the handler for the *sig* signal."
msgstr "*sig* 시그널의 처리기를 제거합니다."

#: ../Doc/library/asyncio-eventloop.rst:981
msgid ""
"Return ``True`` if the signal handler was removed, or ``False`` if no "
"handler was set for the given signal."
msgstr "시그널 처리기가 제거되면 ``True`` 를, 주어진 시그널에 처리기가 설정되지 않았으면 ``False`` 를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:988
msgid "The :mod:`signal` module."
msgstr ":mod:`signal` 모듈."

#: ../Doc/library/asyncio-eventloop.rst:992
msgid "Executing code in thread or process pools"
msgstr "스레드 또는 프로세스 풀에서 코드를 실행하기"

#: ../Doc/library/asyncio-eventloop.rst:996
msgid "Arrange for *func* to be called in the specified executor."
msgstr "지정된 실행기에서 *func* 가 호출되도록 배치합니다."

#: ../Doc/library/asyncio-eventloop.rst:998
msgid ""
"The *executor* argument should be an :class:`concurrent.futures.Executor`"
" instance. The default executor is used if *executor* is ``None``."
msgstr ""
"*executor* 인자는 :class:`~concurrent.futures.Executor` 인스턴스여야 합니다. "
"*executor* 가 ``None`` 이면 기본 실행기가 사용됩니다."

#: ../Doc/library/asyncio-eventloop.rst:1042
msgid "This method returns a :class:`asyncio.Future` object."
msgstr "이 메서드는 :class:`asyncio.Future` 객체를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:1044
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-"
"pass-keywords>` to *func*."
msgstr ""
"*func* 에 :ref:`키워드 인자를 전달하려면 <asyncio-pass-keywords>` "
":func:`functools.partial`\\를 사용하십시오."

#: ../Doc/library/asyncio-eventloop.rst:1047
msgid ""
":meth:`loop.run_in_executor` no longer configures the ``max_workers`` of "
"the thread pool executor it creates, instead leaving it up to the thread "
"pool executor (:class:`~concurrent.futures.ThreadPoolExecutor`) to set "
"the default."
msgstr ""
":meth:`loop.run_in_executor` 는 더는 자신이 만드는 스레드 풀 실행기의 ``max_workers`` 를 "
"설정하지 않습니다. 대신 스레드 풀 실행기(:class:`~concurrent.futures.ThreadPoolExecutor`)가"
" 스스로 기본값을 설정하도록 합니다."

#: ../Doc/library/asyncio-eventloop.rst:1056
msgid ""
"Set *executor* as the default executor used by :meth:`run_in_executor`. "
"*executor* should be an instance of "
":class:`~concurrent.futures.ThreadPoolExecutor`."
msgstr ""
"*executor*\\를 :meth:`run_in_executor`\\에서 사용하는 기본 실행기로 설정합니다. "
"*executor*\\는 :class:`~concurrent.futures.ThreadPoolExecutor`\\의 인스턴스여야 "
"합니다."

#: ../Doc/library/asyncio-eventloop.rst:1060
msgid ""
"Using an executor that is not an instance of "
":class:`~concurrent.futures.ThreadPoolExecutor` is deprecated and will "
"trigger an error in Python 3.9."
msgstr ""
":class:`~concurrent.futures.ThreadPoolExecutor` 인스턴스가 아닌 실행기의 사용은 폐지되었고, "
"파이썬 3.9에서는 에러를 일으키게 됩니다."

#: ../Doc/library/asyncio-eventloop.rst:1065
msgid ""
"*executor* must be an instance of "
":class:`concurrent.futures.ThreadPoolExecutor`."
msgstr ""
"*executor*\\는 반드시 :class:`concurrent.futures.ThreadPoolExecutor`\\의 "
"인스턴스여야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:1070
msgid "Error Handling API"
msgstr "에러 처리 API"

#: ../Doc/library/asyncio-eventloop.rst:1072
msgid "Allows customizing how exceptions are handled in the event loop."
msgstr "이벤트 루프에서 예외를 처리하는 방법을 사용자 정의 할 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:1076
msgid "Set *handler* as the new event loop exception handler."
msgstr "*handler* 를 새 이벤트 루프 예외 처리기로 설정합니다."

#: ../Doc/library/asyncio-eventloop.rst:1078
msgid ""
"If *handler* is ``None``, the default exception handler will be set.  "
"Otherwise, *handler* must be a callable with the signature matching "
"``(loop, context)``, where ``loop`` is a reference to the active event "
"loop, and ``context`` is a ``dict`` object containing the details of the "
"exception (see :meth:`call_exception_handler` documentation for details "
"about context)."
msgstr ""
"*handler*\\가 ``None`` 이면, 기본 예외 처리기가 설정됩니다. 그렇지 않으면, *handler*\\는 반드시 "
"``(loop, context)`` 와 일치하는 서명을 가진 콜러블이어야 합니다. 여기서 ``loop``\\는 활성 이벤트 루프에 "
"대한 참조가 될 것이고, ``context`` 는 예외에 관한 세부 정보를 담고 있는 ``dict`` 객체가 됩니다 "
"(context에 대한 자세한 내용은 :meth:`call_exception_handler` 문서를 참조하십시오)."

#: ../Doc/library/asyncio-eventloop.rst:1088
msgid ""
"Return the current exception handler, or ``None`` if no custom exception "
"handler was set."
msgstr "현재 예외 처리기를 반환하거나, 사용자 정의 예외 처리기가 설정되지 않았으면 ``None`` 을 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:1095
msgid "Default exception handler."
msgstr "기본 예외 처리기."

#: ../Doc/library/asyncio-eventloop.rst:1097
msgid ""
"This is called when an exception occurs and no exception handler is set. "
"This can be called by a custom exception handler that wants to defer to "
"the default handler behavior."
msgstr ""
"예외가 발생하고 예외 처리기가 설정되지 않았을 때 호출됩니다. 기본 동작으로 위임하려는 사용자 정의 예외 처리기가 호출할 수 "
"있습니다."

#: ../Doc/library/asyncio-eventloop.rst:1101
msgid ""
"*context* parameter has the same meaning as in "
":meth:`call_exception_handler`."
msgstr "*context* 매개 변수는 :meth:`call_exception_handler` 에서와 같은 의미입니다."

#: ../Doc/library/asyncio-eventloop.rst:1106
msgid "Call the current event loop exception handler."
msgstr "현재 이벤트 루프 예외 처리기를 호출합니다."

#: ../Doc/library/asyncio-eventloop.rst:1108
msgid ""
"*context* is a ``dict`` object containing the following keys (new keys "
"may be introduced in future Python versions):"
msgstr "*context* 는 다음 키를 포함하는 ``dict`` 객체입니다 (새 키가 미래의 파이썬 버전에서 추가될 수 있습니다):"

#: ../Doc/library/asyncio-eventloop.rst:1111
msgid "'message': Error message;"
msgstr "'message': 에러 메시지;"

#: ../Doc/library/asyncio-eventloop.rst:1112
msgid "'exception' (optional): Exception object;"
msgstr "'exception' (선택적): 예외 객체;"

#: ../Doc/library/asyncio-eventloop.rst:1113
msgid "'future' (optional): :class:`asyncio.Future` instance;"
msgstr "'future' (선택적): :class:`asyncio.Future` 인스턴스;"

#: ../Doc/library/asyncio-eventloop.rst:1114
msgid "'handle' (optional): :class:`asyncio.Handle` instance;"
msgstr "'handle' (선택적): :class:`asyncio.Handle` 인스턴스;"

#: ../Doc/library/asyncio-eventloop.rst:1115
msgid "'protocol' (optional): :ref:`Protocol <asyncio-protocol>` instance;"
msgstr "'protocol' (선택적): :ref:`프로토콜 <asyncio-protocol>` 인스턴스;"

#: ../Doc/library/asyncio-eventloop.rst:1116
msgid "'transport' (optional): :ref:`Transport <asyncio-transport>` instance;"
msgstr "'transport' (선택적): :ref:`트랜스포트 <asyncio-transport>` 인스턴스;"

#: ../Doc/library/asyncio-eventloop.rst:1117
msgid "'socket' (optional): :class:`socket.socket` instance."
msgstr "'socket' (선택적): :class:`socket.socket` 인스턴스."

#: ../Doc/library/asyncio-eventloop.rst:1121
msgid ""
"This method should not be overloaded in subclassed event loops.  For "
"custom exception handling, use the :meth:`set_exception_handler()` "
"method."
msgstr ""
"이 메서드는 서브 클래스 된 이벤트 루프에서 재정의되지 않아야 합니다. 사용자 정의 예외 처리를 위해서는 "
":meth:`set_exception_handler()` 메서드를 사용하십시오."

#: ../Doc/library/asyncio-eventloop.rst:1126
msgid "Enabling debug mode"
msgstr "디버그 모드 활성화"

#: ../Doc/library/asyncio-eventloop.rst:1130
msgid "Get the debug mode (:class:`bool`) of the event loop."
msgstr "이벤트 루프의 디버그 모드(:class:`bool`)를 가져옵니다."

#: ../Doc/library/asyncio-eventloop.rst:1132
msgid ""
"The default value is ``True`` if the environment variable "
":envvar:`PYTHONASYNCIODEBUG` is set to a non-empty string, ``False`` "
"otherwise."
msgstr ""
"기본값은 환경 변수 :envvar:`PYTHONASYNCIODEBUG` 가 비어 있지 않은 문자열로 설정되면 ``True`` 이고,"
" 그렇지 않으면 ``False`` 입니다."

#: ../Doc/library/asyncio-eventloop.rst:1138
msgid "Set the debug mode of the event loop."
msgstr "이벤트 루프의 디버그 모드를 설정합니다."

#: ../Doc/library/asyncio-eventloop.rst:1142
msgid ""
"The new ``-X dev`` command line option can now also be used to enable the"
" debug mode."
msgstr "이제 새로운 ``-X dev`` 명령 줄 옵션을 사용하여 디버그 모드를 활성화할 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:1147
msgid "The :ref:`debug mode of asyncio <asyncio-debug-mode>`."
msgstr ":ref:`asyncio의 디버그 모드 <asyncio-debug-mode>`."

#: ../Doc/library/asyncio-eventloop.rst:1151
msgid "Running Subprocesses"
msgstr "자식 프로세스 실행하기"

#: ../Doc/library/asyncio-eventloop.rst:1153
msgid ""
"Methods described in this subsections are low-level.  In regular "
"async/await code consider using the high-level "
":func:`asyncio.create_subprocess_shell` and "
":func:`asyncio.create_subprocess_exec` convenience functions instead."
msgstr ""
"이 하위 절에서 설명하는 메서드는 저수준입니다. 일반적인 async/await 코드에서는 대신 고수준의 "
":func:`asyncio.create_subprocess_shell` 및 "
":func:`asyncio.create_subprocess_exec` 편리 함수를 사용하는 것을 고려하십시오."

#: ../Doc/library/asyncio-eventloop.rst:1160
msgid ""
"The default asyncio event loop on **Windows** does not support "
"subprocesses. See :ref:`Subprocess Support on Windows <asyncio-windows-"
"subprocess>` for details."
msgstr ""
"**Windows** 의 기본 asyncio 이벤트 루프는 자식 프로세스를 지원하지 않습니다. 자세한 내용은 :ref:`윈도우에서의"
" 자식 프로세스 지원 <asyncio-windows-subprocess>`\\을 참조하십시오."

#: ../Doc/library/asyncio-eventloop.rst:1168
msgid "Create a subprocess from one or more string arguments specified by *args*."
msgstr "*args*\\로 지정된 하나 이상의 문자열 인자로 서브 프로세스를 만듭니다."

#: ../Doc/library/asyncio-eventloop.rst:1171
msgid "*args* must be a list of strings represented by:"
msgstr "*args*\\는 반드시 다음과 같은 것으로 표현되는 문자열의 목록이어야 합니다:"

#: ../Doc/library/asyncio-eventloop.rst:1173
msgid ":class:`str`;"
msgstr ":class:`str`;"

#: ../Doc/library/asyncio-eventloop.rst:1174
msgid ""
"or :class:`bytes`, encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`."
msgstr "또는 :ref:`파일 시스템 인코딩 <filesystem-encoding>`\\으로로 인코딩된 :class:`bytes`."

#: ../Doc/library/asyncio-eventloop.rst:1177
msgid ""
"The first string specifies the program executable, and the remaining "
"strings specify the arguments.  Together, string arguments form the "
"``argv`` of the program."
msgstr ""
"첫 번째 문자열은 프로그램 실행 파일을 지정하고, 나머지 문자열은 인자를 지정합니다. 함께, 문자열 인자들은 프로그램의 "
"``argv``\\를 구성합니다."

#: ../Doc/library/asyncio-eventloop.rst:1181
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=False`` and the list of strings passed as the first "
"argument; however, where :class:`~subprocess.Popen` takes a single "
"argument which is list of strings, *subprocess_exec* takes multiple "
"string arguments."
msgstr ""
"이것은 ``shell=False``\\와 문자열의 목록을 첫 번째 인자로 호출된 표준 라이브러리 "
":class:`subprocess.Popen` 클래스와 유사합니다. 그러나 :class:`~subprocess.Popen`\\이 "
"문자열 목록인 단일 인자를 받아들이지만, *subprocess_exec*\\는 여러 문자열 인자를 받아들입니다."

#: ../Doc/library/asyncio-eventloop.rst:1187
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the "
":class:`asyncio.SubprocessProtocol` class."
msgstr ""
"*protocol_factory*\\는 반드시 :class:`asyncio.SubprocessProtocol` 클래스의 서브 "
"클래스를 반환하는 콜러블이어야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:1190
msgid "Other parameters:"
msgstr "다른 매개 변수:"

#: ../Doc/library/asyncio-eventloop.rst:1192
msgid ""
"*stdin*: either a file-like object representing a pipe to be connected to"
" the subprocess's standard input stream using "
":meth:`~loop.connect_write_pipe`, or the :const:`subprocess.PIPE`  "
"constant (default). By default a new pipe will be created and connected."
msgstr ""
"*stdin*: :meth:`~loop.connect_write_pipe`\\를 사용하여 자식 프로세스의 표준 입력 스트림에 연결될"
" 파이프를 나타내는 파일류 객체 또는 :const:`subprocess.PIPE` 상수 (기본값). 기본적으로 새 파이프가 "
"만들어지고 연결됩니다."

#: ../Doc/library/asyncio-eventloop.rst:1198
msgid ""
"*stdout*: either a file-like object representing the pipe to be connected"
" to the subprocess's standard output stream using "
":meth:`~loop.connect_read_pipe`, or the :const:`subprocess.PIPE` constant"
" (default). By default a new pipe will be created and connected."
msgstr ""
"*stdout*: :meth:`~loop.connect_read_pipe`\\를 사용하여 자식 프로세스의 표준 출력 스트림에 연결될"
" 파이프를 나타내는 파일류 객체 또는 :const:`subprocess.PIPE` 상수 (기본값). 기본적으로 새 파이프가 "
"만들어지고 연결됩니다."

#: ../Doc/library/asyncio-eventloop.rst:1204
msgid ""
"*stderr*: either a file-like object representing the pipe to be connected"
" to the subprocess's standard error stream using "
":meth:`~loop.connect_read_pipe`, or one of :const:`subprocess.PIPE` "
"(default) or :const:`subprocess.STDOUT` constants."
msgstr ""
"*stderr*: :meth:`~loop.connect_read_pipe`\\를 사용하여 자식 프로세스의 표준 에러 스트림에 연결될"
" 파이프를 나타내는 파일류 객체 또는 :const:`subprocess.PIPE` (기본값) 또는 "
":const:`subprocess.STDOUT` 상수 중 하나."

#: ../Doc/library/asyncio-eventloop.rst:1210
msgid ""
"By default a new pipe will be created and connected. When "
":const:`subprocess.STDOUT` is specified, the subprocess' standard error "
"stream will be connected to the same pipe as the standard output stream."
msgstr ""
"기본적으로 새 파이프가 만들어지고 연결됩니다. :const:`subprocess.STDOUT`\\가 지정되면, 자식 프로세스의 표준"
" 에러 스트림은 표준 출력 스트림과 같은 파이프에 연결됩니다."

#: ../Doc/library/asyncio-eventloop.rst:1215
msgid ""
"All other keyword arguments are passed to :class:`subprocess.Popen` "
"without interpretation, except for *bufsize*, *universal_newlines* and "
"*shell*, which should not be specified at all."
msgstr ""
"다른 모든 키워드 인자는 해석 없이 :class:`subprocess.Popen`\\로 전달됩니다. 다만, *bufsize*, "
"*universal_newlines* 및 *shell*\\은 예외인데, 이것들은 지정되지 않아야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:1219
msgid ""
"See the constructor of the :class:`subprocess.Popen` class for "
"documentation on other arguments."
msgstr "다른 인자에 관한 설명은 :class:`subprocess.Popen` 클래스의 생성자를 참조하십시오."

#: ../Doc/library/asyncio-eventloop.rst:1222
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms "
"to the :class:`asyncio.SubprocessTransport` base class and *protocol* is "
"an object instantiated by the *protocol_factory*."
msgstr ""
"``(transport, protocol)`` 쌍을 반환합니다. 여기에서 *transport*\\는 "
":class:`asyncio.SubprocessTransport` 베이스 클래스를 따르고, *protocol*\\은 "
"*protocol_factory*\\에 의해 인스턴스로 만들어진 객체입니다."

#: ../Doc/library/asyncio-eventloop.rst:1230
msgid ""
"Create a subprocess from *cmd*, which can be a :class:`str` or a "
":class:`bytes` string encoded to the :ref:`filesystem encoding "
"<filesystem-encoding>`, using the platform's \"shell\" syntax."
msgstr ""
"플랫폼의 \"셸\" 구문을 사용하는 *cmd*\\로 자식 프로세스를 만듭니다. *cmd*\\는 :class:`str`\\이나 "
":ref:`파일 시스템 인코딩 <filesystem-encoding>`\\으로 인코딩된 :class:`bytes` 일 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:1235
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=True``."
msgstr ""
"이것은 ``shell=True``\\로 호출된 표준 라이브러리 :class:`subprocess.Popen` 클래스와 유사합니다."

#: ../Doc/library/asyncio-eventloop.rst:1238
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the "
":class:`SubprocessProtocol` class."
msgstr ""
"*protocol_factory*\\는 반드시 :class:`SubprocessProtocol` 클래스의 서브 클래스를 반환하는 "
"콜러블이어야 합니다."

#: ../Doc/library/asyncio-eventloop.rst:1241
msgid ""
"See :meth:`~loop.subprocess_exec` for more details about the remaining "
"arguments."
msgstr "나머지 인자에 관한 자세한 내용은 :meth:`~loop.subprocess_exec`\\를 참조하십시오."

#: ../Doc/library/asyncio-eventloop.rst:1244
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms "
"to the :class:`SubprocessTransport` base class and *protocol* is an "
"object instantiated by the *protocol_factory*."
msgstr ""
"``(transport, protocol)`` 쌍을 반환합니다. 여기서 *transport*\\는 "
":class:`SubprocessTransport` 베이스 클래스를 따르고, *protocol*\\은 "
"*protocol_factory*\\에 의해 인스턴스로 만들어진 객체입니다."

#: ../Doc/library/asyncio-eventloop.rst:1249
msgid ""
"It is the application's responsibility to ensure that all whitespace and "
"special characters are quoted appropriately to avoid `shell injection "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ "
"vulnerabilities. The :func:`shlex.quote` function can be used to properly"
" escape whitespace and special characters in strings that are going to be"
" used to construct shell commands."
msgstr ""
"`셸 주입 <https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ "
"취약점을 피하고자 모든 공백과 특수 문자를 적절하게 따옴표 처리하는 것은 응용 프로그램의 책임입니다. "
":func:`shlex.quote` 함수를 사용하여 셸 명령을 구성하는 데 사용될 문자열에 있는 공백 및 특수 문자를 올바르게 "
"이스케이프 할 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:1258
msgid "Callback Handles"
msgstr "콜백 핸들"

#: ../Doc/library/asyncio-eventloop.rst:1262
msgid ""
"A callback wrapper object returned by :meth:`loop.call_soon`, "
":meth:`loop.call_soon_threadsafe`."
msgstr ""
":meth:`loop.call_soon`, :meth:`loop.call_soon_threadsafe` 에 의해 반환되는 콜백 래퍼"
" 객체."

#: ../Doc/library/asyncio-eventloop.rst:1267
msgid ""
"Cancel the callback.  If the callback has already been canceled or "
"executed, this method has no effect."
msgstr "콜백을 취소합니다. 콜백이 이미 취소되었거나 실행되었다면 이 메서드는 아무 효과가 없습니다."

#: ../Doc/library/asyncio-eventloop.rst:1272
msgid "Return ``True`` if the callback was cancelled."
msgstr "콜백이 취소되었으면 ``True`` 을 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:1278
msgid ""
"A callback wrapper object returned by :meth:`loop.call_later`, and "
":meth:`loop.call_at`."
msgstr ":meth:`loop.call_later` 및 :meth:`loop.call_at` 에 의해 반환되는 콜백 래퍼 객체."

#: ../Doc/library/asyncio-eventloop.rst:1281
msgid "This class is a subclass of :class:`Handle`."
msgstr "이 클래스는 :class:`Handle`\\의 서브 클래스입니다."

#: ../Doc/library/asyncio-eventloop.rst:1285
msgid "Return a scheduled callback time as :class:`float` seconds."
msgstr "예약된 콜백 시간을 :class:`float` 초로 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:1287
msgid ""
"The time is an absolute timestamp, using the same time reference as "
":meth:`loop.time`."
msgstr "시간은 절대 타임스탬프입니다. :meth:`loop.time` 과 같은 시간 참조를 사용합니다."

#: ../Doc/library/asyncio-eventloop.rst:1294
msgid "Server Objects"
msgstr "서버 객체"

#: ../Doc/library/asyncio-eventloop.rst:1296
msgid ""
"Server objects are created by :meth:`loop.create_server`, "
":meth:`loop.create_unix_server`, :func:`start_server`, and "
":func:`start_unix_server` functions."
msgstr ""
"Server 객체는 :meth:`loop.create_server`, :meth:`loop.create_unix_server`, "
":func:`start_server`, :func:`start_unix_server`\\로 만듭니다."

#: ../Doc/library/asyncio-eventloop.rst:1300
msgid "Do not instantiate the class directly."
msgstr "클래스의 인스턴스를 직접 만들지 마십시오."

#: ../Doc/library/asyncio-eventloop.rst:1304
msgid ""
"*Server* objects are asynchronous context managers.  When used in an "
"``async with`` statement, it's guaranteed that the Server object is "
"closed and not accepting new connections when the ``async with`` "
"statement is completed::"
msgstr ""
"*Server* 객체는 비동기 컨텍스트 관리자입니다. ``async with`` 문에서 사용될 때, ``async with`` 문이"
" 완료되면 서버 객체가 닫혀 있고 새 연결을 받아들이지 않는다는 것이 보장됩니다::"

#: ../Doc/library/asyncio-eventloop.rst:1317
msgid "Server object is an asynchronous context manager since Python 3.7."
msgstr "Server 객체는 파이썬 3.7부터 비동기 컨텍스트 관리자입니다."

#: ../Doc/library/asyncio-eventloop.rst:1322
msgid ""
"Stop serving: close listening sockets and set the :attr:`sockets` "
"attribute to ``None``."
msgstr "서버를 중지합니다: 리스닝 소켓을 닫고 :attr:`sockets` 어트리뷰트를 ``None`` 으로 설정합니다."

#: ../Doc/library/asyncio-eventloop.rst:1325
msgid ""
"The sockets that represent existing incoming client connections are left "
"open."
msgstr "이미 받아들여진 클라이언트 연결을 나타내는 소켓은 열린 채로 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:1328
msgid ""
"The server is closed asynchronously, use the :meth:`wait_closed` "
"coroutine to wait until the server is closed."
msgstr "서버는 비동기적으로 닫힙니다. 서버가 닫힐 때까지 대기하려면 :meth:`wait_closed` 코루틴을 사용하십시오."

#: ../Doc/library/asyncio-eventloop.rst:1333
msgid "Return the event loop associated with the server object."
msgstr "서버 객체와 연관된 이벤트 루프를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:1339
msgid "Start accepting connections."
msgstr "연결을 받아들이기 시작합니다."

#: ../Doc/library/asyncio-eventloop.rst:1341
msgid ""
"This method is idempotent, so it can be called when the server is already"
" being serving."
msgstr "이 메서드는 멱등적이라서, 서버가 이미 시작되었을 때도 호출 할 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:1344
msgid ""
"The *start_serving* keyword-only parameter to :meth:`loop.create_server` "
"and :meth:`asyncio.start_server` allows creating a Server object that is "
"not accepting connections initially.  In this case "
"``Server.start_serving()``, or :meth:`Server.serve_forever` can be used "
"to make the Server start accepting connections."
msgstr ""
":meth:`loop.create_server`\\와 :meth:`asyncio.start_server` 의 "
"*start_serving* 키워드 전용 매개 변수는 즉시 연결을 받아들이지 않는 서버 객체를 만들 수 있도록 합니다. 이 경우 "
"``Server.start_serving()``, 또는 :meth:`Server.serve_forever`\\를 사용하여 "
"Server가 연결을 받아들이기 시작하도록 할 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:1355
msgid ""
"Start accepting connections until the coroutine is cancelled. "
"Cancellation of ``serve_forever`` task causes the server to be closed."
msgstr "코루틴이 취소될 때까지 연결을 받아들이기 시작합니다. ``serve_forever`` 태스크를 취소하면 서버가 닫힙니다."

#: ../Doc/library/asyncio-eventloop.rst:1359
msgid ""
"This method can be called if the server is already accepting connections."
"  Only one ``serve_forever`` task can exist per one *Server* object."
msgstr ""
"이 메서드는 서버가 이미 연결을 받아들이고 있어도 호출 할 수 있습니다. 하나의 *Server* 객체 당 하나의 "
"``serve_forever`` 태스크만 존재할 수 있습니다."

#: ../Doc/library/asyncio-eventloop.rst:1381
msgid "Return ``True`` if the server is accepting new connections."
msgstr "서버가 새 연결을 받아들이고 있으면 ``True`` 를 반환합니다."

#: ../Doc/library/asyncio-eventloop.rst:1387
msgid "Wait until the :meth:`close` method completes."
msgstr ":meth:`close` 메서드가 완료될 때까지 기다립니다."

#: ../Doc/library/asyncio-eventloop.rst:1391
msgid ""
"List of :class:`socket.socket` objects the server is listening on, or "
"``None`` if the server is closed."
msgstr "서버가 리스닝하고 있는 :class:`socket.socket` 객체의 리스트, 또는 서버가 닫혀 있다면 ``None``."

#: ../Doc/library/asyncio-eventloop.rst:1394
msgid ""
"Prior to Python 3.7 ``Server.sockets`` used to return an internal list of"
" server sockets directly.  In 3.7 a copy of that list is returned."
msgstr ""
"파이썬 3.7 이전에는 ``Server.sockets`` 가 서버 소켓의 내부 리스트를 직접 반환했습니다. 3.7에서는 그 리스트의"
" 복사본이 반환됩니다."

#: ../Doc/library/asyncio-eventloop.rst:1403
msgid "Event Loop Implementations"
msgstr "이벤트 루프 구현"

#: ../Doc/library/asyncio-eventloop.rst:1405
msgid ""
"asyncio ships with two different event loop implementations: "
":class:`SelectorEventLoop` and :class:`ProactorEventLoop`."
msgstr ""
"asyncio에는 두 가지 이벤트 루프 구현이 함께 제공됩니다: :class:`SelectorEventLoop` 및 "
":class:`ProactorEventLoop`."

#: ../Doc/library/asyncio-eventloop.rst:1408
msgid ""
"By default asyncio is configured to use :class:`SelectorEventLoop` on all"
" platforms."
msgstr "기본적으로 asyncio는 모든 플랫폼에서 :class:`SelectorEventLoop`\\를 사용하도록 구성됩니다."

#: ../Doc/library/asyncio-eventloop.rst:1414
msgid "An event loop based on the :mod:`selectors` module."
msgstr ":mod:`selectors` 모듈을 기반으로 하는 이벤트 루프."

#: ../Doc/library/asyncio-eventloop.rst:1416
msgid ""
"Uses the most efficient *selector* available for the given platform.  It "
"is also possible to manually configure the exact selector implementation "
"to be used::"
msgstr ""
"주어진 플랫폼에서 사용할 수 있는 가장 효율적인 *selector*\\를 사용합니다. 정확한 셀렉터 구현을 수동으로 구성하여 사용할"
" 수도 있습니다.::"

#: ../Doc/library/asyncio-eventloop.rst:1428
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`가용성 <availability>`: 유닉스, 윈도우."

#: ../Doc/library/asyncio-eventloop.rst:1433
msgid "An event loop for Windows that uses \"I/O Completion Ports\" (IOCP)."
msgstr "\"I/O 완료 포트\"(IOCP)를 사용하는 윈도우용 이벤트 루프."

#: ../Doc/library/asyncio-eventloop.rst:1436
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`가용성 <availability>`: 윈도우."

#: ../Doc/library/asyncio-eventloop.rst:1437
msgid "An example how to use :class:`ProactorEventLoop` on Windows::"
msgstr "윈도우에서 :class:`ProactorEventLoop`\\를 사용하는 예::"

#: ../Doc/library/asyncio-eventloop.rst:1448
msgid ""
"`MSDN documentation on I/O Completion Ports <https://docs.microsoft.com"
"/en-ca/windows/desktop/FileIO/i-o-completion-ports>`_."
msgstr ""
"`I/O 완료 포트에 관한 MSDN 설명서 <https://docs.microsoft.com/en-"
"ca/windows/desktop/FileIO/i-o-completion-ports>`_."

#: ../Doc/library/asyncio-eventloop.rst:1454
msgid "Abstract base class for asyncio-compliant event loops."
msgstr "asyncio 호환 이벤트 루프의 추상 베이스 클래스."

#: ../Doc/library/asyncio-eventloop.rst:1456
msgid ""
"The :ref:`Event Loop Methods <asyncio-event-loop>` section lists all "
"methods that an alternative implementation of ``AbstractEventLoop`` "
"should have defined."
msgstr ""
":ref:`이벤트 루프 메서드 <asyncio-event-loop>` 절은 ``AbstractEventLoop``\\의 다른 구현이"
" 정의해야 하는 모든 메서드를 나열합니다."

#: ../Doc/library/asyncio-eventloop.rst:1462
msgid "Examples"
msgstr "예제"

#: ../Doc/library/asyncio-eventloop.rst:1464
msgid ""
"Note that all examples in this section **purposefully** show how to use "
"the low-level event loop APIs, such as :meth:`loop.run_forever` and "
":meth:`loop.call_soon`.  Modern asyncio applications rarely need to be "
"written this way; consider using the high-level functions like "
":func:`asyncio.run`."
msgstr ""
"이 절의 모든 예는 **의도적으로** :meth:`loop.run_forever` 및 :meth:`loop.call_soon`\\와"
" 같은 저수준 이벤트 루프 API를 사용하는 방법을 보여줍니다. 현대 asyncio 응용 프로그램은 거의 이런 식으로 작성할 필요가"
" 없습니다; :func:`asyncio.run`\\과 같은 고수준 함수를 사용하는 것을 고려하십시오."

#: ../Doc/library/asyncio-eventloop.rst:1474
msgid "Hello World with call_soon()"
msgstr "call_soon()을 사용하는 Hello World"

#: ../Doc/library/asyncio-eventloop.rst:1476
msgid ""
"An example using the :meth:`loop.call_soon` method to schedule a "
"callback. The callback displays ``\"Hello World\"`` and then stops the "
"event loop::"
msgstr ""
"콜백을 예약하기 위해 :meth:`loop.call_soon` 메서드를 사용하는 예제. 콜백은 ``\"Hello World\"`` "
"를 표시한 다음 이벤트 루프를 중지합니다::"

#: ../Doc/library/asyncio-eventloop.rst:1500
msgid ""
"A similar :ref:`Hello World <coroutine>` example created with a coroutine"
" and the :func:`run` function."
msgstr "코루틴과 :func:`run` 함수로 작성된 유사한 :ref:`Hello World <coroutine>` 예제."

#: ../Doc/library/asyncio-eventloop.rst:1507
msgid "Display the current date with call_later()"
msgstr "call_later()로 현재 날짜를 표시합니다."

#: ../Doc/library/asyncio-eventloop.rst:1509
msgid ""
"An example of a callback displaying the current date every second. The "
"callback uses the :meth:`loop.call_later` method to reschedule itself "
"after 5 seconds, and then stops the event loop::"
msgstr ""
"초마다 현재 날짜를 표시하는 콜백의 예입니다. 콜백은 :meth:`loop.call_later` 메서드를 사용하여 5초 동안 자신을"
" 다시 예약한 다음 이벤트 루프를 중지합니다::"

#: ../Doc/library/asyncio-eventloop.rst:1537
msgid ""
"A similar :ref:`current date <asyncio_example_sleep>` example created "
"with a coroutine and the :func:`run` function."
msgstr "코루틴과 :func:`run` 함수로 작성된 유사한 :ref:`현재 날짜 <asyncio_example_sleep>` 예제."

#: ../Doc/library/asyncio-eventloop.rst:1544
msgid "Watch a file descriptor for read events"
msgstr "파일 기술자에서 읽기 이벤트를 관찰하기"

#: ../Doc/library/asyncio-eventloop.rst:1546
msgid ""
"Wait until a file descriptor received some data using the "
":meth:`loop.add_reader` method and then close the event loop::"
msgstr ""
":meth:`loop.add_reader` 메서드를 사용하여 파일 기술자가 데이터를 수신할 때까지 기다렸다가 이벤트 루프를 "
"닫습니다::"

#: ../Doc/library/asyncio-eventloop.rst:1584
msgid ""
"A similar :ref:`example <asyncio_example_create_connection>` using "
"transports, protocols, and the :meth:`loop.create_connection` method."
msgstr ""
"트랜스포트, 프로토콜, :meth:`loop.create_connection` 메서드를 사용한 유사한 :ref:`예제 "
"<asyncio_example_create_connection>`."

#: ../Doc/library/asyncio-eventloop.rst:1588
msgid ""
"Another similar :ref:`example <asyncio_example_create_connection-"
"streams>` using the high-level :func:`asyncio.open_connection` function "
"and streams."
msgstr ""
"고수준의 :func:`asyncio.open_connection` 함수와 스트림을 사용하는 또 다른 유사한 :ref:`예제 "
"<asyncio_example_create_connection-streams>`."

#: ../Doc/library/asyncio-eventloop.rst:1596
msgid "Set signal handlers for SIGINT and SIGTERM"
msgstr "SIGINT 및 SIGTERM에 대한 시그널 처리기 설정"

#: ../Doc/library/asyncio-eventloop.rst:1598
msgid "(This ``signals`` example only works on Unix.)"
msgstr "(이 ``signals`` 예제는 유닉스에서만 작동합니다.)"

#: ../Doc/library/asyncio-eventloop.rst:1600
msgid ""
"Register handlers for signals :py:data:`SIGINT` and :py:data:`SIGTERM` "
"using the :meth:`loop.add_signal_handler` method::"
msgstr ""
":meth:`loop.add_signal_handler` 메서드를 사용하여 :py:data:`SIGINT`\\와 "
":py:data:`SIGTERM` 시그널을 위한 처리기를 등록합니다::"
