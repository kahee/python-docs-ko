# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-25 10:27+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../Doc/library/os.rst:2
msgid ":mod:`os` --- Miscellaneous operating system interfaces"
msgstr ":mod:`os` --- 기타 운영 체제 인터페이스"

#: ../Doc/library/os.rst:7
msgid "**Source code:** :source:`Lib/os.py`"
msgstr "**소스 코드:** :source:`Lib/os.py`"

#: ../Doc/library/os.rst:11
msgid ""
"This module provides a portable way of using operating system dependent "
"functionality.  If you just want to read or write a file see "
":func:`open`, if you want to manipulate paths, see the :mod:`os.path` "
"module, and if you want to read all the lines in all the files on the "
"command line see the :mod:`fileinput` module.  For creating temporary "
"files and directories see the :mod:`tempfile` module, and for high-level "
"file and directory handling see the :mod:`shutil` module."
msgstr ""
"이 모듈은 운영 체제 종속 기능을 사용하는 이식성 있는 방법을 제공합니다. 파일을 읽거나 쓰고 싶으면 :func:`open`\\을 "
"보세요, 경로를 조작하려면 :mod:`os.path` 모듈을 보시고, 명령 줄에서 주어진 모든 파일의 모든 줄을 읽으려면 "
":mod:`fileinput` 모듈을 보십시오. 임시 파일과 디렉터리를 만들려면 :mod:`tempfile` 모듈을 보시고, "
"고수준의 파일과 디렉터리 처리는 :mod:`shutil` 모듈을 보십시오."

#: ../Doc/library/os.rst:19
msgid "Notes on the availability of these functions:"
msgstr "이러한 기능의 가용성에 대한 참고 사항:"

#: ../Doc/library/os.rst:21
msgid ""
"The design of all built-in operating system dependent modules of Python "
"is such that as long as the same functionality is available, it uses the "
"same interface; for example, the function ``os.stat(path)`` returns stat "
"information about *path* in the same format (which happens to have "
"originated with the POSIX interface)."
msgstr ""
"내장된 모든 운영 체제 종속적인 파이썬 모듈의 설계는, 같은 기능을 사용할 수 있는 한, 같은 인터페이스를 사용합니다; 예를 들어,"
" 함수 ``os.stat(path)``\\는 *path* 에 대한 stat 정보를 같은 (POSIX 인터페이스에서 기원한) 형식으로"
" 반환합니다."

#: ../Doc/library/os.rst:27
msgid ""
"Extensions peculiar to a particular operating system are also available "
"through the :mod:`os` module, but using them is of course a threat to "
"portability."
msgstr ""
"특정 운영 체제에 고유한 확장도 :mod:`os` 모듈을 통해서 사용할 수 있지만, 이러한 기능을 사용하는 것은 물론 이식성에 대한"
" 위협입니다."

#: ../Doc/library/os.rst:31
msgid ""
"All functions accepting path or file names accept both bytes and string "
"objects, and result in an object of the same type, if a path or file name"
" is returned."
msgstr ""
"경로 또는 파일명을 받아들이는 모든 함수는 바이트열과 문자열 객체를 모두 허용하며, 경로나 파일명이 반환되면 같은 형의 객체를 "
"반환합니다."

#: ../Doc/library/os.rst:38
msgid ""
"All functions in this module raise :exc:`OSError` in the case of invalid "
"or inaccessible file names and paths, or other arguments that have the "
"correct type, but are not accepted by the operating system."
msgstr ""
"이 모듈의 모든 함수는, 올바르지 않거나 액세스할 수 없는 파일명과 경로일 때, 또는 올바른 형의 인자이지만, 운영 체제에서 "
"허용하지 않으면 :exc:`OSError`\\를 발생시킵니다."

#: ../Doc/library/os.rst:44
msgid "An alias for the built-in :exc:`OSError` exception."
msgstr "내장 :exc:`OSError` 예외의 별칭."

#: ../Doc/library/os.rst:49
msgid ""
"The name of the operating system dependent module imported.  The "
"following names have currently been registered: ``'posix'``, ``'nt'``, "
"``'java'``."
msgstr ""
"임포트 된 운영 체제 종속 모듈의 이름. 다음과 같은 이름이 현재 등록되어있습니다: ``'posix'``, ``'nt'``, "
"``'java'``."

#: ../Doc/library/os.rst:54
msgid ""
":attr:`sys.platform` has a finer granularity.  :func:`os.uname` gives "
"system-dependent version information."
msgstr ""
":attr:`sys.platform`\\는 더 세분되어 있습니다. :func:`os.uname`\\은 시스템 종속 버전 정보를 "
"제공합니다."

#: ../Doc/library/os.rst:57
msgid ""
"The :mod:`platform` module provides detailed checks for the system's "
"identity."
msgstr ":mod:`platform` 모듈은 시스템의 아이덴티티에 대한 자세한 검사를 제공합니다."

#: ../Doc/library/os.rst:65
msgid "File Names, Command Line Arguments, and Environment Variables"
msgstr "파일명, 명령 줄 인자 및 환경 변수"

#: ../Doc/library/os.rst:67
msgid ""
"In Python, file names, command line arguments, and environment variables "
"are represented using the string type. On some systems, decoding these "
"strings to and from bytes is necessary before passing them to the "
"operating system. Python uses the file system encoding to perform this "
"conversion (see :func:`sys.getfilesystemencoding`)."
msgstr ""
"파이썬에서는, 파일명, 명령 줄 인자 및 환경 변수가 문자열형을 사용하여 표시됩니다. 일부 시스템에서는, 운영 체제에 전달하기 전에"
" 이러한 문자열을 바이트열로 인코딩하는 것이 필요합니다. 파이썬은 파일 시스템 인코딩을 사용하여 이 변환을 수행합니다 "
"(:func:`sys.getfilesystemencoding`\\을 참조하세요)."

#: ../Doc/library/os.rst:73
msgid ""
"On some systems, conversion using the file system encoding may fail. In "
"this case, Python uses the :ref:`surrogateescape encoding error handler "
"<surrogateescape>`, which means that undecodable bytes are replaced by a "
"Unicode character U+DCxx on decoding, and these are again translated to "
"the original byte on encoding."
msgstr ""
"일부 시스템에서는, 파일 시스템 인코딩을 사용한 변환이 실패할 수 있습니다. 이때, 파이썬은 :ref:`surrogateescape"
" 인코딩 에러 처리기 <surrogateescape>`\\를 사용하는데, 디코딩할 때 디코딩 할 수 없는 바이트가 유니코드 문자 "
"U+DCxx로 치환되고, 다시 인코딩할 때 원래 바이트로 변환됩니다."

#: ../Doc/library/os.rst:81
msgid ""
"The file system encoding must guarantee to successfully decode all bytes "
"below 128. If the file system encoding fails to provide this guarantee, "
"API functions may raise UnicodeErrors."
msgstr ""
"파일 시스템 인코딩은 128보다 작은 모든 바이트를 성공적으로 디코딩함을 보장해야 합니다. 파일 시스템 인코딩이 이 보장을 제공하지"
" 못하면, API 함수가 UnicodeError를 발생시킬 수 있습니다."

#: ../Doc/library/os.rst:89
msgid "Process Parameters"
msgstr "프로세스 매개 변수"

#: ../Doc/library/os.rst:91
msgid ""
"These functions and data items provide information and operate on the "
"current process and user."
msgstr "이 함수들과 데이터 항목은 현재 프로세스와 사용자에 관한 정보와 관련 연산을 제공합니다."

#: ../Doc/library/os.rst:97
msgid ""
"Return the filename corresponding to the controlling terminal of the "
"process."
msgstr "프로세스의 제어 터미널에 해당하는 파일명을 반환합니다."

#: ../Doc/library/os.rst:99 ../Doc/library/os.rst:261
#: ../Doc/library/os.rst:270 ../Doc/library/os.rst:279
#: ../Doc/library/os.rst:289 ../Doc/library/os.rst:298
#: ../Doc/library/os.rst:333 ../Doc/library/os.rst:341
#: ../Doc/library/os.rst:378 ../Doc/library/os.rst:389
#: ../Doc/library/os.rst:399 ../Doc/library/os.rst:409
#: ../Doc/library/os.rst:419 ../Doc/library/os.rst:429
#: ../Doc/library/os.rst:458 ../Doc/library/os.rst:465
#: ../Doc/library/os.rst:472 ../Doc/library/os.rst:482
#: ../Doc/library/os.rst:493 ../Doc/library/os.rst:502
#: ../Doc/library/os.rst:520 ../Doc/library/os.rst:528
#: ../Doc/library/os.rst:536 ../Doc/library/os.rst:545
#: ../Doc/library/os.rst:553 ../Doc/library/os.rst:560
#: ../Doc/library/os.rst:567 ../Doc/library/os.rst:576
#: ../Doc/library/os.rst:748 ../Doc/library/os.rst:758
#: ../Doc/library/os.rst:767 ../Doc/library/os.rst:789
#: ../Doc/library/os.rst:810 ../Doc/library/os.rst:844
#: ../Doc/library/os.rst:862 ../Doc/library/os.rst:874
#: ../Doc/library/os.rst:1042 ../Doc/library/os.rst:1057
#: ../Doc/library/os.rst:1072 ../Doc/library/os.rst:1085
#: ../Doc/library/os.rst:1153 ../Doc/library/os.rst:1252
#: ../Doc/library/os.rst:1269 ../Doc/library/os.rst:1281
#: ../Doc/library/os.rst:1299 ../Doc/library/os.rst:1308
#: ../Doc/library/os.rst:1316 ../Doc/library/os.rst:1325
#: ../Doc/library/os.rst:1361 ../Doc/library/os.rst:1598
#: ../Doc/library/os.rst:1663 ../Doc/library/os.rst:1677
#: ../Doc/library/os.rst:1688 ../Doc/library/os.rst:1708
#: ../Doc/library/os.rst:1721 ../Doc/library/os.rst:1732
#: ../Doc/library/os.rst:1904 ../Doc/library/os.rst:1926
#: ../Doc/library/os.rst:1970 ../Doc/library/os.rst:1981
#: ../Doc/library/os.rst:2589 ../Doc/library/os.rst:2736
#: ../Doc/library/os.rst:2957 ../Doc/library/os.rst:3167
#: ../Doc/library/os.rst:3175 ../Doc/library/os.rst:3182
#: ../Doc/library/os.rst:3189 ../Doc/library/os.rst:3196
#: ../Doc/library/os.rst:3203 ../Doc/library/os.rst:3210
#: ../Doc/library/os.rst:3217 ../Doc/library/os.rst:3225
#: ../Doc/library/os.rst:3233 ../Doc/library/os.rst:3240
#: ../Doc/library/os.rst:3247 ../Doc/library/os.rst:3256
#: ../Doc/library/os.rst:3264 ../Doc/library/os.rst:3272
#: ../Doc/library/os.rst:3279 ../Doc/library/os.rst:3286
#: ../Doc/library/os.rst:3301 ../Doc/library/os.rst:3346
#: ../Doc/library/os.rst:3353 ../Doc/library/os.rst:3361
#: ../Doc/library/os.rst:3417 ../Doc/library/os.rst:3614
#: ../Doc/library/os.rst:3630 ../Doc/library/os.rst:3641
#: ../Doc/library/os.rst:3652 ../Doc/library/os.rst:3665
#: ../Doc/library/os.rst:3711 ../Doc/library/os.rst:3722
#: ../Doc/library/os.rst:3730 ../Doc/library/os.rst:3746
#: ../Doc/library/os.rst:3758 ../Doc/library/os.rst:3766
#: ../Doc/library/os.rst:3774 ../Doc/library/os.rst:3782
#: ../Doc/library/os.rst:3790 ../Doc/library/os.rst:3798
#: ../Doc/library/os.rst:3805 ../Doc/library/os.rst:3812
#: ../Doc/library/os.rst:3958 ../Doc/library/os.rst:3967
#: ../Doc/library/os.rst:3988 ../Doc/library/os.rst:3998
#: ../Doc/library/os.rst:4007
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`가용성 <availability>`: 유닉스."

#: ../Doc/library/os.rst:104
msgid ""
"A :term:`mapping` object representing the string environment. For "
"example, ``environ['HOME']`` is the pathname of your home directory (on "
"some platforms), and is equivalent to ``getenv(\"HOME\")`` in C."
msgstr ""
"문자열 환경을 나타내는 :term:`매핑 <mapping>` 객체입니다. 예를 들어, ``environ['HOME']``\\은 홈 "
"디렉터리의 경로명이며 (일부 플랫폼에서), C의 ``getenv(\"HOME\")``\\과 같습니다."

#: ../Doc/library/os.rst:108
msgid ""
"This mapping is captured the first time the :mod:`os` module is imported,"
" typically during Python startup as part of processing :file:`site.py`.  "
"Changes to the environment made after this time are not reflected in "
"``os.environ``, except for changes made by modifying ``os.environ`` "
"directly."
msgstr ""
"이 매핑은 :mod:`os` 모듈을 처음으로 임포트 할 때, 일반적으로 파이썬을 시작할 때 :file:`site.py`\\를 "
"처리하는 과정에서, 캡처됩니다. 이 시각 이후 변경된 환경은 ``os.environ``\\을 직접 수정하여 변경한 경우를 제외하고는"
" ``os.environ``\\에 반영되지 않습니다."

#: ../Doc/library/os.rst:113
msgid ""
"If the platform supports the :func:`putenv` function, this mapping may be"
" used to modify the environment as well as query the environment.  "
":func:`putenv` will be called automatically when the mapping is modified."
msgstr ""
"플랫폼이 :func:`putenv` 함수를 지원하면, 이 매핑은 환경을 조회하는 것뿐 아니라 환경을 수정하는 데도 사용될 수 "
"있습니다. 매핑이 수정될 때 :func:`putenv`\\가 자동으로 호출됩니다."

#: ../Doc/library/os.rst:117
msgid ""
"On Unix, keys and values use :func:`sys.getfilesystemencoding` and "
"``'surrogateescape'`` error handler. Use :data:`environb` if you would "
"like to use a different encoding."
msgstr ""
"유닉스에서, 키와 값은 :func:`sys.getfilesystemencoding` 과 ``'surrogateescape'`` 에러"
" 처리기를 사용합니다. 다른 인코딩을 사용하려면 :data:`environb`\\를 사용하십시오."

#: ../Doc/library/os.rst:123
msgid ""
"Calling :func:`putenv` directly does not change ``os.environ``, so it's "
"better to modify ``os.environ``."
msgstr ""
":func:`putenv`\\를 직접 호출해도 ``os.environ``\\은 변경되지 않으므로, ``os.environ``\\을 "
"수정하는 것이 좋습니다."

#: ../Doc/library/os.rst:128
msgid ""
"On some platforms, including FreeBSD and Mac OS X, setting ``environ`` "
"may cause memory leaks.  Refer to the system documentation for "
":c:func:`putenv`."
msgstr ""
"FreeBSD 및 맥 OS X를 포함한 일부 플랫폼에서, ``environ``\\을 설정하면 메모리 누수가 발생할 수 있습니다. "
":c:func:`putenv`\\에 대한 시스템 설명서를 참조하십시오."

#: ../Doc/library/os.rst:132
msgid ""
"If :func:`putenv` is not provided, a modified copy of this mapping  may "
"be passed to the appropriate process-creation functions to cause  child "
"processes to use a modified environment."
msgstr ""
":func:`putenv`\\가 제공되지 않으면, 이 매핑의 수정된 복사본을 적절한 프로세스 생성 함수에 전달하여 자식 프로세스가 "
"수정된 환경을 사용하게 할 수 있습니다."

#: ../Doc/library/os.rst:136
msgid ""
"If the platform supports the :func:`unsetenv` function, you can delete "
"items in this mapping to unset environment variables. :func:`unsetenv` "
"will be called automatically when an item is deleted from ``os.environ``,"
" and when one of the :meth:`pop` or :meth:`clear` methods is called."
msgstr ""
"플랫폼이 :func:`unsetenv` 기능을 지원하면, 이 매핑의 항목을 삭제하여 환경 변수를 삭제할 수 있습니다. 항목이 "
"``os.environ``\\에서 삭제되거나, :meth:`pop` 또는 :meth:`clear` 메서드 중 하나가 호출되면 "
":func:`unsetenv`\\가 자동으로 호출됩니다."

#: ../Doc/library/os.rst:144
msgid ""
"Bytes version of :data:`environ`: a :term:`mapping` object representing "
"the environment as byte strings. :data:`environ` and :data:`environb` are"
" synchronized (modify :data:`environb` updates :data:`environ`, and vice "
"versa)."
msgstr ""
":data:`environ`\\의 바이트열 버전: 환경을 바이트열로 나타내는 :term:`매핑 <mapping>` 객체입니다. "
":data:`environ`\\과 :data:`environb`\\는 동기화됩니다 (:data:`environb`\\를 수정하면 "
":data:`environ`\\이 갱신되고, 그 반대도 마찬가지입니다)."

#: ../Doc/library/os.rst:149
msgid ""
":data:`environb` is only available if :data:`supports_bytes_environ` is "
"True."
msgstr ""
":data:`environb`\\는 :data:`supports_bytes_environ`\\이 True인 경우에만 사용할 수 "
"있습니다."

#: ../Doc/library/os.rst:160
msgid "These functions are described in :ref:`os-file-dir`."
msgstr "이 함수는 :ref:`os-file-dir`\\에 설명되어 있습니다."

#: ../Doc/library/os.rst:165
msgid ""
"Encode :term:`path-like <path-like object>` *filename* to the filesystem "
"encoding with ``'surrogateescape'`` error handler, or ``'strict'`` on "
"Windows; return :class:`bytes` unchanged."
msgstr ""
"``'surrogateescape'`` 에러 처리기를, 또는 윈도우에서는 ``'strict'``\\를, 사용하여 파일 시스템 "
"인코딩으로 :term:`경로류 <path-like object>` *filename* 을 인코딩합니다; "
":class:`bytes`\\를 변경하지 않고 반환합니다."

#: ../Doc/library/os.rst:169
msgid ":func:`fsdecode` is the reverse function."
msgstr ":func:`fsdecode`\\는 역 함수입니다."

#: ../Doc/library/os.rst:173 ../Doc/library/os.rst:188
msgid ""
"Support added to accept objects implementing the :class:`os.PathLike` "
"interface."
msgstr ":class:`os.PathLike` 인터페이스를 구현하는 객체를 받아들이도록 지원이 추가되었습니다."

#: ../Doc/library/os.rst:180
msgid ""
"Decode the :term:`path-like <path-like object>` *filename* from the "
"filesystem encoding with ``'surrogateescape'`` error handler, or "
"``'strict'`` on Windows; return :class:`str` unchanged."
msgstr ""
"``'surrogateescape'`` 에러 처리기를, 또는 윈도우에서는 ``'strict'``\\를, 사용하여 파일 시스템 "
"인코딩으로 :term:`경로류 <path-like object>` *filename* 을 디코딩합니다; :class:`str`\\을"
" 변경하지 않고 반환합니다."

#: ../Doc/library/os.rst:184
msgid ":func:`fsencode` is the reverse function."
msgstr ":func:`fsencode`\\는 역 함수입니다."

#: ../Doc/library/os.rst:195
msgid "Return the file system representation of the path."
msgstr "경로의 파일 시스템 표현을 돌려줍니다."

#: ../Doc/library/os.rst:197
msgid ""
"If :class:`str` or :class:`bytes` is passed in, it is returned unchanged."
" Otherwise :meth:`~os.PathLike.__fspath__` is called and its value is "
"returned as long as it is a :class:`str` or :class:`bytes` object. In all"
" other cases, :exc:`TypeError` is raised."
msgstr ""
":class:`str`\\이나 :class:`bytes`\\가 전달되면, 변경되지 않은 상태로 반환됩니다. 그렇지 않으면 "
":meth:`~os.PathLike.__fspath__`\\가 호출되고, 해당 값이 :class:`str`\\이나 "
":class:`bytes` 객체인 한 그 값이 반환됩니다. 다른 모든 경우에는 :exc:`TypeError`\\가 발생합니다."

#: ../Doc/library/os.rst:207
msgid ""
"An :term:`abstract base class` for objects representing a file system "
"path, e.g. :class:`pathlib.PurePath`."
msgstr ""
"파일 시스템 경로를 나타내는 객체(예를 들어 :class:`pathlib.PurePath`)의 :term:`추상 베이스 클래스 "
"<abstract base class>`\\입니다."

#: ../Doc/library/os.rst:214
msgid "Return the file system path representation of the object."
msgstr "객체의 파일 시스템 경로 표현을 돌려줍니다."

#: ../Doc/library/os.rst:216
msgid ""
"The method should only return a :class:`str` or :class:`bytes` object, "
"with the preference being for :class:`str`."
msgstr ""
"이 메서드는 :class:`str`\\이나 :class:`bytes` 객체만 반환해야 하며, :class:`str`\\을 선호합니다."

#: ../Doc/library/os.rst:222
msgid ""
"Return the value of the environment variable *key* if it exists, or "
"*default* if it doesn't. *key*, *default* and the result are str."
msgstr ""
"존재하면 환경 변수 *key* 의 값을 반환하고, 그렇지 않으면 *default* 를 반환합니다. *key*, *default* 및"
" 결과는 str입니다."

#: ../Doc/library/os.rst:225
msgid ""
"On Unix, keys and values are decoded with "
":func:`sys.getfilesystemencoding` and ``'surrogateescape'`` error "
"handler. Use :func:`os.getenvb` if you would like to use a different "
"encoding."
msgstr ""
"유닉스에서, 키와 값은 :func:`sys.getfilesystemencoding` 과 ``'surrogateescape'`` 에러"
" 처리기로 디코딩됩니다. 다른 인코딩을 사용하려면 :func:`os.getenvb`\\를 사용하십시오."

#: ../Doc/library/os.rst:229 ../Doc/library/os.rst:442
#: ../Doc/library/os.rst:645
msgid ":ref:`Availability <availability>`: most flavors of Unix, Windows."
msgstr ":ref:`가용성 <availability>`: 대부분의 유닉스, 윈도우."

#: ../Doc/library/os.rst:234
msgid ""
"Return the value of the environment variable *key* if it exists, or "
"*default* if it doesn't. *key*, *default* and the result are bytes."
msgstr ""
"존재하면 환경 변수 *key* 의 값을 반환하고, 그렇지 않으면 *default* 를 반환합니다. *key*, *default* 및"
" 결과는 bytes입니다."

#: ../Doc/library/os.rst:237
msgid ""
":func:`getenvb` is only available if :data:`supports_bytes_environ` is "
"True."
msgstr ""
":func:`getenvb`\\는 :data:`supports_bytes_environ`\\이 True인 경우에만 사용할 수 "
"있습니다."

#: ../Doc/library/os.rst:241
msgid ":ref:`Availability <availability>`: most flavors of Unix."
msgstr ":ref:`가용성 <availability>`: 대부분의 유닉스."

#: ../Doc/library/os.rst:247
msgid ""
"Returns the list of directories that will be searched for a named "
"executable, similar to a shell, when launching a process. *env*, when "
"specified, should be an environment variable dictionary to lookup the "
"PATH in. By default, when *env* is ``None``, :data:`environ` is used."
msgstr ""
"셸과 비슷하게, 프로세스를 시작할 때 지정된 이름의 실행 파일을 검색할 디렉터리 리스트를 반환합니다. (지정된다면) *env* 는 "
"PATH를 조회할 환경 변수 딕셔너리 여야 합니다. 기본적으로, *env* 가 ``None``\\이면, "
":data:`environ`\\이 사용됩니다."

#: ../Doc/library/os.rst:258
msgid ""
"Return the effective group id of the current process.  This corresponds "
"to the \"set id\" bit on the file being executed in the current process."
msgstr ""
"현재 프로세스의 유효(effective) 그룹 ID를 반환합니다. 이것은 현재 프로세스에서 실행 중인 파일의 \"set id\" "
"비트에 해당합니다."

#: ../Doc/library/os.rst:268
msgid "Return the current process's effective user id."
msgstr "현재 프로세스의 유효(effective) 사용자 ID를 반환합니다."

#: ../Doc/library/os.rst:277
msgid "Return the real group id of the current process."
msgstr "현재 프로세스의 실제(real) 그룹 ID를 반환합니다."

#: ../Doc/library/os.rst:284
msgid ""
"Return list of group ids that *user* belongs to. If *group* is not in the"
" list, it is included; typically, *group* is specified as the group ID "
"field from the password record for *user*."
msgstr ""
"*user*\\가 속한 그룹 ID의 목록을 돌려줍니다. *group* 이 목록에 없으면 포함됩니다; 일반적으로 *group* 은 "
"*user* 의 암호 레코드에서 그룹 ID 필드로 지정됩니다."

#: ../Doc/library/os.rst:295
msgid "Return list of supplemental group ids associated with the current process."
msgstr "현재 프로세스와 관련된 보충(supplemental) 그룹 ID 목록을 반환합니다."

#: ../Doc/library/os.rst:301
msgid ""
"On Mac OS X, :func:`getgroups` behavior differs somewhat from other Unix "
"platforms. If the Python interpreter was built with a deployment target "
"of :const:`10.5` or earlier, :func:`getgroups` returns the list of "
"effective group ids associated with the current user process; this list "
"is limited to a system-defined number of entries, typically 16, and may "
"be modified by calls to :func:`setgroups` if suitably privileged. If "
"built with a deployment target greater than :const:`10.5`, "
":func:`getgroups` returns the current group access list for the user "
"associated with the effective user id of the process; the group access "
"list may change over the lifetime of the process, it is not affected by "
"calls to :func:`setgroups`, and its length is not limited to 16.  The "
"deployment target value, :const:`MACOSX_DEPLOYMENT_TARGET`, can be "
"obtained with :func:`sysconfig.get_config_var`."
msgstr ""
"맥 OS X에서, :func:`getgroups` 동작은 다른 유닉스 플랫폼과 약간 다릅니다. 파이썬 인터프리터가 "
":const:`10.5` 또는 이전 버전의 배포 대상으로 빌드되면, :func:`getgroups`\\는 현재 사용자 프로세스와 "
"관련된 유효 그룹 ID 목록을 반환합니다; 이 목록은 시스템 정의된 항목 수(일반적으로 16)로 제한되며, 적절하게 권한이 부여된 "
"경우 :func:`setgroups`\\를 호출하여 수정할 수 있습니다. :const:`10.5`\\보다 큰 배포 대상으로 "
"빌드되면, :func:`getgroups`\\는 프로세스의 유효 사용자 ID와 연관된 사용자에 대한 현재 그룹 액세스 목록을 "
"반환합니다; 그룹 액세스 목록은 프로세스 수명 동안 변경될 수 있으며, :func:`setgroups` 호출의 영향을 받지 않고, "
"길이도 16개로 제한되지 않습니다. 배포 대상 값(:const:`MACOSX_DEPLOYMENT_TARGET`)은 "
":func:`sysconfig.get_config_var`\\를 통해 얻을 수 있습니다."

#: ../Doc/library/os.rst:318
msgid ""
"Return the name of the user logged in on the controlling terminal of the "
"process.  For most purposes, it is more useful to use "
":func:`getpass.getuser` since the latter checks the environment variables"
" :envvar:`LOGNAME` or :envvar:`USERNAME` to find out who the user is, and"
" falls back to ``pwd.getpwuid(os.getuid())[0]`` to get the login name of "
"the current real user id."
msgstr ""
"프로세스의 제어 터미널에 로그인한 사용자의 이름을 반환합니다. 대부분 목적에서, :func:`getpass.getuser`\\를 "
"사용하는 것이 더 유용한데, 이 함수는 환경 변수 :envvar:`LOGNAME` 이나 :envvar:`USERNAME`\\을 "
"검사하여 사용자가 누구인지 알아내고, 현재 실제 사용자 ID의 로그인 이름을 얻기 위해 "
"``pwd.getpwuid(os.getuid())[0]``\\로 폴백 하기 때문입니다."

#: ../Doc/library/os.rst:325 ../Doc/library/os.rst:360
#: ../Doc/library/os.rst:822 ../Doc/library/os.rst:832
#: ../Doc/library/os.rst:1018 ../Doc/library/os.rst:1387
#: ../Doc/library/os.rst:1746 ../Doc/library/os.rst:2000
#: ../Doc/library/os.rst:2719 ../Doc/library/os.rst:2748
#: ../Doc/library/os.rst:3134 ../Doc/library/os.rst:3497
#: ../Doc/library/os.rst:3508 ../Doc/library/os.rst:3576
#: ../Doc/library/os.rst:3600
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`가용성 <availability>`: 유닉스, 윈도우."

#: ../Doc/library/os.rst:330
msgid ""
"Return the process group id of the process with process id *pid*. If "
"*pid* is 0, the process group id of the current process is returned."
msgstr ""
"프로세스 ID *pid* 를 갖는 프로세스의 프로세스 그룹 ID를 반환합니다. *pid* 가 0이면, 현재 프로세스의 프로세스 그룹"
" id가 반환됩니다."

#: ../Doc/library/os.rst:339
msgid "Return the id of the current process group."
msgstr "현재 프로세스 그룹의 ID를 반환합니다."

#: ../Doc/library/os.rst:348
msgid "Return the current process id."
msgstr "현재의 프로세스 ID를 반환합니다."

#: ../Doc/library/os.rst:355
msgid ""
"Return the parent's process id.  When the parent process has exited, on "
"Unix the id returned is the one of the init process (1), on Windows it is"
" still the same id, which may be already reused by another process."
msgstr ""
"부모의 프로세스 ID를 반환합니다. 부모 프로세스가 종료했으면, 유닉스에서 반환된 id는 init 프로세스 (1) 중 하나이며, "
"윈도우에서는 여전히 같은 id인데, 다른 프로세스에서 이미 재사용했을 수 있습니다."

#: ../Doc/library/os.rst:361
msgid "Added support for Windows."
msgstr "윈도우에 대한 지원이 추가되었습니다."

#: ../Doc/library/os.rst:369
msgid ""
"Get program scheduling priority.  The value *which* is one of "
":const:`PRIO_PROCESS`, :const:`PRIO_PGRP`, or :const:`PRIO_USER`, and "
"*who* is interpreted relative to *which* (a process identifier for "
":const:`PRIO_PROCESS`, process group identifier for :const:`PRIO_PGRP`, "
"and a user ID for :const:`PRIO_USER`).  A zero value for *who* denotes "
"(respectively) the calling process, the process group of the calling "
"process, or the real user ID of the calling process."
msgstr ""
"프로그램 스케줄 우선순위를 얻습니다. *which* 값은 :const:`PRIO_PROCESS`, :const:`PRIO_PGRP`"
" 또는 :const:`PRIO_USER` 중 하나이고, *who*\\는 *which* 에 상대적으로 해석됩니다 "
"(:const:`PRIO_PROCESS` 면 프로세스 식별자, :const:`PRIO_PGRP` 면 프로세스 그룹 식별자, "
":const:`PRIO_USER` 면 사용자 ID). 0 값의 *who*\\는 (각각) 호출하는 프로세스, 호출하는 프로세스의 "
"프로세스 그룹, 호출하는 프로세스의 실제 사용자 ID를 나타냅니다."

#: ../Doc/library/os.rst:386
msgid "Parameters for the :func:`getpriority` and :func:`setpriority` functions."
msgstr ":func:`getpriority` 와 :func:`setpriority` 함수의 매개 변숫값"

#: ../Doc/library/os.rst:395
msgid ""
"Return a tuple (ruid, euid, suid) denoting the current process's real, "
"effective, and saved user ids."
msgstr ""
"현재 프로세스의 실제(real), 유효(effective) 및 저장된(saved) 사용자 ID를 나타내는 튜플 (ruid, "
"euid, suid)를 반환합니다."

#: ../Doc/library/os.rst:405
msgid ""
"Return a tuple (rgid, egid, sgid) denoting the current process's real, "
"effective, and saved group ids."
msgstr ""
"현재 프로세스의 실제(real), 유효(effective) 및 저장된(saved) 그룹 ID를 나타내는 튜플 (rgid, egid,"
" sgid)를 반환합니다."

#: ../Doc/library/os.rst:417
msgid "Return the current process's real user id."
msgstr "현재 프로세스의 실제(real) 사용자 ID를 반환합니다."

#: ../Doc/library/os.rst:424
msgid ""
"Call the system initgroups() to initialize the group access list with all"
" of the groups of which the specified username is a member, plus the "
"specified group id."
msgstr ""
"지정된 사용자 이름이 구성원인 모든 그룹과 지정된 그룹 ID로 구성된 그룹 액세스 목록을 초기화하기 위해 시스템 "
"initgroups()를 호출합니다."

#: ../Doc/library/os.rst:437
msgid ""
"Set the environment variable named *key* to the string *value*.  Such "
"changes to the environment affect subprocesses started with "
":func:`os.system`, :func:`popen` or :func:`fork` and :func:`execv`."
msgstr ""
"*key* 라는 환경 변수를 문자열 *value* 로 설정합니다. 이러한 환경의 변화는 :func:`os.system`, "
":func:`popen` 또는 :func:`fork` 및 :func:`execv`\\로 시작된 자식 프로세스에 영향을 줍니다."

#: ../Doc/library/os.rst:445
msgid ""
"On some platforms, including FreeBSD and Mac OS X, setting ``environ`` "
"may cause memory leaks. Refer to the system documentation for putenv."
msgstr ""
"FreeBSD 및 맥 OS X를 포함한 일부 플랫폼에서, ``environ``\\를 설정하면 메모리 누수가 발생할 수 있습니다. "
"putenv에 관한 시스템 설명서를 참조하십시오."

#: ../Doc/library/os.rst:448
msgid ""
"When :func:`putenv` is supported, assignments to items in ``os.environ`` "
"are automatically translated into corresponding calls to :func:`putenv`; "
"however, calls to :func:`putenv` don't update ``os.environ``, so it is "
"actually preferable to assign to items of ``os.environ``."
msgstr ""
":func:`putenv`\\가 지원되면, ``os.environ``\\의 항목에 대한 대입이 :func:`putenv`\\에 대한"
" 해당 호출로 자동 변환됩니다. 그러나, :func:`putenv`\\에 대한 호출은 ``os.environ``\\을 갱신하지 "
"않으므로, 실제로는 ``os.environ`` 항목에 대입하는 것이 좋습니다."

#: ../Doc/library/os.rst:456
msgid "Set the current process's effective group id."
msgstr "현재 프로세스의 유효 그룹 ID를 설정합니다."

#: ../Doc/library/os.rst:463
msgid "Set the current process's effective user id."
msgstr "현재 프로세스의 유효 사용자 ID를 설정합니다."

#: ../Doc/library/os.rst:470
msgid "Set the current process' group id."
msgstr "현재 프로세스의 그룹 ID를 설정합니다."

#: ../Doc/library/os.rst:477
msgid ""
"Set the list of supplemental group ids associated with the current "
"process to *groups*. *groups* must be a sequence, and each element must "
"be an integer identifying a group. This operation is typically available "
"only to the superuser."
msgstr ""
"현재 프로세스와 연관된 보충(supplemental) 그룹 ID의 목록을 *groups*\\로 설정합니다. *groups* 는 "
"시퀀스 여야 하며, 각 요소는 그룹을 식별하는 정수여야 합니다. 이 연산은 대개 슈퍼 유저만 사용할 수 있습니다."

#: ../Doc/library/os.rst:483
msgid ""
"On Mac OS X, the length of *groups* may not exceed the system-defined "
"maximum number of effective group ids, typically 16. See the "
"documentation for :func:`getgroups` for cases where it may not return the"
" same group list set by calling setgroups()."
msgstr ""
"맥 OS X에서 *groups* 의 길이는 시스템이 정의한 최대 유효 그룹 ID 수(일반적으로 16)를 초과할 수 없습니다. "
"setgroups()를 호출해서 설정한 것과 같은 그룹 목록을 반환하지 않는 경우에 관해서는 :func:`getgroups` "
"설명서를 참조하십시오."

#: ../Doc/library/os.rst:490
msgid ""
"Call the system call :c:func:`setpgrp` or ``setpgrp(0, 0)`` depending on "
"which version is implemented (if any).  See the Unix manual for the "
"semantics."
msgstr ""
"구현된 (있기는 하다면) 버전에 따라 시스템 호출 :c:func:`setpgrp` 나 ``setpgrp(0, 0)``\\을 "
"호출합니다. 의미에 대해서는 유닉스 매뉴얼을 참조하십시오."

#: ../Doc/library/os.rst:498
msgid ""
"Call the system call :c:func:`setpgid` to set the process group id of the"
" process with id *pid* to the process group with id *pgrp*.  See the Unix"
" manual for the semantics."
msgstr ""
"프로세스 ID가 *pid* 인 프로세스의 프로세스 그룹 ID를 *pgrp* 로 설정하기 위해 시스템 호출 "
":c:func:`setpgid`\\를 호출합니다. 의미에 대해서는 유닉스 매뉴얼을 참조하십시오."

#: ../Doc/library/os.rst:509
msgid ""
"Set program scheduling priority. The value *which* is one of "
":const:`PRIO_PROCESS`, :const:`PRIO_PGRP`, or :const:`PRIO_USER`, and "
"*who* is interpreted relative to *which* (a process identifier for "
":const:`PRIO_PROCESS`, process group identifier for :const:`PRIO_PGRP`, "
"and a user ID for :const:`PRIO_USER`). A zero value for *who* denotes "
"(respectively) the calling process, the process group of the calling "
"process, or the real user ID of the calling process. *priority* is a "
"value in the range -20 to 19. The default priority is 0; lower priorities"
" cause more favorable scheduling."
msgstr ""
"프로그램 스케줄 우선순위를 설정합니다. *which* 값은 :const:`PRIO_PROCESS`, "
":const:`PRIO_PGRP` 또는 :const:`PRIO_USER` 중 하나이고, *who*\\는 *which* 에 상대적으로"
" 해석됩니다 (:const:`PRIO_PROCESS` 면 프로세스 식별자, :const:`PRIO_PGRP` 면 프로세스 그룹 "
"식별자, :const:`PRIO_USER` 면 사용자 ID). 0 값의 *who*\\는 (각각) 호출하는 프로세스, 호출하는 "
"프로세스의 프로세스 그룹, 호출하는 프로세스의 실제 사용자 ID를 나타냅니다. *priority* 는 -20에서 19 사이의 "
"값입니다. 기본 우선순위는 0입니다; 우선순위가 낮으면 더 유리하게 스케줄 됩니다."

#: ../Doc/library/os.rst:526
msgid "Set the current process's real and effective group ids."
msgstr "현재 프로세스의 실제(real) 및 유효한(effective) 그룹 ID를 설정합니다."

#: ../Doc/library/os.rst:533
msgid "Set the current process's real, effective, and saved group ids."
msgstr "현재 프로세스의 실제(real), 유효(effective) 및 저장된(saved) 그룹 ID를 설정합니다."

#: ../Doc/library/os.rst:542
msgid "Set the current process's real, effective, and saved user ids."
msgstr "현재 프로세스의 실제(real), 유효(effective) 및 저장된(saved) 사용자 ID를 설정합니다."

#: ../Doc/library/os.rst:551
msgid "Set the current process's real and effective user ids."
msgstr "현재 프로세스의 실제(real) 및 유효(effective) 사용자 ID를 설정합니다."

#: ../Doc/library/os.rst:558
msgid ""
"Call the system call :c:func:`getsid`.  See the Unix manual for the "
"semantics."
msgstr "시스템 호출 :c:func:`getsid`\\를 호출합니다. 의미에 대해서는 유닉스 매뉴얼을 참조하십시오."

#: ../Doc/library/os.rst:565
msgid ""
"Call the system call :c:func:`setsid`.  See the Unix manual for the "
"semantics."
msgstr "시스템 호출 :c:func:`setsid`\\를 호출합니다. 의미에 대해서는 유닉스 매뉴얼을 참조하십시오."

#: ../Doc/library/os.rst:574
msgid "Set the current process's user id."
msgstr "현재 프로세스의 사용자 ID를 설정합니다."

#: ../Doc/library/os.rst:582
msgid ""
"Return the error message corresponding to the error code in *code*. On "
"platforms where :c:func:`strerror` returns ``NULL`` when given an unknown"
" error number, :exc:`ValueError` is raised."
msgstr ""
"에러 코드 *code*\\에 해당하는 에러 메시지를 반환합니다. 알 수 없는 에러 코드가 주어질 때 "
":c:func:`strerror`\\가 ``NULL``\\을 반환하는 플랫폼에서, :exc:`ValueError`\\가 발생합니다."

#: ../Doc/library/os.rst:589
msgid ""
"``True`` if the native OS type of the environment is bytes (eg. ``False``"
" on Windows)."
msgstr "환경의 원시 OS 형이 바이트열이면 ``True`` (예를 들어, 윈도우에서는 ``False``)."

#: ../Doc/library/os.rst:597
msgid "Set the current numeric umask and return the previous umask."
msgstr "현재 숫자 umask를 설정하고 이전 umask를 반환합니다."

#: ../Doc/library/os.rst:606
msgid ""
"Returns information identifying the current operating system. The return "
"value is an object with five attributes:"
msgstr "현재 운영 체제를 식별하는 정보를 반환합니다. 반환 값은 5가지 어트리뷰트를 가진 객체입니다:"

#: ../Doc/library/os.rst:609
msgid ":attr:`sysname` - operating system name"
msgstr ":attr:`sysname` - 운영 체제 이름"

#: ../Doc/library/os.rst:610
msgid ":attr:`nodename` - name of machine on network (implementation-defined)"
msgstr ":attr:`nodename` - 네트워크상의 기계 이름 (구현이 정의)"

#: ../Doc/library/os.rst:611
msgid ":attr:`release` - operating system release"
msgstr ":attr:`release` - 운영 체제 릴리스"

#: ../Doc/library/os.rst:612
msgid ":attr:`version` - operating system version"
msgstr ":attr:`version` - 운영 체제 버전"

#: ../Doc/library/os.rst:613
msgid ":attr:`machine` - hardware identifier"
msgstr ":attr:`machine` - 하드웨어 식별자"

#: ../Doc/library/os.rst:615
msgid ""
"For backwards compatibility, this object is also iterable, behaving like "
"a five-tuple containing :attr:`sysname`, :attr:`nodename`, "
":attr:`release`, :attr:`version`, and :attr:`machine` in that order."
msgstr ""
"하위 호환성을 위해, 이 객체는 이터러블이기도 해서, :attr:`sysname`, :attr:`nodename`, "
":attr:`release`, :attr:`version` 및 :attr:`machine`\\이 이 순서로 포함된 5-튜플처럼 "
"작동합니다."

#: ../Doc/library/os.rst:620
msgid ""
"Some systems truncate :attr:`nodename` to 8 characters or to the leading "
"component; a better way to get the hostname is :func:`socket.gethostname`"
"  or even ``socket.gethostbyaddr(socket.gethostname())``."
msgstr ""
"일부 시스템에서는 :attr:`nodename`\\을 8자나 선행 구성 요소로 자릅니다; 호스트 이름을 얻는 더 좋은 방법은 "
":func:`socket.gethostname` 또는 더 나아가 "
"``socket.gethostbyaddr(socket.gethostname())``\\입니다."

#: ../Doc/library/os.rst:626
msgid ":ref:`Availability <availability>`: recent flavors of Unix."
msgstr ":ref:`가용성 <availability>`: 최근 유닉스."

#: ../Doc/library/os.rst:627 ../Doc/library/os.rst:3601
msgid ""
"Return type changed from a tuple to a tuple-like object with named "
"attributes."
msgstr "반환형이 튜플에서 이름이 지정된 어트리뷰트를 가진 튜플류 객체로 변경되었습니다."

#: ../Doc/library/os.rst:636
msgid ""
"Unset (delete) the environment variable named *key*. Such changes to the "
"environment affect subprocesses started with :func:`os.system`, "
":func:`popen` or :func:`fork` and :func:`execv`."
msgstr ""
"*key* 라는 이름의 환경 변수를 삭제합니다. 이러한 환경 변화는 :func:`os.system`, :func:`popen` 또는"
" :func:`fork` 및 :func:`execv`\\로 시작된 자식 프로세스에 영향을 줍니다."

#: ../Doc/library/os.rst:640
msgid ""
"When :func:`unsetenv` is supported, deletion of items in ``os.environ`` "
"is automatically translated into a corresponding call to "
":func:`unsetenv`; however, calls to :func:`unsetenv` don't update "
"``os.environ``, so it is actually preferable to delete items of "
"``os.environ``."
msgstr ""
":func:`unsetenv`\\가 지원되면, ``os.environ``\\의 항목 삭제가 자동으로 "
":func:`unsetenv`\\에 대한 해당 호출로 변환됩니다. 그러나 :func:`unsetenv`\\에 대한 호출은 "
"``os.environ``\\을 갱신하지 않으므로, 실제로는 ``os.environ`` 항목을 삭제하는 것이 좋습니다."

#: ../Doc/library/os.rst:651
msgid "File Object Creation"
msgstr "파일 객체 생성"

#: ../Doc/library/os.rst:653
msgid ""
"This function creates new :term:`file objects <file object>`.  (See also "
":func:`~os.open` for opening file descriptors.)"
msgstr ""
"이 함수는 새로운 :term:`파일 객체 <file object>`\\를 만듭니다. (파일 기술자를 여는 것에 관해서는 "
":func:`~os.open`\\를 참조하십시오.)"

#: ../Doc/library/os.rst:659
msgid ""
"Return an open file object connected to the file descriptor *fd*.  This "
"is an alias of the :func:`open` built-in function and accepts the same "
"arguments. The only difference is that the first argument of "
":func:`fdopen` must always be an integer."
msgstr ""
"파일 기술자 *fd에* 연결된 열린 파일 객체를 반환합니다. 이것은 :func:`open` 내장 함수의 별칭이며 같은 인자를 "
"받아들입니다. 유일한 차이점은 :func:`fdopen`\\의 첫 번째 인자는 항상 정수여야 한다는 것입니다."

#: ../Doc/library/os.rst:668
msgid "File Descriptor Operations"
msgstr "파일 기술자 연산"

#: ../Doc/library/os.rst:670
msgid "These functions operate on I/O streams referenced using file descriptors."
msgstr "이 함수들은 파일 기술자를 사용하여 참조된 I/O 스트림에 작용합니다."

#: ../Doc/library/os.rst:672
msgid ""
"File descriptors are small integers corresponding to a file that has been"
" opened by the current process.  For example, standard input is usually "
"file descriptor 0, standard output is 1, and standard error is 2.  "
"Further files opened by a process will then be assigned 3, 4, 5, and so "
"forth.  The name \"file descriptor\" is slightly deceptive; on Unix "
"platforms, sockets and pipes are also referenced by file descriptors."
msgstr ""
"파일 기술자는 현재 프로세스에 의해 열린 파일에 대응하는 작은 정수입니다. 예를 들어, 표준 입력은 보통 파일 기술자 0이고, 표준"
" 출력은 1이며, 표준 에러는 2입니다. 프로세스에 의해 열린 추가 파일은 3, 4, 5 등으로 지정됩니다. \"파일 기술자\"라는"
" 이름은 약간 기만적입니다; 유닉스 플랫폼에서, 소켓과 파이프도 파일 기술자에 의해 참조됩니다."

#: ../Doc/library/os.rst:679
msgid ""
"The :meth:`~io.IOBase.fileno` method can be used to obtain the file "
"descriptor associated with a :term:`file object` when required.  Note "
"that using the file descriptor directly will bypass the file object "
"methods, ignoring aspects such as internal buffering of data."
msgstr ""
":meth:`~io.IOBase.fileno` 메서드는 필요할 때 :term:`파일 객체 <file object>`\\와 연관된 "
"파일 기술자를 얻는 데 사용될 수 있습니다. 파일 기술자를 직접 사용하면 파일 객체 메서드를 거치지 않아서, 데이터의 내부 버퍼링과"
" 같은 측면을 무시하게 되는 것에 유의하십시오."

#: ../Doc/library/os.rst:687
msgid "Close file descriptor *fd*."
msgstr "파일 기술자 *fd*\\를 닫습니다."

#: ../Doc/library/os.rst:691
msgid ""
"This function is intended for low-level I/O and must be applied to a file"
" descriptor as returned by :func:`os.open` or :func:`pipe`.  To close a "
"\"file object\" returned by the built-in function :func:`open` or by "
":func:`popen` or :func:`fdopen`, use its :meth:`~io.IOBase.close` method."
msgstr ""
"이 함수는 저수준 I/O를 위한 것이며, :func:`os.open` 또는 :func:`pipe`\\에 의해 반환된 파일 기술자에 "
"적용되어야 합니다. 내장 함수 :func:`open` 나 :func:`popen` 또는 :func:`fdopen`\\에 의해 반환된"
" \"파일 객체\"를 닫으려면, :meth:`~io.IOBase.close` 메서드를 사용하십시오."

#: ../Doc/library/os.rst:699
msgid ""
"Close all file descriptors from *fd_low* (inclusive) to *fd_high* "
"(exclusive), ignoring errors. Equivalent to (but much faster than)::"
msgstr ""
"에러는 무시하면서, *fd_low*\\(포함)부터 *fd_high*\\(제외)까지 모든 파일 기술자를 닫습니다. 다음과 동등합니다 "
"(하지만 훨씬 빠릅니다)::"

#: ../Doc/library/os.rst:711
msgid ""
"Return a string describing the encoding of the device associated with "
"*fd* if it is connected to a terminal; else return :const:`None`."
msgstr ""
"*fd* 와 연관된 장치가 터미널에 연결되어 있을 때 인코딩을 설명하는 문자열을 반환합니다; 그렇지 않으면 "
":const:`None`\\을 반환합니다."

#: ../Doc/library/os.rst:717
msgid ""
"Return a duplicate of file descriptor *fd*. The new file descriptor is "
":ref:`non-inheritable <fd_inheritance>`."
msgstr ""
"파일 기술자 *fd* 의 복사본을 반환합니다. 새 파일 기술자는 :ref:`상속 불가능 <fd_inheritance>`\\합니다."

#: ../Doc/library/os.rst:720
msgid ""
"On Windows, when duplicating a standard stream (0: stdin, 1: stdout, 2: "
"stderr), the new file descriptor is :ref:`inheritable <fd_inheritance>`."
msgstr ""
"윈도우에서는, 표준 스트림(0: stdin, 1: stdout, 2: stderr)을 복제할 때, 새 파일 기술자가 :ref:`상속"
" 가능 <fd_inheritance>`\\합니다."

#: ../Doc/library/os.rst:724 ../Doc/library/os.rst:914
msgid "The new file descriptor is now non-inheritable."
msgstr "새로운 파일 기술자는 이제 상속 불가능합니다."

#: ../Doc/library/os.rst:730
msgid ""
"Duplicate file descriptor *fd* to *fd2*, closing the latter first if "
"necessary. Return *fd2*. The new file descriptor is :ref:`inheritable "
"<fd_inheritance>` by default or non-inheritable if *inheritable* is "
"``False``."
msgstr ""
"파일 기술자 *fd* 를 *fd2*\\에 복제하고, 필요하면 먼저 후자를 닫습니다. *fd2*\\를 반환합니다. 새로운 파일 "
"기술자는 기본적으로 :ref:`상속 가능 <fd_inheritance>`\\하고, *inheritable* 이 "
"``False``\\면 상속 불가능합니다."

#: ../Doc/library/os.rst:735
msgid "Add the optional *inheritable* parameter."
msgstr "선택적 *inheritable* 매개 변수를 추가했습니다."

#: ../Doc/library/os.rst:738
msgid "Return *fd2* on success. Previously, ``None`` was always returned."
msgstr "성공하면 *fd2* 를 반환합니다. 이전에는 항상 ``None``\\을 반환했습니다."

#: ../Doc/library/os.rst:744
msgid ""
"Change the mode of the file given by *fd* to the numeric *mode*.  See the"
" docs for :func:`chmod` for possible values of *mode*.  As of Python 3.3,"
" this is equivalent to ``os.chmod(fd, mode)``."
msgstr ""
"*fd* 에 의해 주어진 파일의 모드를 숫자 *mode* 로 변경합니다. *mode*\\의 가능한 값은 :func:`chmod` "
"문서를 참조하십시오. 파이썬 3.3부터는, ``os.chmod(fd, mode)``\\와 같습니다."

#: ../Doc/library/os.rst:753
msgid ""
"Change the owner and group id of the file given by *fd* to the numeric "
"*uid* and *gid*.  To leave one of the ids unchanged, set it to -1.  See "
":func:`chown`.  As of Python 3.3, this is equivalent to ``os.chown(fd, "
"uid, gid)``."
msgstr ""
"*fd* 에 의해 주어진 파일의 소유자와 그룹 id를 숫자 *uid* 와 *gid*\\로 변경합니다. ID 중 하나를 변경하지 "
"않으려면, 그것을 -1로 설정하십시오. :func:`chown`\\를 참조하십시오. 파이썬 3.3부터는, ``os.chown(fd,"
" uid, gid)``\\와 같습니다."

#: ../Doc/library/os.rst:763
msgid ""
"Force write of file with filedescriptor *fd* to disk. Does not force "
"update of metadata."
msgstr "파일 기술자 *fd* 로 주어진 파일을 디스크에 쓰도록 강제합니다. 메타 데이터를 갱신하도록 강제하지 않습니다."

#: ../Doc/library/os.rst:769
msgid "This function is not available on MacOS."
msgstr "이 함수는 MacOS에서는 사용할 수 없습니다."

#: ../Doc/library/os.rst:774
msgid ""
"Return system configuration information relevant to an open file. *name* "
"specifies the configuration value to retrieve; it may be a string which "
"is the name of a defined system value; these names are specified in a "
"number of standards (POSIX.1, Unix 95, Unix 98, and others).  Some "
"platforms define additional names as well.  The names known to the host "
"operating system are given in the ``pathconf_names`` dictionary.  For "
"configuration variables not included in that mapping, passing an integer "
"for *name* is also accepted."
msgstr ""
"열린 파일과 관련된 시스템 구성 정보를 반환합니다. *name* 은 조회할 구성 값을 지정합니다; 정의된 시스템 값의 이름인 "
"문자열일 수 있습니다; 이 이름은 여러 표준(POSIX.1, 유닉스 95, 유닉스 98 및 기타)에서 지정됩니다. 일부 플랫폼은 "
"추가 이름도 정의합니다. 호스트 운영 체제에 알려진 이름은 ``pathconf_names`` 딕셔너리에서 제공됩니다. 이 매핑에 "
"포함되지 않은 구성 변수의 경우, *name*\\에 정수를 전달하는 것도 허용됩니다."

#: ../Doc/library/os.rst:782 ../Doc/library/os.rst:1961
msgid ""
"If *name* is a string and is not known, :exc:`ValueError` is raised.  If "
"a specific value for *name* is not supported by the host system, even if "
"it is included in ``pathconf_names``, an :exc:`OSError` is raised with "
":const:`errno.EINVAL` for the error number."
msgstr ""
"*name* 이 문자열이고 알 수 없으면, :exc:`ValueError`\\가 발생합니다. *name*\\에 대한 특정 값이 "
"호스트 시스템에서 지원되지 않으면, ``pathconf_names``\\에 포함되어 있어도, 에러 번호가 "
":const:`errno.EINVAL`\\인 :exc:`OSError`\\가 발생합니다."

#: ../Doc/library/os.rst:787
msgid "As of Python 3.3, this is equivalent to ``os.pathconf(fd, name)``."
msgstr "파이썬 3.3부터, ``os.pathconf(fd, name)``\\과 같습니다."

#: ../Doc/library/os.rst:794
msgid ""
"Get the status of the file descriptor *fd*. Return a :class:`stat_result`"
" object."
msgstr "파일 기술자 *fd* 의 상태를 가져옵니다. :class:`stat_result` 객체를 반환합니다."

#: ../Doc/library/os.rst:797
msgid "As of Python 3.3, this is equivalent to ``os.stat(fd)``."
msgstr "파이썬 3.3부터는, ``os.stat(fd)``\\와 같습니다."

#: ../Doc/library/os.rst:801 ../Doc/library/os.rst:1807
msgid "The :func:`.stat` function."
msgstr ":func:`.stat` 함수."

#: ../Doc/library/os.rst:806
msgid ""
"Return information about the filesystem containing the file associated "
"with file descriptor *fd*, like :func:`statvfs`.  As of Python 3.3, this "
"is equivalent to ``os.statvfs(fd)``."
msgstr ""
":func:`statvfs` 처럼, 파일 기술자 *fd* 와 연관된 파일을 포함하는 파일 시스템에 대한 정보를 반환합니다. 파이썬 "
"3.3부터는, ``os.statvfs(fd)``\\와 같습니다."

#: ../Doc/library/os.rst:815
msgid ""
"Force write of file with filedescriptor *fd* to disk.  On Unix, this "
"calls the native :c:func:`fsync` function; on Windows, the MS "
":c:func:`_commit` function."
msgstr ""
"파일 기술자 *fd* 의 파일을 디스크에 쓰도록 강제합니다. 유닉스에서는, 네이티브 :c:func:`fsync` 함수를 호출합니다;"
" 윈도우에서는, MS :c:func:`_commit` 함수."

#: ../Doc/library/os.rst:818
msgid ""
"If you're starting with a buffered Python :term:`file object` *f*, first "
"do ``f.flush()``, and then do ``os.fsync(f.fileno())``, to ensure that "
"all internal buffers associated with *f* are written to disk."
msgstr ""
"버퍼링 된 파이썬 :term:`파일 객체 <file object>` *f*\\로 시작하는 경우, *f* 와 연관된 모든 내부 버퍼가"
" 디스크에 기록되게 하려면, 먼저 ``f.flush()``\\를 수행한 다음 ``os.fsync(f.fileno())``\\를 "
"하십시오."

#: ../Doc/library/os.rst:827
msgid ""
"Truncate the file corresponding to file descriptor *fd*, so that it is at"
" most *length* bytes in size.  As of Python 3.3, this is equivalent to "
"``os.truncate(fd, length)``."
msgstr ""
"파일 기술자 *fd*\\에 해당하는 파일을 잘라내어 최대 *length* 바이트가 되도록 만듭니다. 파이썬 3.3부터는, "
"``os.truncate(fd, length)``\\와 같습니다."

#: ../Doc/library/os.rst:833 ../Doc/library/os.rst:2751
msgid "Added support for Windows"
msgstr "윈도우 지원 추가"

#: ../Doc/library/os.rst:838
msgid ""
"Get the blocking mode of the file descriptor: ``False`` if the "
":data:`O_NONBLOCK` flag is set, ``True`` if the flag is cleared."
msgstr ""
"파일 기술자의 블로킹 모드를 얻어옵니다: :data:`O_NONBLOCK` 플래그가 설정되었으면 ``False``, 플래그가 "
"지워졌으면 ``True``."

#: ../Doc/library/os.rst:841
msgid "See also :func:`set_blocking` and :meth:`socket.socket.setblocking`."
msgstr ":func:`set_blocking` 및 :meth:`socket.socket.setblocking`\\도 참조하십시오."

#: ../Doc/library/os.rst:849
msgid ""
"Return ``True`` if the file descriptor *fd* is open and connected to a "
"tty(-like) device, else ``False``."
msgstr ""
"파일 기술자 *fd* 가 열려 있고 tty(류의) 장치에 연결되어 있으면 ``True``\\를 반환하고, 그렇지 않으면 "
"``False``\\를 반환합니다."

#: ../Doc/library/os.rst:855
msgid ""
"Apply, test or remove a POSIX lock on an open file descriptor. *fd* is an"
" open file descriptor. *cmd* specifies the command to use - one of "
":data:`F_LOCK`, :data:`F_TLOCK`, :data:`F_ULOCK` or :data:`F_TEST`. *len*"
" specifies the section of the file to lock."
msgstr ""
"열린 파일 기술자에 POSIX 록을 적용, 검사 또는 제거합니다. *fd* 는 열린 파일 기술자입니다. *cmd* 는 사용할 명령을"
" 지정합니다 - :data:`F_LOCK`, :data:`F_TLOCK`, :data:`F_ULOCK` 또는 "
":data:`F_TEST` 중 하나. *len* 은 잠글 파일의 영역을 지정합니다."

#: ../Doc/library/os.rst:871
msgid "Flags that specify what action :func:`lockf` will take."
msgstr ":func:`lockf`\\가 취할 조치를 지정하는 플래그."

#: ../Doc/library/os.rst:880
msgid ""
"Set the current position of file descriptor *fd* to position *pos*, "
"modified by *how*: :const:`SEEK_SET` or ``0`` to set the position "
"relative to the beginning of the file; :const:`SEEK_CUR` or ``1`` to set "
"it relative to the current position; :const:`SEEK_END` or ``2`` to set it"
" relative to the end of the file. Return the new cursor position in "
"bytes, starting from the beginning."
msgstr ""
"파일 기술자 *fd* 의 현재 위치를 *how* 에 따라 달리 해석되는 위치 *pos*\\로 설정합니다: "
":const:`SEEK_SET` 이나 ``0`` 이면 파일의 시작 부분을 기준으로 위치를 설정합니다; "
":const:`SEEK_CUR`\\이나 ``1`` 이면 현재 위치를 기준으로 설정합니다; :const:`SEEK_END` 나 "
"``2`` 면 파일의 끝을 기준으로 설정합니다. 새 커서 위치를 파일의 시작에서 따진 바이트로 반환합니다."

#: ../Doc/library/os.rst:891
msgid ""
"Parameters to the :func:`lseek` function. Their values are 0, 1, and 2, "
"respectively."
msgstr ":func:`lseek` 함수의 매개 변수. 값은 각각 0, 1, 2입니다."

#: ../Doc/library/os.rst:894
msgid ""
"Some operating systems could support additional values, like "
":data:`os.SEEK_HOLE` or :data:`os.SEEK_DATA`."
msgstr ""
"일부 운영 체제는 :data:`os.SEEK_HOLE` 이나 :data:`os.SEEK_DATA`\\와 같은 추가 값을 지원할 수 "
"있습니다."

#: ../Doc/library/os.rst:901
msgid ""
"Open the file *path* and set various flags according to *flags* and "
"possibly its mode according to *mode*.  When computing *mode*, the "
"current umask value is first masked out.  Return the file descriptor for "
"the newly opened file. The new file descriptor is :ref:`non-inheritable "
"<fd_inheritance>`."
msgstr ""
"파일 *path*\\를 열고 *flags* 에 따른 다양한 플래그와 때로 *mode* 따른 모드를 설정합니다. *mode*\\를 "
"계산할 때, 현재 umask 값으로 먼저 마스킹합니다. 새롭게 열린 파일의 파일 기술자를 돌려줍니다. 새 파일 기술자는 "
":ref:`상속 불가능 <fd_inheritance>`\\합니다."

#: ../Doc/library/os.rst:906
msgid ""
"For a description of the flag and mode values, see the C run-time "
"documentation; flag constants (like :const:`O_RDONLY` and "
":const:`O_WRONLY`) are defined in the :mod:`os` module.  In particular, "
"on Windows adding :const:`O_BINARY` is needed to open files in binary "
"mode."
msgstr ""
"플래그와 모드 값에 대한 설명은, C 런타임 설명서를 참조하십시오; 플래그 상수(:const:`O_RDONLY` 와 "
":const:`O_WRONLY`\\와 같은)는 :mod:`os` 모듈에 정의되어 있습니다. 특히, 윈도우에서 바이너리 모드로 파일을"
" 열려면 :const:`O_BINARY`\\를 추가해야 합니다."

#: ../Doc/library/os.rst:911
msgid ""
"This function can support :ref:`paths relative to directory descriptors "
"<dir_fd>` with the *dir_fd* parameter."
msgstr "이 함수는 *dir_fd* 매개 변수로 :ref:`디렉터리 기술자에 상대적인 경로 <dir_fd>`\\를 지원할 수 있습니다."

#: ../Doc/library/os.rst:919
msgid ""
"This function is intended for low-level I/O.  For normal usage, use the "
"built-in function :func:`open`, which returns a :term:`file object` with "
":meth:`~file.read` and :meth:`~file.write` methods (and many more).  To "
"wrap a file descriptor in a file object, use :func:`fdopen`."
msgstr ""
"이 함수는 저수준 I/O를 위한 것입니다. 일반적인 사용을 위해서는 내장 함수 :func:`open`\\을 사용하십시오, 이 함수는"
" :meth:`~file.read` 및 :meth:`~file.write` 메서드(와 더 많은 메서드)가있는 :term:`파일 객체"
" <file object>`\\를 반환합니다. 파일 기술자를 파일 객체로 싸려면, :func:`fdopen`\\을 사용하십시오."

#: ../Doc/library/os.rst:924 ../Doc/library/os.rst:1839
#: ../Doc/library/os.rst:1905 ../Doc/library/os.rst:1927
#: ../Doc/library/os.rst:2004 ../Doc/library/os.rst:2025
msgid "The *dir_fd* argument."
msgstr "*dir_fd* 인자"

#: ../Doc/library/os.rst:927 ../Doc/library/os.rst:1219
#: ../Doc/library/os.rst:1342 ../Doc/library/os.rst:3696
msgid ""
"If the system call is interrupted and the signal handler does not raise "
"an exception, the function now retries the system call instead of raising"
" an :exc:`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"시스템 호출이 인터럽트 되고 시그널 처리기가 예외를 발생시키지 않으면, 함수는 이제 :exc:`InterruptedError` "
"예외를 일으키는 대신 시스템 호출을 재시도합니다 (이유는 :pep:`475`\\를 참조하세요)."

#: ../Doc/library/os.rst:932 ../Doc/library/os.rst:1546
#: ../Doc/library/os.rst:1573 ../Doc/library/os.rst:1602
#: ../Doc/library/os.rst:1646 ../Doc/library/os.rst:1678
#: ../Doc/library/os.rst:1709 ../Doc/library/os.rst:1722
#: ../Doc/library/os.rst:1733 ../Doc/library/os.rst:1786
#: ../Doc/library/os.rst:1842 ../Doc/library/os.rst:1881
#: ../Doc/library/os.rst:1908 ../Doc/library/os.rst:1930
#: ../Doc/library/os.rst:1971 ../Doc/library/os.rst:2007
#: ../Doc/library/os.rst:2028 ../Doc/library/os.rst:2045
#: ../Doc/library/os.rst:2116 ../Doc/library/os.rst:2373
#: ../Doc/library/os.rst:2602 ../Doc/library/os.rst:2754
#: ../Doc/library/os.rst:2768 ../Doc/library/os.rst:2808
#: ../Doc/library/os.rst:2901 ../Doc/library/os.rst:2960
#: ../Doc/library/os.rst:2998 ../Doc/library/os.rst:3139
#: ../Doc/library/os.rst:3485
msgid "Accepts a :term:`path-like object`."
msgstr ":term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: ../Doc/library/os.rst:935
msgid ""
"The following constants are options for the *flags* parameter to the "
":func:`~os.open` function.  They can be combined using the bitwise OR "
"operator ``|``.  Some of them are not available on all platforms.  For "
"descriptions of their availability and use, consult the "
":manpage:`open(2)` manual page on Unix or `the MSDN "
"<https://msdn.microsoft.com/en-us/library/z0kc8e3z.aspx>`_ on Windows."
msgstr ""
"다음 상수는 :func:`~os.open` 함수에 대한 *flags* 매개 변수의 옵션입니다. 비트별 OR 연산자 ``|``\\를 "
"사용하여 결합할 수 있습니다. 일부는 모든 플랫폼에서 사용할 수는 없습니다. 가용성과 사용에 대한 설명은 유닉스의 "
":manpage:`open(2)` 매뉴얼 페이지 또는 윈도우의 `MSDN <https://msdn.microsoft.com/en-"
"us/library/z0kc8e3z.aspx>`_\\을 참조하십시오."

#: ../Doc/library/os.rst:950
msgid "The above constants are available on Unix and Windows."
msgstr "위의 상수는 유닉스 및 윈도우에서 사용할 수 있습니다."

#: ../Doc/library/os.rst:961
msgid "The above constants are only available on Unix."
msgstr "위의 상수는 유닉스에서만 사용할 수 있습니다."

#: ../Doc/library/os.rst:963
msgid "Add :data:`O_CLOEXEC` constant."
msgstr ":data:`O_CLOEXEC` 상수를 추가합니다."

#: ../Doc/library/os.rst:974
msgid "The above constants are only available on Windows."
msgstr "위의 상수는 윈도우에서만 사용할 수 있습니다."

#: ../Doc/library/os.rst:987
msgid ""
"The above constants are extensions and not present if they are not "
"defined by the C library."
msgstr "위의 상수는 확장이며 C 라이브러리에서 정의하지 않으면 존재하지 않습니다."

#: ../Doc/library/os.rst:990
msgid ""
"Add :data:`O_PATH` on systems that support it. Add :data:`O_TMPFILE`, "
"only available on Linux Kernel 3.11   or newer."
msgstr ""
"지원하는 시스템에 :data:`O_PATH`\\를 추가합니다. 리눅스 커널 3.11 이상에서만 사용 가능한 "
":data:`O_TMPFILE`\\를 추가합니다."

#: ../Doc/library/os.rst:1000
msgid ""
"Open a new pseudo-terminal pair. Return a pair of file descriptors "
"``(master, slave)`` for the pty and the tty, respectively. The new file "
"descriptors are :ref:`non-inheritable <fd_inheritance>`. For a (slightly)"
" more portable approach, use the :mod:`pty` module."
msgstr ""
"새로운 가상 터미널 쌍을 엽니다. 파일 기술자의 쌍 ``(master, slave)`` 를 반환하는데, 각각 pty와 tty "
"입니다. 새 파일 기술자는 :ref:`상속 불가능 <fd_inheritance>`\\합니다. (약간) 더 이식성 있는 접근 방식을 "
"사용하려면, :mod:`pty` 모듈을 사용하십시오."

#: ../Doc/library/os.rst:1006 ../Doc/library/os.rst:1032
#: ../Doc/library/os.rst:3312
msgid ":ref:`Availability <availability>`: some flavors of Unix."
msgstr ":ref:`가용성 <availability>`: 일부 유닉스."

#: ../Doc/library/os.rst:1007 ../Doc/library/os.rst:1019
msgid "The new file descriptors are now non-inheritable."
msgstr "새로운 파일 기술자는 이제 상속 불가능합니다."

#: ../Doc/library/os.rst:1013
msgid ""
"Create a pipe.  Return a pair of file descriptors ``(r, w)`` usable for "
"reading and writing, respectively. The new file descriptor is :ref:`non-"
"inheritable <fd_inheritance>`."
msgstr ""
"파이프를 만듭니다. 파일 기술자 쌍 ``(r, w)`` 를 반환하는데, 각각 읽기와 쓰기에 사용할 수 있습니다. 새 파일 기술자는 "
":ref:`상속 불가능 <fd_inheritance>`\\합니다."

#: ../Doc/library/os.rst:1025
msgid ""
"Create a pipe with *flags* set atomically. *flags* can be constructed by "
"ORing together one or more of these values: :data:`O_NONBLOCK`, "
":data:`O_CLOEXEC`. Return a pair of file descriptors ``(r, w)`` usable "
"for reading and writing, respectively."
msgstr ""
"*flags* 가 원자적으로 설정된 파이프를 만듭니다. *flags* 는 다음과 같은 값들을 하나 이상 OR 해서 만들 수 "
"있습니다: :data:`O_NONBLOCK`, :data:`O_CLOEXEC`. 파일 기술자 쌍 ``(r, w)`` 를 반환하는데,"
" 각각 읽기와 쓰기에 사용할 수 있습니다."

#: ../Doc/library/os.rst:1038
msgid ""
"Ensures that enough disk space is allocated for the file specified by "
"*fd* starting from *offset* and continuing for *len* bytes."
msgstr "*fd*\\로 지정된 파일이 *offset* 에서 시작하여 *len* 바이트 동안 계속되도록 충분한 디스크 공간을 할당합니다."

#: ../Doc/library/os.rst:1048
msgid ""
"Announces an intention to access data in a specific pattern thus allowing"
" the kernel to make optimizations. The advice applies to the region of "
"the file specified by *fd* starting at *offset* and continuing for *len* "
"bytes. *advice* is one of :data:`POSIX_FADV_NORMAL`, "
":data:`POSIX_FADV_SEQUENTIAL`, :data:`POSIX_FADV_RANDOM`, "
":data:`POSIX_FADV_NOREUSE`, :data:`POSIX_FADV_WILLNEED` or "
":data:`POSIX_FADV_DONTNEED`."
msgstr ""
"특정 패턴으로 데이터에 액세스하려는 의도를 알려 커널이 최적화할 수 있도록 합니다. 조언(advice)은 *fd에* 의해 지정된 "
"파일의 *offset* 에서 시작하여 *len* 바이트 동안 계속되는 영역에 적용됩니다. *advice*\\는 "
":data:`POSIX_FADV_NORMAL`, :data:`POSIX_FADV_SEQUENTIAL`, "
":data:`POSIX_FADV_RANDOM`, :data:`POSIX_FADV_NOREUSE`, "
":data:`POSIX_FADV_WILLNEED` 또는 :data:`POSIX_FADV_DONTNEED` 중 하나입니다."

#: ../Doc/library/os.rst:1068
msgid ""
"Flags that can be used in *advice* in :func:`posix_fadvise` that specify "
"the access pattern that is likely to be used."
msgstr ""
"사용 가능성이 큰 액세스 패턴을 지정하는 :func:`posix_fadvise`\\의 *advice* 에 사용될 수 있는 플래그."

#: ../Doc/library/os.rst:1078
msgid ""
"Read at most *n* bytes from file descriptor *fd* at a position of "
"*offset*, leaving the file offset unchanged."
msgstr ""
"파일 기술자 *fd*\\에서 *offset* 의 위치부터 최대 *n* 바이트를 읽어 들이고, 파일 오프셋은 변경되지 않은 채로 남겨"
" 둡니다."

#: ../Doc/library/os.rst:1081 ../Doc/library/os.rst:1208
msgid ""
"Return a bytestring containing the bytes read. If the end of the file "
"referred to by *fd* has been reached, an empty bytes object is returned."
msgstr ""
"읽어 들인 바이트를 포함하는 바이트열을 돌려줍니다. *fd* 에 의해 참조된 파일의 끝에 도달하면, 빈 바이트열 객체가 반환됩니다."

#: ../Doc/library/os.rst:1091
msgid ""
"Read from a file descriptor *fd* at a position of *offset* into mutable "
":term:`bytes-like objects <bytes-like object>` *buffers*, leaving the "
"file offset unchanged.  Transfer data into each buffer until it is full "
"and then move on to the next buffer in the sequence to hold the rest of "
"the data."
msgstr ""
"파일 기술자 *fd*\\에서 *offset* 위치부터 가변 :term:`바이트열류 객체들 <bytes-like object>` "
"*buffers* 로 읽어 들이고, 파일 오프셋은 변경되지 않은 채로 남겨 둡니다. 데이터가 가득 찰 때까지 각 버퍼로 데이터를 "
"전송한 다음 나머지 데이터를 보관하기 위해 시퀀스의 다음 버퍼로 이동합니다."

#: ../Doc/library/os.rst:1096 ../Doc/library/os.rst:1165
msgid ""
"The flags argument contains a bitwise OR of zero or more of the following"
" flags:"
msgstr "flags 인자는 다음 플래그 중 0개 이상의 비트별 OR를 포함합니다:"

#: ../Doc/library/os.rst:1099
msgid ":data:`RWF_HIPRI`"
msgstr ":data:`RWF_HIPRI`"

#: ../Doc/library/os.rst:1100
msgid ":data:`RWF_NOWAIT`"
msgstr ":data:`RWF_NOWAIT`"

#: ../Doc/library/os.rst:1102 ../Doc/library/os.rst:1292
msgid ""
"Return the total number of bytes actually read which can be less than the"
" total capacity of all the objects."
msgstr "실제로 읽힌 총 바이트 수를 반환합니다. 이 값은 모든 객체의 총 용량보다 작을 수 있습니다."

#: ../Doc/library/os.rst:1105 ../Doc/library/os.rst:1173
#: ../Doc/library/os.rst:1295 ../Doc/library/os.rst:1357
msgid ""
"The operating system may set a limit (:func:`sysconf` value "
"``'SC_IOV_MAX'``) on the number of buffers that can be used."
msgstr ""
"운영 체제는 사용할 수 있는 버퍼 수에 한계(:func:`sysconf` 값 ``'SC_IOV_MAX'``)를 설정할 수 있습니다."

#: ../Doc/library/os.rst:1108
msgid "Combine the functionality of :func:`os.readv` and :func:`os.pread`."
msgstr ":func:`os.readv` 와 :func:`os.pread`\\의 기능을 결합합니다."

#: ../Doc/library/os.rst:1112
msgid ""
":ref:`Availability <availability>`: Linux 2.6.30 and newer, FreeBSD 6.0 "
"and newer, OpenBSD 2.7 and newer. Using flags requires Linux 4.6 or "
"newer."
msgstr ""
":ref:`가용성 <availability>`: 리눅스 2.6.30 이상, FreeBSD 6.0 이상, OpenBSD 2.7 이상."
" flags를 사용하려면 리눅스 4.6 이상이 필요합니다."

#: ../Doc/library/os.rst:1118
msgid ""
"Do not wait for data which is not immediately available. If this flag is "
"specified, the system call will return instantly if it would have to read"
" data from the backing storage or wait for a lock."
msgstr ""
"즉시 사용할 수 없는 데이터를 기다리지 않습니다. 이 플래그를 지정하면, 하부 저장 장치에서 데이터를 읽어야 하거나 록을 기다려야 "
"할 때 즉시 시스템 호출이 반환됩니다."

#: ../Doc/library/os.rst:1122
msgid ""
"If some data was successfully read, it will return the number of bytes "
"read. If no bytes were read, it will return ``-1`` and set errno to "
":data:`errno.EAGAIN`."
msgstr ""
"일부 데이터가 성공적으로 읽히면, 읽은 바이트 수를 반환합니다. 읽은 바이트가 없으면, ``-1``\\을 반환하고 errno를 "
":data:`errno.EAGAIN`\\로 설정합니다."

#: ../Doc/library/os.rst:1127
msgid ":ref:`Availability <availability>`: Linux 4.14 and newer."
msgstr ":ref:`가용성 <availability>`: 리눅스 4.14 이상."

#: ../Doc/library/os.rst:1133
msgid ""
"High priority read/write. Allows block-based filesystems to use polling "
"of the device, which provides lower latency, but may use additional "
"resources."
msgstr ""
"우선순위가 높은 읽기/쓰기. 블록 기반 파일 시스템이 장치의 폴링을 사용할 수 있게 하여, 지연은 짧아 지지만, 추가 자원을 사용할"
" 수 있습니다."

#: ../Doc/library/os.rst:1137
msgid ""
"Currently, on Linux, this feature is usable only on a file descriptor "
"opened using the :data:`O_DIRECT` flag."
msgstr "현재, 리눅스에서, 이 기능은 :data:`O_DIRECT` 플래그를 사용하여 열린 파일 기술자에만 사용할 수 있습니다."

#: ../Doc/library/os.rst:1141
msgid ":ref:`Availability <availability>`: Linux 4.6 and newer."
msgstr ":ref:`가용성 <availability>`: 리눅스 4.6 이상."

#: ../Doc/library/os.rst:1147
msgid ""
"Write the bytestring in *str* to file descriptor *fd* at position of "
"*offset*, leaving the file offset unchanged."
msgstr "파일 기술자 *fd*\\의 *offset* 위치에 *str* 바이트열을 쓰고, 파일 오프셋은 변경되지 않은 채로 남겨 둡니다."

#: ../Doc/library/os.rst:1150 ../Doc/library/os.rst:1332
msgid "Return the number of bytes actually written."
msgstr "실제로 쓴 바이트 수를 반환합니다."

#: ../Doc/library/os.rst:1159
msgid ""
"Write the *buffers* contents to file descriptor *fd* at a offset "
"*offset*, leaving the file offset unchanged.  *buffers* must be a "
"sequence of :term:`bytes-like objects <bytes-like object>`. Buffers are "
"processed in array order. Entire contents of the first buffer is written "
"before proceeding to the second, and so on."
msgstr ""
"*buffers* 내용을 파일 기술자 *fd*\\의 오프셋 *offset* 에 쓰고, 파일 오프셋은 변경되지 않은 채로 남겨 "
"둡니다. *buffers* 는 :term:`바이트열류 객체 <bytes-like object>`\\의 시퀀스 여야 합니다. 버퍼는 "
"배열 순서로 처리됩니다. 첫 번째 버퍼의 전체 내용은 두 번째 버퍼로 진행하기 전에 기록되고, 같은 식으로 계속 진행합니다."

#: ../Doc/library/os.rst:1168
msgid ":data:`RWF_DSYNC`"
msgstr ":data:`RWF_DSYNC`"

#: ../Doc/library/os.rst:1169
msgid ":data:`RWF_SYNC`"
msgstr ":data:`RWF_SYNC`"

#: ../Doc/library/os.rst:1171
msgid "Return the total number of bytes actually written."
msgstr "실제로 쓴 총 바이트 수를 반환합니다."

#: ../Doc/library/os.rst:1176
msgid "Combine the functionality of :func:`os.writev` and :func:`os.pwrite`."
msgstr ":func:`os.writev` 와 :func:`os.pwrite`\\의 기능을 결합합니다."

#: ../Doc/library/os.rst:1180
msgid ""
":ref:`Availability <availability>`: Linux 2.6.30 and newer, FreeBSD 6.0 "
"and newer, OpenBSD 2.7 and newer. Using flags requires Linux 4.7 or "
"newer."
msgstr ""
":ref:`가용성 <availability>`: 리눅스 2.6.30 이상, FreeBSD 6.0 이상, OpenBSD 2.7 이상."
" flags를 사용하려면 리눅스 4.7 이상이 필요합니다."

#: ../Doc/library/os.rst:1186
msgid ""
"Provide a per-write equivalent of the :data:`O_DSYNC` ``open(2)`` flag. "
"This flag effect applies only to the data range written by the system "
"call."
msgstr ""
":data:`O_DSYNC` ``open(2)`` 플래그의 쓰기마다 지정할 수 있는 버전을 제공합니다. 이 플래그 효과는 시스템 "
"호출로 기록된 데이터 범위에만 적용됩니다."

#: ../Doc/library/os.rst:1190 ../Doc/library/os.rst:1200
msgid ":ref:`Availability <availability>`: Linux 4.7 and newer."
msgstr ":ref:`가용성 <availability>`: 리눅스 4.7 이상."

#: ../Doc/library/os.rst:1196
msgid ""
"Provide a per-write equivalent of the :data:`O_SYNC` ``open(2)`` flag. "
"This flag effect applies only to the data range written by the system "
"call."
msgstr ""
":data:`O_SYNC` ``open(2)`` 플래그의 쓰기마다 지정할 수 있는 버전을 제공합니다. 이 플래그 효과는 시스템 "
"호출로 기록된 데이터 범위에만 적용됩니다."

#: ../Doc/library/os.rst:1206
msgid "Read at most *n* bytes from file descriptor *fd*."
msgstr "파일 기술자 *fd*\\에서 최대 *n* 바이트를 읽습니다."

#: ../Doc/library/os.rst:1213
msgid ""
"This function is intended for low-level I/O and must be applied to a file"
" descriptor as returned by :func:`os.open` or :func:`pipe`.  To read a "
"\"file object\" returned by the built-in function :func:`open` or by "
":func:`popen` or :func:`fdopen`, or :data:`sys.stdin`, use its "
":meth:`~file.read` or :meth:`~file.readline` methods."
msgstr ""
"이 함수는 저수준 I/O를 위한 것이며 :func:`os.open` 이나 :func:`pipe`\\에 의해 반환된 파일 기술자에 "
"적용되어야 합니다. 내장 함수 :func:`open` 이나 :func:`popen` 또는 :func:`fdopen`\\에 의해 "
"반환된 \"파일 객체\"나 :data:`sys.stdin`\\을 읽으려면, 그것의 :meth:`~file.read` 나 "
":meth:`~file.readline` 메서드를 사용하십시오."

#: ../Doc/library/os.rst:1228
msgid ""
"Copy *count* bytes from file descriptor *in* to file descriptor *out* "
"starting at *offset*. Return the number of bytes sent. When EOF is "
"reached return 0."
msgstr ""
"파일 기술자 *in*\\에서 파일 기술자 *out* 으로 *offset*\\에서 시작하여 *count* 바이트를 복사합니다. 전송된"
" 바이트 수를 반환합니다. EOF에 도달하면 0을 반환합니다."

#: ../Doc/library/os.rst:1232
msgid ""
"The first function notation is supported by all platforms that define "
":func:`sendfile`."
msgstr "첫 번째 함수 서명은 :func:`sendfile`\\를 정의하는 모든 플랫폼에서 지원됩니다."

#: ../Doc/library/os.rst:1235
msgid ""
"On Linux, if *offset* is given as ``None``, the bytes are read from the "
"current position of *in* and the position of *in* is updated."
msgstr ""
"리눅스에서, *offset*\\이 ``None``\\으로 주어지면, *in*\\의 현재 위치에서 바이트를 읽고 *in*\\의 위치가"
" 갱신됩니다."

#: ../Doc/library/os.rst:1238
msgid ""
"The second case may be used on Mac OS X and FreeBSD where *headers* and "
"*trailers* are arbitrary sequences of buffers that are written before and"
" after the data from *in* is written. It returns the same as the first "
"case."
msgstr ""
"두 번째 경우는 맥 OS X와 FreeBSD 에 사용될 수 있는데, *headers* 와 *trailers* 는 *in* 의 "
"데이터가 기록되는 전후에 기록되는 버퍼의 임의의 시퀀스입니다. 첫 번째 경우와 같은 결과를 반환합니다."

#: ../Doc/library/os.rst:1242
msgid ""
"On Mac OS X and FreeBSD, a value of 0 for *count* specifies to send until"
" the end of *in* is reached."
msgstr "맥 OS X 및 FreeBSD 에서, *count* 의 값 0은 *in* 의 끝에 도달할 때까지 보내도록 지정합니다."

#: ../Doc/library/os.rst:1245
msgid ""
"All platforms support sockets as *out* file descriptor, and some "
"platforms allow other types (e.g. regular file, pipe) as well."
msgstr ""
"모든 플랫폼은 *out* 파일 기술자로 소켓을 지원하고, 일부 플랫폼은 다른 유형(예를 들어 일반 파일, 파이프)들도 허락합니다."

#: ../Doc/library/os.rst:1248
msgid ""
"Cross-platform applications should not use *headers*, *trailers* and "
"*flags* arguments."
msgstr "이기종 플랫폼 응용 프로그램은 *headers*, *trailers* 및 *flags* 인자를 사용해서는 안 됩니다."

#: ../Doc/library/os.rst:1255
msgid ""
"For a higher-level wrapper of :func:`sendfile`, see "
":meth:`socket.socket.sendfile`."
msgstr ":func:`sendfile`\\의 고수준 래퍼는, :meth:`socket.socket.sendfile`\\을 보십시오."

#: ../Doc/library/os.rst:1263
msgid ""
"Set the blocking mode of the specified file descriptor. Set the "
":data:`O_NONBLOCK` flag if blocking is ``False``, clear the flag "
"otherwise."
msgstr ""
"지정된 파일 기술자의 블로킹 모드를 설정합니다. blocking이 ``False``\\면 :data:`O_NONBLOCK` 플래그를"
" 설정하고, 그렇지 않으면 플래그를 지웁니다."

#: ../Doc/library/os.rst:1266
msgid "See also :func:`get_blocking` and :meth:`socket.socket.setblocking`."
msgstr ":func:`get_blocking`\\과 :meth:`socket.socket.setblocking`\\도 참조하십시오."

#: ../Doc/library/os.rst:1277
msgid ""
"Parameters to the :func:`sendfile` function, if the implementation "
"supports them."
msgstr "구현이 지원하는 경우, :func:`sendfile` 함수에 대한 매개 변수입니다."

#: ../Doc/library/os.rst:1287
msgid ""
"Read from a file descriptor *fd* into a number of mutable :term:`bytes-"
"like objects <bytes-like object>` *buffers*. Transfer data into each "
"buffer until it is full and then move on to the next buffer in the "
"sequence to hold the rest of the data."
msgstr ""
"파일 기술자 *fd*\\에서 여러 가변 :term:`바이트열류 객체 <bytes-like object>` *buffers*\\로 "
"읽어 들입니다. 데이터가 가득 찰 때까지 각 버퍼로 데이터를 전송한 다음 나머지 데이터를 보관하기 위해 시퀀스의 다음 버퍼로 "
"이동합니다."

#: ../Doc/library/os.rst:1305
msgid ""
"Return the process group associated with the terminal given by *fd* (an "
"open file descriptor as returned by :func:`os.open`)."
msgstr ""
"*fd*\\(:func:`os.open`\\에 의해 반환된 것과 같은 열린 파일 기술자)에 의해 주어진 터미널과 관련된 프로세스 "
"그룹을 반환합니다."

#: ../Doc/library/os.rst:1313
msgid ""
"Set the process group associated with the terminal given by *fd* (an open"
" file descriptor as returned by :func:`os.open`) to *pg*."
msgstr ""
"*fd*\\(:func:`os.open`\\에 의해 반환된 것과 같은 열린 파일 기술자)에 의해 주어진 터미널과 관련된 프로세스 "
"그룹을 *pg*\\로 설정합니다."

#: ../Doc/library/os.rst:1321
msgid ""
"Return a string which specifies the terminal device associated with file "
"descriptor *fd*.  If *fd* is not associated with a terminal device, an "
"exception is raised."
msgstr ""
"파일 기술자 *fd*\\와 관련된 터미널 장치를 나타내는 문자열을 돌려줍니다. *fd* 가 터미널 장치와 연관되어 있지 않으면, "
"예외가 발생합니다."

#: ../Doc/library/os.rst:1330
msgid "Write the bytestring in *str* to file descriptor *fd*."
msgstr "*str* 바이트열을 파일 기술자 *fd* 에 씁니다."

#: ../Doc/library/os.rst:1336
msgid ""
"This function is intended for low-level I/O and must be applied to a file"
" descriptor as returned by :func:`os.open` or :func:`pipe`.  To write a "
"\"file object\" returned by the built-in function :func:`open` or by "
":func:`popen` or :func:`fdopen`, or :data:`sys.stdout` or "
":data:`sys.stderr`, use its :meth:`~file.write` method."
msgstr ""
"이 함수는 저수준 I/O를 위한 것이며 :func:`os.open` 이나 :func:`pipe`\\에 의해 반환된 파일 기술자에 "
"적용되어야 합니다. 내장 함수 :func:`open` 이나 :func:`popen` 또는 :func:`fdopen`\\에 의해 "
"반환된 \"파일 객체\"나 :data:`sys.stdout` 또는 :data:`sys.stderr`\\에 쓰려면, 그것의 "
":meth:`~file.write` 메서드를 사용하십시오."

#: ../Doc/library/os.rst:1350
msgid ""
"Write the contents of *buffers* to file descriptor *fd*. *buffers* must "
"be a sequence of :term:`bytes-like objects <bytes-like object>`. Buffers "
"are processed in array order. Entire contents of the first buffer is "
"written before proceeding to the second, and so on."
msgstr ""
"*buffers* 내용을 파일 기술자 *fd*\\에 씁니다. *buffers* 는 :term:`바이트열류 객체 <bytes-like"
" object>`\\의 시퀀스 여야 합니다. 버퍼는 배열 순서로 처리됩니다. 첫 번째 버퍼의 전체 내용은 두 번째 버퍼로 진행하기 "
"전에 기록되고, 같은 식으로 계속 진행합니다."

#: ../Doc/library/os.rst:1355
msgid "Returns the total number of bytes actually written."
msgstr "실제로 쓴 총 바이트 수를 반환합니다."

#: ../Doc/library/os.rst:1368
msgid "Querying the size of a terminal"
msgstr "터미널의 크기 조회하기"

#: ../Doc/library/os.rst:1374
msgid ""
"Return the size of the terminal window as ``(columns, lines)``, tuple of "
"type :class:`terminal_size`."
msgstr ""
"터미널 창의 크기를 ``(columns, lines)`` 로 반환하는데, :class:`terminal_size` 형의 튜플입니다."

#: ../Doc/library/os.rst:1377
msgid ""
"The optional argument ``fd`` (default ``STDOUT_FILENO``, or standard "
"output) specifies which file descriptor should be queried."
msgstr "선택적 인자 ``fd``\\(기본값 ``STDOUT_FILENO``, 즉 표준 출력)는 조회할 파일 기술자를 지정합니다."

#: ../Doc/library/os.rst:1380
msgid ""
"If the file descriptor is not connected to a terminal, an :exc:`OSError` "
"is raised."
msgstr "파일 기술자가 터미널에 연결되어 있지 않으면, :exc:`OSError`\\가 발생합니다."

#: ../Doc/library/os.rst:1383
msgid ""
":func:`shutil.get_terminal_size` is the high-level function which should "
"normally be used, ``os.get_terminal_size`` is the low-level "
"implementation."
msgstr ""
":func:`shutil.get_terminal_size`\\가 일반적으로 사용해야 하는 고수준 함수이며, "
"``os.get_terminal_size``\\는 저수준 구현입니다."

#: ../Doc/library/os.rst:1391
msgid ""
"A subclass of tuple, holding ``(columns, lines)`` of the terminal window "
"size."
msgstr "터미널 창 크기 ``(columns, lines)``\\를 저장하는 튜플의 서브 클래스."

#: ../Doc/library/os.rst:1395
msgid "Width of the terminal window in characters."
msgstr "문자 단위의 터미널 창의 너비."

#: ../Doc/library/os.rst:1399
msgid "Height of the terminal window in characters."
msgstr "문자 단위의 터미널 창의 높이."

#: ../Doc/library/os.rst:1405
msgid "Inheritance of File Descriptors"
msgstr "파일 기술자의 상속"

#: ../Doc/library/os.rst:1409
msgid ""
"A file descriptor has an \"inheritable\" flag which indicates if the file"
" descriptor can be inherited by child processes.  Since Python 3.4, file "
"descriptors created by Python are non-inheritable by default."
msgstr ""
"파일 기술자는 자식 프로세스가 파일 기술자를 상속받을 수 있는지를 나타내는 \"상속 가능\" 플래그를 가지고 있습니다. 파이썬 "
"3.4부터, 파이썬에 의해 생성된 파일 기술자는 기본적으로 상속 불가능합니다."

#: ../Doc/library/os.rst:1413
msgid ""
"On UNIX, non-inheritable file descriptors are closed in child processes "
"at the execution of a new program, other file descriptors are inherited."
msgstr "유닉스에서는, 상속 불가능한 파일 기술자는 새 프로그램 실행 시 자식 프로세스에서 닫히고, 다른 파일 기술자는 상속됩니다."

#: ../Doc/library/os.rst:1416
msgid ""
"On Windows, non-inheritable handles and file descriptors are closed in "
"child processes, except for standard streams (file descriptors 0, 1 and "
"2: stdin, stdout and stderr), which are always inherited.  Using "
":func:`spawn\\* <spawnl>` functions, all inheritable handles and all "
"inheritable file descriptors are inherited. Using the :mod:`subprocess` "
"module, all file descriptors except standard streams are closed, and "
"inheritable handles are only inherited if the *close_fds* parameter is "
"``False``."
msgstr ""
"윈도우에서는, 항상 상속되는 표준 스트림(파일 기술자 0, 1, 2: stdin, stdout, stderr)을 제외하고, 상속 "
"불가능한 핸들 및 파일 기술자는 자식 프로세스에서 닫힙니다. :func:`spawn\\* <spawnl>` 함수를 사용하면, 상속 "
"가능한 모든 핸들과 상속 가능한 모든 파일 기술자가 상속됩니다. :mod:`subprocess` 모듈을 사용하면, 표준 스트림을 "
"제외한 모든 파일 기술자가 닫히고, 상속 가능한 핸들은 *close_fds* 매개 변수가 ``False`` 일 때만 상속됩니다."

#: ../Doc/library/os.rst:1426
msgid "Get the \"inheritable\" flag of the specified file descriptor (a boolean)."
msgstr "지정된 파일 기술자의 \"상속 가능\" 플래그를 가져옵니다 (논릿값)."

#: ../Doc/library/os.rst:1430
msgid "Set the \"inheritable\" flag of the specified file descriptor."
msgstr "지정된 파일 기술자의 \"상속 가능(inheritable)\" 플래그를 설정합니다."

#: ../Doc/library/os.rst:1434
msgid "Get the \"inheritable\" flag of the specified handle (a boolean)."
msgstr "지정된 핸들의 \"상속 가능\" 플래그를 가져옵니다 (논릿값)."

#: ../Doc/library/os.rst:1436 ../Doc/library/os.rst:1442
#: ../Doc/library/os.rst:3520 ../Doc/library/os.rst:3549
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`가용성 <availability>`: 윈도우."

#: ../Doc/library/os.rst:1440
msgid "Set the \"inheritable\" flag of the specified handle."
msgstr "지정된 핸들의 \"상속 가능(inheritable)\" 플래그를 설정합니다."

#: ../Doc/library/os.rst:1448
msgid "Files and Directories"
msgstr "파일과 디렉터리"

#: ../Doc/library/os.rst:1450
msgid ""
"On some Unix platforms, many of these functions support one or more of "
"these features:"
msgstr "일부 유닉스 플랫폼에서, 이 함수 중 많은 것들이 다음 기능 중 하나 이상을 지원합니다:"

#: ../Doc/library/os.rst:1455
msgid ""
"**specifying a file descriptor:** For some functions, the *path* argument"
" can be not only a string giving a path name, but also a file descriptor."
"  The function will then operate on the file referred to by the "
"descriptor.  (For POSIX systems, Python will call the ``f...`` version of"
" the function.)"
msgstr ""
"**파일 기술자 지정:** 일부 함수의 경우, *path* 인자는 경로명을 제공하는 문자열뿐만 아니라 파일 기술자일 수도 있습니다."
" 그러면 그 함수는 기술자가 참조하는 파일에서 작동합니다. (POSIX 시스템에서, 파이썬은 함수의 ``f...`` 버전을 "
"호출합니다.)"

#: ../Doc/library/os.rst:1461
msgid ""
"You can check whether or not *path* can be specified as a file descriptor"
" on your platform using :data:`os.supports_fd`.  If it is unavailable, "
"using it will raise a :exc:`NotImplementedError`."
msgstr ""
":data:`os.supports_fd`\\를 사용하여, 플랫폼에서 파일 기술자로 *path*\\를 지정할 수 있는지를 확인할 수 "
"있습니다. 사용할 수 없을 때, 사용하면 :exc:`NotImplementedError`\\를 발생시킵니다."

#: ../Doc/library/os.rst:1465
msgid ""
"If the function also supports *dir_fd* or *follow_symlinks* arguments, it"
" is an error to specify one of those when supplying *path* as a file "
"descriptor."
msgstr ""
"함수가 *dir_fd* 나 *follow_symlinks* 인자도 지원하면, *path* 에 파일 기술자를 제공할 때, 이 중 "
"하나를 지정하는 것은 에러입니다."

#: ../Doc/library/os.rst:1470
msgid ""
"**paths relative to directory descriptors:** If *dir_fd* is not ``None``,"
" it should be a file descriptor referring to a directory, and the path to"
" operate on should be relative; path will then be relative to that "
"directory.  If the path is absolute, *dir_fd* is ignored.  (For POSIX "
"systems, Python will call the ``...at`` or ``f...at`` version of the "
"function.)"
msgstr ""
"**디렉터리 기술자에 상대적인 경로:** *dir_fd* 가 ``None``\\이 아니면, 디렉터리를 가리키는 파일 기술자여야 "
"하며, 대상 경로는 상대 경로여야 합니다; 그러면 경로는 그 디렉터리에 상대적입니다. 절대 경로이면, *dir_fd* 는 "
"무시됩니다. (POSIX 시스템에서, 파이썬은 함수의 ``...at`` 또는 ``f...at`` 버전을 호출합니다.)"

#: ../Doc/library/os.rst:1476
msgid ""
"You can check whether or not *dir_fd* is supported on your platform using"
" :data:`os.supports_dir_fd`.  If it is unavailable, using it will raise a"
" :exc:`NotImplementedError`."
msgstr ""
":data:`os.supports_dir_fd`\\를 사용하여, 플랫폼에서 *dir_fd*\\가 지원되는지를 확인할 수 있습니다. "
"사용할 수 없을 때, 사용하면 :exc:`NotImplementedError`\\를 발생시킵니다."

#: ../Doc/library/os.rst:1482
msgid ""
"**not following symlinks:** If *follow_symlinks* is ``False``, and the "
"last element of the path to operate on is a symbolic link, the function "
"will operate on the symbolic link itself instead of the file the link "
"points to.  (For POSIX systems, Python will call the ``l...`` version of "
"the function.)"
msgstr ""
"**심볼릭 링크를 따르지 않음:** *follow_symlinks* 가 ``False``\\고, 대상 경로의 마지막 요소가 심볼릭 "
"링크면, 함수는 링크가 가리키는 파일 대신 심볼릭 링크 자체에 대해 작동합니다. (POSIX 시스템에서, 파이썬은 함수의 "
"``l...`` 버전을 호출합니다.)"

#: ../Doc/library/os.rst:1488
msgid ""
"You can check whether or not *follow_symlinks* is supported on your "
"platform using :data:`os.supports_follow_symlinks`.  If it is "
"unavailable, using it will raise a :exc:`NotImplementedError`."
msgstr ""
":data:`os.supports_follow_symlinks`\\를 사용하여, 플랫폼에서 *follow_symlinks*\\가 "
"지원되는지를 확인할 수 있습니다. 사용할 수 없을 때, 사용하면 :exc:`NotImplementedError`\\를 발생시킵니다."

#: ../Doc/library/os.rst:1496
msgid ""
"Use the real uid/gid to test for access to *path*.  Note that most "
"operations will use the effective uid/gid, therefore this routine can be "
"used in a suid/sgid environment to test if the invoking user has the "
"specified access to *path*.  *mode* should be :const:`F_OK` to test the "
"existence of *path*, or it can be the inclusive OR of one or more of "
":const:`R_OK`, :const:`W_OK`, and :const:`X_OK` to test permissions.  "
"Return :const:`True` if access is allowed, :const:`False` if not. See the"
" Unix man page :manpage:`access(2)` for more information."
msgstr ""
"실제(real) uid/gid를 사용해서 *path*\\를 액세스할 수 있는지 검사합니다. 대부분의 연산은 "
"유효한(effective) uid/gid를 사용할 것이므로, 이 함수는 suid/sgid 환경에서 호출하는 사용자가 지정된 "
"*path* 에 대한 액세스 권한이 있는지 검사하는데 사용할 수 있습니다. *path*\\가 존재하는지를 검사하려면 *mode* 는"
" :const:`F_OK` 여야 하며, 권한을 검사하려면 하나 이상의 :const:`R_OK`, :const:`W_OK` 및 "
":const:`X_OK`\\를 OR 값일 수 있습니다. 액세스가 허용되면 :const:`True`\\를 반환하고, 그렇지 않으면 "
":const:`False`\\를 반환합니다. 더 자세한 정보는 유닉스 매뉴얼 페이지 :manpage:`access(2)`\\를 "
"참조하십시오."

#: ../Doc/library/os.rst:1505
msgid ""
"This function can support specifying :ref:`paths relative to directory "
"descriptors <dir_fd>` and :ref:`not following symlinks "
"<follow_symlinks>`."
msgstr ""
"이 함수는 :ref:`디렉터리 기술자에 상대적인 경로 <dir_fd>` 와 :ref:`심볼릭 링크를 따르지 않음 "
"<follow_symlinks>`\\을 지원할 수 있습니다."

#: ../Doc/library/os.rst:1508
msgid ""
"If *effective_ids* is ``True``, :func:`access` will perform its access "
"checks using the effective uid/gid instead of the real uid/gid. "
"*effective_ids* may not be supported on your platform; you can check "
"whether or not it is available using :data:`os.supports_effective_ids`.  "
"If it is unavailable, using it will raise a :exc:`NotImplementedError`."
msgstr ""
"*effective_ids* 가 ``True``\\면, :func:`access`\\는 실제(real) uid/gid 대신 "
"유효한(effective) uid/gid를 사용하여 액세스 검사를 수행합니다. *effective_ids* 는 플랫폼에서 지원되지 "
"않을 수 있습니다; :data:`os.supports_effective_ids`\\를 사용하여, 사용할 수 있는지를 확인할 수 "
"있습니다. 사용할 수 없을 때, 사용하면 :exc:`NotImplementedError`\\를 발생시킵니다."

#: ../Doc/library/os.rst:1516
msgid ""
"Using :func:`access` to check if a user is authorized to e.g. open a file"
" before actually doing so using :func:`open` creates a security hole, "
"because the user might exploit the short time interval between checking "
"and opening the file to manipulate it. It's preferable to use "
":term:`EAFP` techniques. For example::"
msgstr ""
"예를 들어, 실제로 :func:`open`\\를 사용하여 파일을 열기 전에, :func:`access`\\를 사용하여 파일을 여는 "
"권한이 있는지 확인하는 것은 보안 구멍을 만듭니다. 사용자가 파일을 확인하고 조작을 위해 열기 사이의 짧은 시간 간격을 악용할 수 "
"있기 때문입니다. :term:`EAFP` 기법을 사용하는 것이 좋습니다. 예를 들면::"

#: ../Doc/library/os.rst:1527
msgid "is better written as::"
msgstr "는 다음과 같이 쓰는 것이 더 좋습니다::"

#: ../Doc/library/os.rst:1539
msgid ""
"I/O operations may fail even when :func:`access` indicates that they "
"would succeed, particularly for operations on network filesystems which "
"may have permissions semantics beyond the usual POSIX permission-bit "
"model."
msgstr ""
":func:`access`\\가 성공할 것임을 알릴 때도, I/O 연산이 실패할 수 있습니다. 특히 일반적인 POSIX 권한 비트 "
"모델을 넘어서는 권한 의미가 있을 수 있는 네트워크 파일 시스템에 대한 연산에서 그럴 수 있습니다."

#: ../Doc/library/os.rst:1543
msgid "Added the *dir_fd*, *effective_ids*, and *follow_symlinks* parameters."
msgstr "*dir_fd*, *effective_ids* 및 *follow_symlinks* 매개 변수를 추가했습니다."

#: ../Doc/library/os.rst:1555
msgid ""
"Values to pass as the *mode* parameter of :func:`access` to test the "
"existence, readability, writability and executability of *path*, "
"respectively."
msgstr ""
"*path* 의 존재 여부, 읽기 가능성, 쓰기 가능성 및 실행 가능성을 검사하기 위해, :func:`access`\\의 "
"*mode* 매개 변수로 전달할 값입니다."

#: ../Doc/library/os.rst:1564
msgid "Change the current working directory to *path*."
msgstr "현재 작업 디렉터리를 *path*\\로 변경합니다."

#: ../Doc/library/os.rst:1566
msgid ""
"This function can support :ref:`specifying a file descriptor <path_fd>`."
"  The descriptor must refer to an opened directory, not an open file."
msgstr ""
"이 함수는 :ref:`파일 기술자 지정 <path_fd>`\\을 지원할 수 있습니다. 기술자는 열려있는 파일이 아니라, 열려있는 "
"디렉터리를 참조해야 합니다."

#: ../Doc/library/os.rst:1569
msgid ""
"Added support for specifying *path* as a file descriptor on some "
"platforms."
msgstr "일부 플랫폼에서 *path* 를 파일 기술자로 지정하는 지원이 추가되었습니다."

#: ../Doc/library/os.rst:1579
msgid ""
"Set the flags of *path* to the numeric *flags*. *flags* may take a "
"combination (bitwise OR) of the following values (as defined in the "
":mod:`stat` module):"
msgstr ""
"*path* 의 플래그를 숫자 *flags*\\로 설정합니다. *flags*\\는 다음 값들(:mod:`stat` 모듈에 정의된 "
"대로)의 조합(비트별 OR)을 취할 수 있습니다:"

#: ../Doc/library/os.rst:1582
msgid ":data:`stat.UF_NODUMP`"
msgstr ":data:`stat.UF_NODUMP`"

#: ../Doc/library/os.rst:1583
msgid ":data:`stat.UF_IMMUTABLE`"
msgstr ":data:`stat.UF_IMMUTABLE`"

#: ../Doc/library/os.rst:1584
msgid ":data:`stat.UF_APPEND`"
msgstr ":data:`stat.UF_APPEND`"

#: ../Doc/library/os.rst:1585
msgid ":data:`stat.UF_OPAQUE`"
msgstr ":data:`stat.UF_OPAQUE`"

#: ../Doc/library/os.rst:1586
msgid ":data:`stat.UF_NOUNLINK`"
msgstr ":data:`stat.UF_NOUNLINK`"

#: ../Doc/library/os.rst:1587
msgid ":data:`stat.UF_COMPRESSED`"
msgstr ":data:`stat.UF_COMPRESSED`"

#: ../Doc/library/os.rst:1588
msgid ":data:`stat.UF_HIDDEN`"
msgstr ":data:`stat.UF_HIDDEN`"

#: ../Doc/library/os.rst:1589
msgid ":data:`stat.SF_ARCHIVED`"
msgstr ":data:`stat.SF_ARCHIVED`"

#: ../Doc/library/os.rst:1590
msgid ":data:`stat.SF_IMMUTABLE`"
msgstr ":data:`stat.SF_IMMUTABLE`"

#: ../Doc/library/os.rst:1591
msgid ":data:`stat.SF_APPEND`"
msgstr ":data:`stat.SF_APPEND`"

#: ../Doc/library/os.rst:1592
msgid ":data:`stat.SF_NOUNLINK`"
msgstr ":data:`stat.SF_NOUNLINK`"

#: ../Doc/library/os.rst:1593
msgid ":data:`stat.SF_SNAPSHOT`"
msgstr ":data:`stat.SF_SNAPSHOT`"

#: ../Doc/library/os.rst:1595
msgid "This function can support :ref:`not following symlinks <follow_symlinks>`."
msgstr "이 함수는 :ref:`심볼릭 링크를 따르지 않음 <follow_symlinks>`\\을 지원할 수 있습니다."

#: ../Doc/library/os.rst:1599
msgid "The *follow_symlinks* argument."
msgstr "*follow_symlinks* 인자."

#: ../Doc/library/os.rst:1608
msgid ""
"Change the mode of *path* to the numeric *mode*. *mode* may take one of "
"the following values (as defined in the :mod:`stat` module) or bitwise "
"ORed combinations of them:"
msgstr ""
"*path*\\의 모드를 숫자 *mode*\\로 변경합니다. *mode* 는 다음 값들(:mod:`stat` 모듈에 정의된 "
"대로)이나 이들의 비트별 OR 조합을 취할 수 있습니다:"

#: ../Doc/library/os.rst:1612
msgid ":data:`stat.S_ISUID`"
msgstr ":data:`stat.S_ISUID`"

#: ../Doc/library/os.rst:1613
msgid ":data:`stat.S_ISGID`"
msgstr ":data:`stat.S_ISGID`"

#: ../Doc/library/os.rst:1614
msgid ":data:`stat.S_ENFMT`"
msgstr ":data:`stat.S_ENFMT`"

#: ../Doc/library/os.rst:1615
msgid ":data:`stat.S_ISVTX`"
msgstr ":data:`stat.S_ISVTX`"

#: ../Doc/library/os.rst:1616
msgid ":data:`stat.S_IREAD`"
msgstr ":data:`stat.S_IREAD`"

#: ../Doc/library/os.rst:1617
msgid ":data:`stat.S_IWRITE`"
msgstr ":data:`stat.S_IWRITE`"

#: ../Doc/library/os.rst:1618
msgid ":data:`stat.S_IEXEC`"
msgstr ":data:`stat.S_IEXEC`"

#: ../Doc/library/os.rst:1619
msgid ":data:`stat.S_IRWXU`"
msgstr ":data:`stat.S_IRWXU`"

#: ../Doc/library/os.rst:1620
msgid ":data:`stat.S_IRUSR`"
msgstr ":data:`stat.S_IRUSR`"

#: ../Doc/library/os.rst:1621
msgid ":data:`stat.S_IWUSR`"
msgstr ":data:`stat.S_IWUSR`"

#: ../Doc/library/os.rst:1622
msgid ":data:`stat.S_IXUSR`"
msgstr ":data:`stat.S_IXUSR`"

#: ../Doc/library/os.rst:1623
msgid ":data:`stat.S_IRWXG`"
msgstr ":data:`stat.S_IRWXG`"

#: ../Doc/library/os.rst:1624
msgid ":data:`stat.S_IRGRP`"
msgstr ":data:`stat.S_IRGRP`"

#: ../Doc/library/os.rst:1625
msgid ":data:`stat.S_IWGRP`"
msgstr ":data:`stat.S_IWGRP`"

#: ../Doc/library/os.rst:1626
msgid ":data:`stat.S_IXGRP`"
msgstr ":data:`stat.S_IXGRP`"

#: ../Doc/library/os.rst:1627
msgid ":data:`stat.S_IRWXO`"
msgstr ":data:`stat.S_IRWXO`"

#: ../Doc/library/os.rst:1628
msgid ":data:`stat.S_IROTH`"
msgstr ":data:`stat.S_IROTH`"

#: ../Doc/library/os.rst:1629
msgid ":data:`stat.S_IWOTH`"
msgstr ":data:`stat.S_IWOTH`"

#: ../Doc/library/os.rst:1630
msgid ":data:`stat.S_IXOTH`"
msgstr ":data:`stat.S_IXOTH`"

#: ../Doc/library/os.rst:1632 ../Doc/library/os.rst:1655
#: ../Doc/library/os.rst:2800
msgid ""
"This function can support :ref:`specifying a file descriptor <path_fd>`, "
":ref:`paths relative to directory descriptors <dir_fd>` and :ref:`not "
"following symlinks <follow_symlinks>`."
msgstr ""
"이 함수는 :ref:`파일 기술자 지정 <path_fd>`, :ref:`디렉터리 기술자에 상대적인 경로 <dir_fd>` 및 "
":ref:`심볼릭 링크를 따르지 않음 <follow_symlinks>`\\을 지원할 수 있습니다."

#: ../Doc/library/os.rst:1638
msgid ""
"Although Windows supports :func:`chmod`, you can only set the file's "
"read-only flag with it (via the ``stat.S_IWRITE`` and ``stat.S_IREAD`` "
"constants or a corresponding integer value).  All other bits are ignored."
msgstr ""
"윈도우가 :func:`chmod`\\를 지원하더라도, (``stat.S_IWRITE`` 와 ``stat.S_IREAD`` 상수나 "
"해당 정숫값을 통해) 파일의 읽기 전용 플래그만 설정할 수 있습니다. 다른 모든 비트는 무시됩니다."

#: ../Doc/library/os.rst:1642
msgid ""
"Added support for specifying *path* as an open file descriptor, and the "
"*dir_fd* and *follow_symlinks* arguments."
msgstr "*path*\\를 열린 파일 기술자로 지정하는 지원과 *dir_fd* 및 *follow_symlinks* 인자가 추가되었습니다."

#: ../Doc/library/os.rst:1652
msgid ""
"Change the owner and group id of *path* to the numeric *uid* and *gid*.  "
"To leave one of the ids unchanged, set it to -1."
msgstr ""
"*path* 의 소유자와 그룹 ID를 숫자 *uid* 와 *gid*\\로 변경합니다. ID 중 하나를 변경하지 않으려면, 그것을 "
"-1로 설정하십시오."

#: ../Doc/library/os.rst:1659
msgid ""
"See :func:`shutil.chown` for a higher-level function that accepts names "
"in addition to numeric ids."
msgstr "숫자 ID 이외에 이름을 허용하는 고수준 함수는 :func:`shutil.chown`\\를 참조하십시오."

#: ../Doc/library/os.rst:1664
msgid ""
"Added support for specifying an open file descriptor for *path*, and the "
"*dir_fd* and *follow_symlinks* arguments."
msgstr ""
"*path* 에 열린 파일 기술자를 지정하는 것과 *dir_fd* 및 *follow_symlinks* 인자에 대한 지원이 "
"추가되었습니다."

#: ../Doc/library/os.rst:1668
msgid "Supports a :term:`path-like object`."
msgstr ":term:`경로류 객체 <path-like object>`\\를 지원합니다."

#: ../Doc/library/os.rst:1674
msgid "Change the root directory of the current process to *path*."
msgstr "현재 프로세스의 루트 디렉터리를 *path*\\로 변경합니다."

#: ../Doc/library/os.rst:1684
msgid ""
"Change the current working directory to the directory represented by the "
"file descriptor *fd*.  The descriptor must refer to an opened directory, "
"not an open file.  As of Python 3.3, this is equivalent to "
"``os.chdir(fd)``."
msgstr ""
"현재 작업 디렉터리를 파일 기술자 *fd*\\가 나타내는 디렉터리로 변경합니다. 기술자는 열려있는 파일이 아니라 열려있는 디렉터리를"
" 참조해야 합니다. 파이썬 3.3부터는, ``os.chdir(fd)``\\와 같습니다."

#: ../Doc/library/os.rst:1693
msgid "Return a string representing the current working directory."
msgstr "현재 작업 디렉터리를 나타내는 문자열을 반환합니다."

#: ../Doc/library/os.rst:1698
msgid "Return a bytestring representing the current working directory."
msgstr "현재 작업 디렉터리를 나타내는 바이트열을 반환합니다."

#: ../Doc/library/os.rst:1703
msgid ""
"Set the flags of *path* to the numeric *flags*, like :func:`chflags`, but"
" do not follow symbolic links.  As of Python 3.3, this is equivalent to "
"``os.chflags(path, flags, follow_symlinks=False)``."
msgstr ""
"*path* 의 플래그를, :func:`chflags` 처럼, 숫자 *flags*\\로 설정하지만, 심볼릭 링크를 따르지 않습니다."
" 파이썬 3.3부터는, ``os.chflags(path, flags, follow_symlinks=False)``\\와 같습니다."

#: ../Doc/library/os.rst:1715
msgid ""
"Change the mode of *path* to the numeric *mode*. If path is a symlink, "
"this affects the symlink rather than the target.  See the docs for "
":func:`chmod` for possible values of *mode*.  As of Python 3.3, this is "
"equivalent to ``os.chmod(path, mode, follow_symlinks=False)``."
msgstr ""
"*path* 모드를 숫자 *mode*\\로 변경합니다. path가 심볼릭 링크면, 이 함수는 타깃이 아닌 심볼릭 링크에 영향을 "
"미칩니다. *mode*\\의 가능한 값은 :func:`chmod` 문서를 참조하십시오. 파이썬 3.3부터는, "
"``os.chmod(path, mode, follow_symlinks=False)``\\와 같습니다."

#: ../Doc/library/os.rst:1727
msgid ""
"Change the owner and group id of *path* to the numeric *uid* and *gid*.  "
"This function will not follow symbolic links.  As of Python 3.3, this is "
"equivalent to ``os.chown(path, uid, gid, follow_symlinks=False)``."
msgstr ""
"*path* 의 소유자와 그룹 ID를 숫자 *uid* 와 *gid*\\로 변경합니다. 이 함수는 심볼릭 링크를 따르지 않습니다. "
"파이썬 3.3부터는, ``os.chown(path, uid, gid, follow_symlinks=False)``\\와 같습니다."

#: ../Doc/library/os.rst:1739
msgid "Create a hard link pointing to *src* named *dst*."
msgstr "*src*\\를 가리키는 *dst* 라는 이름의 하드 링크를 만듭니다."

#: ../Doc/library/os.rst:1741
msgid ""
"This function can support specifying *src_dir_fd* and/or *dst_dir_fd* to "
"supply :ref:`paths relative to directory descriptors <dir_fd>`, and "
":ref:`not following symlinks <follow_symlinks>`."
msgstr ""
"이 함수는 :ref:`디렉터리 기술자에 상대적인 경로 <dir_fd>`\\를 제공하기 위해 *src_dir_fd* 와/나 "
"*dst_dir_fd* 를 지정하는 것과, :ref:`심볼릭 링크를 따르지 않음 <follow_symlinks>`\\을 지원할 수 "
"있습니다."

#: ../Doc/library/os.rst:1747
msgid "Added Windows support."
msgstr "윈도우 지원이 추가되었습니다."

#: ../Doc/library/os.rst:1750
msgid "Added the *src_dir_fd*, *dst_dir_fd*, and *follow_symlinks* arguments."
msgstr "*src_dir_fd* , *dst_dir_fd* 및 *follow_symlinks* 인자를 추가했습니다."

#: ../Doc/library/os.rst:1753 ../Doc/library/os.rst:1815
#: ../Doc/library/os.rst:2067 ../Doc/library/os.rst:2100
#: ../Doc/library/os.rst:2727
msgid "Accepts a :term:`path-like object` for *src* and *dst*."
msgstr "*src* 및 *dst*\\로 :term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: ../Doc/library/os.rst:1759
msgid ""
"Return a list containing the names of the entries in the directory given "
"by *path*.  The list is in arbitrary order, and does not include the "
"special entries ``'.'`` and ``'..'`` even if they are present in the "
"directory."
msgstr ""
"*path*\\에 의해 주어진 디렉터리에 있는 항목들의 이름을 담고 있는 리스트를 반환합니다. 리스트는 임의의 순서로 나열되며, "
"디렉터리에 존재하더라도 특수 항목 ``'.'`` 과 ``'..'``\\는 포함하지 않습니다."

#: ../Doc/library/os.rst:1763
msgid ""
"*path* may be a :term:`path-like object`.  If *path* is of type ``bytes``"
" (directly or indirectly through the :class:`PathLike` interface), the "
"filenames returned will also be of type ``bytes``; in all other "
"circumstances, they will be of type ``str``."
msgstr ""
"*path*\\는 :term:`경로류 객체 <path-like object>` 일 수 있습니다. *path* 가 ``bytes`` "
"형이면 (직접 또는 :class:`PathLike` 인터페이스를 통해 간접적으로), 반환되는 파일명도 ``bytes`` 형입니다; "
"다른 모든 상황에서는 형 ``str``\\이 됩니다."

#: ../Doc/library/os.rst:1768 ../Doc/library/os.rst:2143
msgid ""
"This function can also support :ref:`specifying a file descriptor "
"<path_fd>`; the file descriptor must refer to a directory."
msgstr ""
"이 함수는 또한 :ref:`파일 기술자 지정 <path_fd>`\\을 지원할 수 있습니다; 파일 기술자는 디렉터리를 참조해야 합니다."

#: ../Doc/library/os.rst:1772
msgid "To encode ``str`` filenames to ``bytes``, use :func:`~os.fsencode`."
msgstr "``str`` 파일명을 ``bytes``\\로 인코딩하려면, :func:`~os.fsencode`\\를 사용하십시오."

#: ../Doc/library/os.rst:1776
msgid ""
"The :func:`scandir` function returns directory entries along with file "
"attribute information, giving better performance for many common use "
"cases."
msgstr ""
":func:`scandir` 함수는 파일 어트리뷰트 정보와 함께 디렉터리 항목을 반환하므로, 많은 일반적인 사용 사례에서 더 나은 "
"성능을 제공합니다."

#: ../Doc/library/os.rst:1780
msgid "The *path* parameter became optional."
msgstr "*path* 매개 변수는 선택 사항이 되었습니다."

#: ../Doc/library/os.rst:1783 ../Doc/library/os.rst:2593
msgid "Added support for specifying an open file descriptor for *path*."
msgstr "*path*\\에 열린 파일 기술자를 지정하는 지원이 추가되었습니다."

#: ../Doc/library/os.rst:1792
msgid ""
"Perform the equivalent of an :c:func:`lstat` system call on the given "
"path. Similar to :func:`~os.stat`, but does not follow symbolic links. "
"Return a :class:`stat_result` object."
msgstr ""
"주어진 경로에 대해 :c:func:`lstat` 시스템 호출과 동등한 작업을 수행합니다. :func:`~os.stat`\\와 "
"유사하지만, 심볼릭 링크를 따르지 않습니다. :class:`stat_result` 객체를 반환합니다."

#: ../Doc/library/os.rst:1796
msgid ""
"On platforms that do not support symbolic links, this is an alias for "
":func:`~os.stat`."
msgstr "심볼릭 링크를 지원하지 않는 플랫폼에서, 이 함수는 :func:`~os.stat`\\의 별칭입니다."

#: ../Doc/library/os.rst:1799
msgid ""
"As of Python 3.3, this is equivalent to ``os.stat(path, dir_fd=dir_fd, "
"follow_symlinks=False)``."
msgstr ""
"파이썬 3.3부터는, ``os.stat(path, dir_fd=dir_fd, follow_symlinks=False)``\\와 "
"같습니다."

#: ../Doc/library/os.rst:1802 ../Doc/library/os.rst:1833
#: ../Doc/library/os.rst:1894 ../Doc/library/os.rst:1922
#: ../Doc/library/os.rst:1996
msgid ""
"This function can also support :ref:`paths relative to directory "
"descriptors <dir_fd>`."
msgstr "이 기능은 :ref:`디렉터리 기술자에 상대적인 경로 <dir_fd>`\\도 지원할 수 있습니다."

#: ../Doc/library/os.rst:1809 ../Doc/library/os.rst:2001
#: ../Doc/library/os.rst:2720
msgid "Added support for Windows 6.0 (Vista) symbolic links."
msgstr "윈도우 6.0 (Vista) 심볼릭 링크에 대한 지원이 추가되었습니다."

#: ../Doc/library/os.rst:1812
msgid "Added the *dir_fd* parameter."
msgstr "*dir_fd* 매개 변수가 추가되었습니다."

#: ../Doc/library/os.rst:1821
msgid "Create a directory named *path* with numeric mode *mode*."
msgstr "숫자 모드 *mode*\\로 *path* 라는 디렉터리를 만듭니다."

#: ../Doc/library/os.rst:1823
msgid "If the directory already exists, :exc:`FileExistsError` is raised."
msgstr "디렉터리가 이미 존재하면, :exc:`FileExistsError`\\가 발생합니다."

#: ../Doc/library/os.rst:1827
msgid ""
"On some systems, *mode* is ignored.  Where it is used, the current umask "
"value is first masked out.  If bits other than the last 9 (i.e. the last "
"3 digits of the octal representation of the *mode*) are set, their "
"meaning is platform-dependent.  On some platforms, they are ignored and "
"you should call :func:`chmod` explicitly to set them."
msgstr ""
"일부 시스템에서는, *mode*\\가 무시됩니다. 모드가 사용될 때, 현재 umask 값으로 먼저 마스킹합니다. 마지막 9비트 "
"(즉, *mode* 의 8진 표현의 마지막 3자리 수) 이외의 비트가 설정되면, 그 의미는 플랫폼에 따라 다릅니다. 일부 "
"플랫폼에서는, 이것들이 무시되며, 설정하려면 명시적으로 :func:`chmod`\\를 호출해야 합니다."

#: ../Doc/library/os.rst:1836
msgid ""
"It is also possible to create temporary directories; see the "
":mod:`tempfile` module's :func:`tempfile.mkdtemp` function."
msgstr ""
"임시 디렉터리를 만들 수도 있습니다; :mod:`tempfile` 모듈의 :func:`tempfile.mkdtemp` 함수를 "
"참조하십시오."

#: ../Doc/library/os.rst:1852
msgid ""
"Recursive directory creation function.  Like :func:`mkdir`, but makes all"
" intermediate-level directories needed to contain the leaf directory."
msgstr ""
"재귀적 디렉터리 생성 함수. :func:`mkdir`\\와 비슷하지만, 말단 디렉터리를 포함하는 데 필요한 모든 중간 수준 "
"디렉터리들을 만듭니다."

#: ../Doc/library/os.rst:1855
msgid ""
"The *mode* parameter is passed to :func:`mkdir` for creating the leaf "
"directory; see :ref:`the mkdir() description <mkdir_modebits>` for how it"
" is interpreted.  To set the file permission bits of any newly-created "
"parent directories you can set the umask before invoking "
":func:`makedirs`.  The file permission bits of existing parent "
"directories are not changed."
msgstr ""
"*mode* 매개 변수는 말단 디렉터리를 만들기 위해 :func:`mkdir`\\로 전달됩니다; 이것이 어떻게 해석되는지는 "
":ref:`mkdir() 설명 <mkdir_modebits>`\\을 보십시오. 새로 만들어지는 부모 디렉터리들의 파일 권한 비트를 "
"설정하려면, :func:`makedirs`\\를 호출하기 전에 umask를 설정할 수 있습니다. 이미 존재하는 부모 디렉터리의 파일"
" 권한 비트는 변경되지 않습니다."

#: ../Doc/library/os.rst:1861
msgid ""
"If *exist_ok* is ``False`` (the default), an :exc:`OSError` is raised if "
"the target directory already exists."
msgstr "*exist_ok* 가 ``False``\\(기본값)면, 대상 디렉터리가 이미 있을 때 :exc:`OSError`\\가 발생합니다."

#: ../Doc/library/os.rst:1866
msgid ""
":func:`makedirs` will become confused if the path elements to create "
"include :data:`pardir` (eg. \"..\" on UNIX systems)."
msgstr ""
":func:`makedirs`\\는 생성할 경로 요소에 :data:`pardir`\\(예를 들어, 유닉스 시스템의 경우 "
"\"..\")이 포함되어 있으면 혼란해 할 수 있습니다."

#: ../Doc/library/os.rst:1869
msgid "This function handles UNC paths correctly."
msgstr "이 함수는 UNC 경로를 올바르게 처리합니다."

#: ../Doc/library/os.rst:1871
msgid "The *exist_ok* parameter."
msgstr "*exist_ok* 매개 변수."

#: ../Doc/library/os.rst:1876
msgid ""
"Before Python 3.4.1, if *exist_ok* was ``True`` and the directory "
"existed, :func:`makedirs` would still raise an error if *mode* did not "
"match the mode of the existing directory. Since this behavior was "
"impossible to implement safely, it was removed in Python 3.4.1. See "
":issue:`21082`."
msgstr ""
"파이썬 3.4.1 이전에는, *exist_ok* 가 ``True``\\이고 디렉터리가 존재한다면, *mode* 가 기존 디렉터리의 "
"모드와 일치하지 않을 때, :func:`makedirs`\\는 여전히 에러를 발생시킵니다. 이 동작은 안전하게 구현할 수 없으므로,"
" 파이썬 3.4.1에서 제거되었습니다. :issue:`21082`\\를 참조하십시오."

#: ../Doc/library/os.rst:1884
msgid ""
"The *mode* argument no longer affects the file permission bits of newly-"
"created intermediate-level directories."
msgstr "*mode* 인자는 더는 새로 만들어지는 중간 수준 디렉터리의 파일 권한 비트에 영향을 주지 않습니다."

#: ../Doc/library/os.rst:1891
msgid ""
"Create a FIFO (a named pipe) named *path* with numeric mode *mode*. The "
"current umask value is first masked out from the mode."
msgstr ""
"숫자 모드 *mode*\\로 *path* 라는 이름의 FIFO(이름있는 파이프)를 만듭니다. 현재 umask 값으로 먼저 모드를 "
"마스킹합니다."

#: ../Doc/library/os.rst:1897
msgid ""
"FIFOs are pipes that can be accessed like regular files.  FIFOs exist "
"until they are deleted (for example with :func:`os.unlink`). Generally, "
"FIFOs are used as rendezvous between \"client\" and \"server\" type "
"processes: the server opens the FIFO for reading, and the client opens it"
" for writing.  Note that :func:`mkfifo` doesn't open the FIFO --- it just"
" creates the rendezvous point."
msgstr ""
"FIFO는 일반 파일처럼 액세스할 수 있는 파이프입니다. FIFO는 삭제될 때까지 존재합니다 (예를 들어 "
":func:`os.unlink`\\로). 일반적으로, FIFO는 \"클라이언트\"와 \"서버\" 유형 프로세스 사이에서 랑데부로 "
"사용됩니다: 서버는 FIFO를 읽기 용도로 열고, 클라이언트는 쓰기 용도로 엽니다. :func:`mkfifo`\\가 FIFO를 "
"열지는 않는다는 점에 유의하십시오 --- 단지 랑데부 포인트를 생성합니다."

#: ../Doc/library/os.rst:1914
msgid ""
"Create a filesystem node (file, device special file or named pipe) named "
"*path*. *mode* specifies both the permissions to use and the type of node"
" to be created, being combined (bitwise OR) with one of ``stat.S_IFREG``,"
" ``stat.S_IFCHR``, ``stat.S_IFBLK``, and ``stat.S_IFIFO`` (those "
"constants are available in :mod:`stat`).  For ``stat.S_IFCHR`` and "
"``stat.S_IFBLK``, *device* defines the newly created device special file "
"(probably using :func:`os.makedev`), otherwise it is ignored."
msgstr ""
"*path* 라는 이름의 파일 시스템 노드(파일, 장치 특수 파일 또는 이름있는 파이프)를 만듭니다. *mode* 는 사용 권한과 "
"생성될 노드의 유형을 모두 지정하며, ``stat.S_IFREG``, ``stat.S_IFCHR``, ``stat.S_IFBLK``"
" 및 ``stat.S_IFIFO`` 중 하나와 결합(비트별 OR)합니다 (이 상수들은 :mod:`stat`\\에 있습니다). "
"``stat.S_IFCHR``\\와 ``stat.S_IFBLK``\\의 경우, *device* 는 새로 만들어지는 장치 특수 "
"파일(아마도 :func:`os.makedev`\\를 사용해서)을 정의합니다, 그렇지 않으면 무시됩니다."

#: ../Doc/library/os.rst:1936
msgid ""
"Extract the device major number from a raw device number (usually the "
":attr:`st_dev` or :attr:`st_rdev` field from :c:type:`stat`)."
msgstr ""
"원시 장치 번호(보통 :c:type:`stat`\\의 :attr:`st_dev` 이나 :attr:`st_rdev` 어트리뷰트)에서 "
"장치 주 번호를 추출합니다."

#: ../Doc/library/os.rst:1942
msgid ""
"Extract the device minor number from a raw device number (usually the "
":attr:`st_dev` or :attr:`st_rdev` field from :c:type:`stat`)."
msgstr ""
"원시 장치 번호(보통 :c:type:`stat`\\의 :attr:`st_dev` 이나 :attr:`st_rdev` 어트리뷰트)에서 "
"장치 부 번호를 추출합니다."

#: ../Doc/library/os.rst:1948
msgid "Compose a raw device number from the major and minor device numbers."
msgstr "주 장치 번호와 부 장치 번호로 원시 장치 번호를 조립합니다."

#: ../Doc/library/os.rst:1953
msgid ""
"Return system configuration information relevant to a named file. *name* "
"specifies the configuration value to retrieve; it may be a string which "
"is the name of a defined system value; these names are specified in a "
"number of standards (POSIX.1, Unix 95, Unix 98, and others).  Some "
"platforms define additional names as well.  The names known to the host "
"operating system are given in the ``pathconf_names`` dictionary.  For "
"configuration variables not included in that mapping, passing an integer "
"for *name* is also accepted."
msgstr ""
"이름있는 파일과 관련된 시스템 구성 정보를 반환합니다. *name* 은 조회할 구성 값을 지정합니다; 정의된 시스템 값의 이름인 "
"문자열일 수 있습니다; 이 이름은 여러 표준(POSIX.1, 유닉스 95, 유닉스 98 및 기타)에서 지정됩니다. 일부 플랫폼은 "
"추가적인 이름도 정의합니다. 호스트 운영 체제에 알려진 이름은 ``pathconf_names`` 딕셔너리에서 제공됩니다. 이 매핑에"
" 포함되지 않은 구성 변수를 위해, *name*\\에 정수를 전달하는 것도 허용됩니다."

#: ../Doc/library/os.rst:1966 ../Doc/library/os.rst:2586
#: ../Doc/library/os.rst:2745
msgid "This function can support :ref:`specifying a file descriptor <path_fd>`."
msgstr "이 함수는 :ref:`파일 기술자 지정 <path_fd>`\\을 지원할 수 있습니다."

#: ../Doc/library/os.rst:1977
msgid ""
"Dictionary mapping names accepted by :func:`pathconf` and "
":func:`fpathconf` to the integer values defined for those names by the "
"host operating system.  This can be used to determine the set of names "
"known to the system."
msgstr ""
":func:`pathconf`\\와 :func:`fpathconf`\\가 받아들이는 이름을 호스트 운영 체제에서 해당 이름에 대해 "
"정의된 정숫값으로 매핑하는 딕셔너리. 이것은 시스템에 알려진 이름 집합을 판별하는 데 사용될 수 있습니다."

#: ../Doc/library/os.rst:1986
msgid ""
"Return a string representing the path to which the symbolic link points."
"  The result may be either an absolute or relative pathname; if it is "
"relative, it may be converted to an absolute pathname using "
"``os.path.join(os.path.dirname(path), result)``."
msgstr ""
"심볼릭 링크가 가리키는 경로를 나타내는 문자열을 반환합니다. 결과는 절대 또는 상대 경로명일 수 있습니다; 상대 경로이면 "
"``os.path.join(os.path.dirname(path), result)``\\를 사용하여 절대 경로명으로 변환할 수 "
"있습니다."

#: ../Doc/library/os.rst:1991
msgid ""
"If the *path* is a string object (directly or indirectly through a "
":class:`PathLike` interface), the result will also be a string object, "
"and the call may raise a UnicodeDecodeError. If the *path* is a bytes "
"object (direct or indirectly), the result will be a bytes object."
msgstr ""
"*path* 가 (직접 또는 :class:`PathLike` 인터페이스를 통해 간접적으로) 문자열 객체면, 결과도 문자열 객체가 "
"되고, 호출은 UnicodeDecodeError를 발생시킬 수 있습니다. *path* 가 (직접 또는 간접적으로) 바이트열 객체면,"
" 결과는 바이트열 객체가 됩니다."

#: ../Doc/library/os.rst:2013
msgid ""
"Remove (delete) the file *path*.  If *path* is a directory, "
":exc:`OSError` is raised.  Use :func:`rmdir` to remove directories."
msgstr ""
"파일 *path*\\를 제거(삭제)합니다. *path* 가 디렉터리면, :exc:`OSError`\\가 발생합니다. 디렉터리를 "
"제거하려면 :func:`rmdir`\\를 사용하십시오."

#: ../Doc/library/os.rst:2016 ../Doc/library/os.rst:2110
#: ../Doc/library/os.rst:2703
msgid ""
"This function can support :ref:`paths relative to directory descriptors "
"<dir_fd>`."
msgstr "이 함수는 :ref:`디렉터리 기술자에 상대적인 경로 <dir_fd>`\\를 지원할 수 있습니다."

#: ../Doc/library/os.rst:2019
msgid ""
"On Windows, attempting to remove a file that is in use causes an "
"exception to be raised; on Unix, the directory entry is removed but the "
"storage allocated to the file is not made available until the original "
"file is no longer in use."
msgstr ""
"윈도우에서, 사용 중인 파일을 제거하려고 시도하면 예외가 발생합니다; 유닉스에서는 디렉터리 항목이 제거되지만, 원본 파일이 더는 "
"사용되지 않을 때까지 파일에 할당된 저장 공간을 사용할 수 없습니다."

#: ../Doc/library/os.rst:2023
msgid "This function is semantically identical to :func:`unlink`."
msgstr "이 함수는 의미 적으로 :func:`unlink`\\와 같습니다."

#: ../Doc/library/os.rst:2036
msgid ""
"Remove directories recursively.  Works like :func:`rmdir` except that, if"
" the leaf directory is successfully removed, :func:`removedirs`  tries to"
" successively remove every parent directory mentioned in  *path* until an"
" error is raised (which is ignored, because it generally means that a "
"parent directory is not empty). For example, "
"``os.removedirs('foo/bar/baz')`` will first remove the directory "
"``'foo/bar/baz'``, and then remove ``'foo/bar'`` and ``'foo'`` if they "
"are empty. Raises :exc:`OSError` if the leaf directory could not be "
"successfully removed."
msgstr ""
"재귀적으로 디렉터리를 제거합니다. :func:`rmdir` 처럼 동작하는데 다음과 같은 차이가 있습니다. 말단 디렉터리가 성공적으로"
" 제거되면, :func:`removedirs`\\는 에러가 발생할 때까지 *path*\\에 언급된 모든 상위 디렉터리를 연속적으로 "
"제거하려고 합니다 (에러는 무시되는데, 이는 일반적으로 부모 디렉터리가 비어 있음을 뜻하기 때문입니다). 예를 들어, "
"``os.removedirs('foo/bar/baz')``\\는 먼저 ``'foo/bar/baz'`` 디렉터리를 제거한 다음, "
"``'foo/bar'`` 및 ``'foo'``\\가 비어 있으면 제거합니다. 말단 디렉터리를 성공적으로 제거할 수 없으면, "
":exc:`OSError`\\를 발생시킵니다."

#: ../Doc/library/os.rst:2051
msgid ""
"Rename the file or directory *src* to *dst*.  If *dst* is a directory, "
":exc:`OSError` will be raised.  On Unix, if *dst* exists and is a file, "
"it will be replaced silently if the user has permission.  The operation "
"may fail on some Unix flavors if *src* and *dst* are on different "
"filesystems.  If successful, the renaming will be an atomic operation "
"(this is a POSIX requirement).  On Windows, if *dst* already exists, "
":exc:`OSError` will be raised even if it is a file."
msgstr ""
"파일 또는 디렉터리 *src*\\의 이름을 *dst*\\로 바꿉니다. *dst* 가 디렉터리면, :exc:`OSError`\\가 "
"발생합니다. 유닉스에서는, *dst* 가 존재하고 파일이면, 사용자에게 권한이 있을 때 자동으로 대체됩니다. *src* 와 "
"*dst* 가 다른 파일 시스템에 있을 때, 일부 유닉스 환경에서 작업이 실패할 수 있습니다. 성공하면, 이름 바꾸기는 원자적 "
"연산이 됩니다 (이것은 POSIX 요구 사항입니다). 윈도우에서 *dst*\\가 이미 존재하면, :exc:`OSError`\\는 "
"파일일 때도 발생합니다."

#: ../Doc/library/os.rst:2059 ../Doc/library/os.rst:2095
msgid ""
"This function can support specifying *src_dir_fd* and/or *dst_dir_fd* to "
"supply :ref:`paths relative to directory descriptors <dir_fd>`."
msgstr ""
"이 함수는 :ref:`디렉터리 기술자에 상대적인 경로 <dir_fd>`\\를 제공하도록 *src_dir_fd* 와/나 "
"*dst_dir_fd* 를 지정하는 것을 지원할 수 있습니다."

#: ../Doc/library/os.rst:2062
msgid ""
"If you want cross-platform overwriting of the destination, use "
":func:`replace`."
msgstr "플랫폼에 무관하게 대상을 덮어쓰길 원하면, :func:`replace`\\를 사용하십시오."

#: ../Doc/library/os.rst:2064
msgid "The *src_dir_fd* and *dst_dir_fd* arguments."
msgstr "*src_dir_fd* 및 *dst_dir_fd* 인자"

#: ../Doc/library/os.rst:2073
msgid ""
"Recursive directory or file renaming function. Works like :func:`rename`,"
" except creation of any intermediate directories needed to make the new "
"pathname good is attempted first. After the rename, directories "
"corresponding to rightmost path segments of the old name will be pruned "
"away using :func:`removedirs`."
msgstr ""
"재귀적 디렉터리 또는 파일 이름 바꾸기 함수. :func:`rename`\\처럼 작동하지만, 새 경로명이 유효하도록 만들기 위해 "
"먼저 필요한 중간 디렉터리를 만드는 점이 다릅니다. 이름을 변경한 후에는, 이전 이름의 가장 오른쪽 경로 세그먼트에 해당하는 "
"디렉터리를 :func:`removedirs`\\를 사용하여 제거합니다."

#: ../Doc/library/os.rst:2080
msgid ""
"This function can fail with the new directory structure made if you lack "
"permissions needed to remove the leaf directory or file."
msgstr ""
"이 함수는 말단 디렉터리나 파일을 제거하는 데 필요한 권한이 없을 때, 새 디렉터리 구조를 만든 상태에서 실패할 수 있습니다."

#: ../Doc/library/os.rst:2083
msgid "Accepts a :term:`path-like object` for *old* and *new*."
msgstr "*old* 와 *new* 에 :term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: ../Doc/library/os.rst:2089
msgid ""
"Rename the file or directory *src* to *dst*.  If *dst* is a directory, "
":exc:`OSError` will be raised.  If *dst* exists and is a file, it will be"
" replaced silently if the user has permission.  The operation may fail if"
" *src* and *dst* are on different filesystems.  If successful, the "
"renaming will be an atomic operation (this is a POSIX requirement)."
msgstr ""
"파일 또는 디렉터리 *src*\\의 이름을 *dst*\\로 바꿉니다. *dst* 가 디렉터리면, :exc:`OSError`\\가 "
"발생합니다. *dst* 가 존재하고 파일이면, 사용자에게 권한이 있을 때 자동으로 대체됩니다. *src* 와 *dst* 가 다른 "
"파일 시스템에 있으면, 작업이 실패할 수 있습니다. 성공하면, 이름 바꾸기는 원자적 연산이 됩니다 (이것은 POSIX 요구 "
"사항입니다)."

#: ../Doc/library/os.rst:2106
msgid ""
"Remove (delete) the directory *path*.  Only works when the directory is "
"empty, otherwise, :exc:`OSError` is raised.  In order to remove whole "
"directory trees, :func:`shutil.rmtree` can be used."
msgstr ""
"디렉터리 *path*\\를 제거(삭제)합니다. 디렉터리가 비어있을 때만 작동하고, 그렇지 않으면 :exc:`OSError`\\가 "
"발생합니다. 전체 디렉터리 트리를 제거하려면, :func:`shutil.rmtree`\\를 사용할 수 있습니다."

#: ../Doc/library/os.rst:2113 ../Doc/library/os.rst:2765
msgid "The *dir_fd* parameter."
msgstr "*dir_fd* 매개 변수"

#: ../Doc/library/os.rst:2122
msgid ""
"Return an iterator of :class:`os.DirEntry` objects corresponding to the "
"entries in the directory given by *path*. The entries are yielded in "
"arbitrary order, and the special entries ``'.'`` and ``'..'`` are not "
"included."
msgstr ""
"*path*\\로 지정된 디렉터리 내의 항목에 대응하는 :class:`os.DirEntry` 객체의 이터레이터를 돌려줍니다. 항목은"
" 임의의 순서로 제공되며, 특수 항목 ``'.'`` 및 ``'..'``\\는 포함되지 않습니다."

#: ../Doc/library/os.rst:2127
msgid ""
"Using :func:`scandir` instead of :func:`listdir` can significantly "
"increase the performance of code that also needs file type or file "
"attribute information, because :class:`os.DirEntry` objects expose this "
"information if the operating system provides it when scanning a "
"directory. All :class:`os.DirEntry` methods may perform a system call, "
"but :func:`~os.DirEntry.is_dir` and :func:`~os.DirEntry.is_file` usually "
"only require a system call for symbolic links; :func:`os.DirEntry.stat` "
"always requires a system call on Unix but only requires one for symbolic "
"links on Windows."
msgstr ""
":func:`listdir` 대신 :func:`scandir`\\를 사용하면, 디렉터리를 검색할 때 운영 체제가 제공한다면 "
":class:`os.DirEntry` 객체가 파일 유형과 파일 어트리뷰트 정보를 제공하기 때문에, 이것들이 필요한 코드의 성능을 "
"크게 개선할 수 있습니다. 모든 :class:`os.DirEntry` 메서드가 시스템 호출을 수행할 수 있지만, 일반적으로 "
":func:`~os.DirEntry.is_dir` 및 :func:`~os.DirEntry.is_file`\\는 심볼릭 링크에 "
"대해서만 시스템 호출을 요구합니다; :func:`os.DirEntry.stat`\\는 유닉스에서 항상 시스템 호출을 요구하지만 "
"윈도우에서는 심볼릭 링크에 대해서만 시스템 호출을 요구합니다."

#: ../Doc/library/os.rst:2137
msgid ""
"*path* may be a :term:`path-like object`.  If *path* is of type ``bytes``"
" (directly or indirectly through the :class:`PathLike` interface), the "
"type of the :attr:`~os.DirEntry.name` and :attr:`~os.DirEntry.path` "
"attributes of each :class:`os.DirEntry` will be ``bytes``; in all other "
"circumstances, they will be of type ``str``."
msgstr ""
"*path* 는 :term:`경로류 객체 <path-like object>` 일 수 있습니다. *path* 가 (직접 또는 "
":class:`PathLike` 인터페이스를 통해 간접적으로) ``bytes`` 형이면, 각 "
":class:`os.DirEntry`\\의 :attr:`~os.DirEntry.name` 및 "
":attr:`~os.DirEntry.path` 어트리뷰트의 형은 ``bytes``\\입니다. 다른 모든 상황에서는 형 "
"``str``\\이 됩니다."

#: ../Doc/library/os.rst:2146
msgid ""
"The :func:`scandir` iterator supports the :term:`context manager` "
"protocol and has the following method:"
msgstr ""
":func:`scandir` 이터레이터는 :term:`컨텍스트 관리자 <context manager>` 프로토콜을 지원하고 다음과 "
"같은 메서드를 제공합니다:"

#: ../Doc/library/os.rst:2151
msgid "Close the iterator and free acquired resources."
msgstr "이터레이터를 닫고 확보한 자원을 반납합니다."

#: ../Doc/library/os.rst:2153
msgid ""
"This is called automatically when the iterator is exhausted or garbage "
"collected, or when an error happens during iterating.  However it is "
"advisable to call it explicitly or use the :keyword:`with` statement."
msgstr ""
"이터레이터가 소진되거나 가비지 수집될 때 또는 이터레이션 중에 에러가 발생하면 자동으로 호출됩니다. 하지만 명시적으로 호출하거나 "
":keyword:`with` 문을 사용하는 것이 좋습니다."

#: ../Doc/library/os.rst:2160
msgid ""
"The following example shows a simple use of :func:`scandir` to display "
"all the files (excluding directories) in the given *path* that don't "
"start with ``'.'``. The ``entry.is_file()`` call will generally not make "
"an additional system call::"
msgstr ""
"다음 예제는 주어진 *path*\\의 ``'.'``\\로 시작하지 않는 모든 파일(디렉터리 제외)을 표시하기 위한 "
":func:`scandir`\\의 간단한 사용을 보여줍니다. ``entry.is_file()`` 호출은 일반적으로 추가 시스템 "
"호출을 하지 않습니다::"

#: ../Doc/library/os.rst:2172
msgid ""
"On Unix-based systems, :func:`scandir` uses the system's `opendir() "
"<http://pubs.opengroup.org/onlinepubs/009695399/functions/opendir.html>`_"
" and `readdir() "
"<http://pubs.opengroup.org/onlinepubs/009695399/functions/readdir_r.html>`_"
" functions. On Windows, it uses the Win32 `FindFirstFileW "
"<https://msdn.microsoft.com/en-"
"us/library/windows/desktop/aa364418(v=vs.85).aspx>`_ and `FindNextFileW "
"<https://msdn.microsoft.com/en-"
"us/library/windows/desktop/aa364428(v=vs.85).aspx>`_ functions."
msgstr ""
"유닉스 기반 시스템에서, :func:`scandir`\\은 시스템의 `opendir() "
"<http://pubs.opengroup.org/onlinepubs/009695399/functions/opendir.html>`_"
" 과 `readdir() "
"<http://pubs.opengroup.org/onlinepubs/009695399/functions/readdir_r.html>`_"
" 함수를 사용합니다. 윈도우에서는, Win32 `FindFirstFileW <https://msdn.microsoft.com/en-"
"us/library/windows/desktop/aa364418(v=vs.85).aspx>`_ 와 `FindNextFileW "
"<https://msdn.microsoft.com/en-"
"us/library/windows/desktop/aa364428(v=vs.85).aspx>`_ 함수를 사용합니다."

#: ../Doc/library/os.rst:2184
msgid ""
"Added support for the :term:`context manager` protocol and the "
":func:`~scandir.close()` method.  If a :func:`scandir` iterator is "
"neither exhausted nor explicitly closed a :exc:`ResourceWarning` will be "
"emitted in its destructor."
msgstr ""
":term:`컨텍스트 관리자 <context manager>` 프로토콜과 :func:`~scandir.close()` 메서드 대한 "
"지원이 추가되었습니다. :func:`scandir` 이터레이터가 모두 소진되거나 명시적으로 닫히지 않으면 "
":exc:`ResourceWarning`\\가 파괴자에서 방출됩니다."

#: ../Doc/library/os.rst:2190
msgid "The function accepts a :term:`path-like object`."
msgstr "이 함수는 :term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: ../Doc/library/os.rst:2192
msgid "Added support for :ref:`file descriptors <path_fd>` on Unix."
msgstr "유닉스에서 :ref:`파일 기술자 <path_fd>`\\에 대한 지원이 추가되었습니다."

#: ../Doc/library/os.rst:2198
msgid ""
"Object yielded by :func:`scandir` to expose the file path and other file "
"attributes of a directory entry."
msgstr "디렉터리 항목의 파일 경로와 다른 파일 어트리뷰트를 노출하기 위해 :func:`scandir`\\에 의해 산출되는 객체."

#: ../Doc/library/os.rst:2201
msgid ""
":func:`scandir` will provide as much of this information as possible "
"without making additional system calls. When a ``stat()`` or ``lstat()`` "
"system call is made, the ``os.DirEntry`` object will cache the result."
msgstr ""
":func:`scandir`\\는 추가 시스템 호출 없이 가능한 많은 정보를 제공합니다. ``stat()`` 또는 "
"``lstat()`` 시스템 호출이 이루어지면, ``os.DirEntry`` 객체는 결과를 캐시 합니다."

#: ../Doc/library/os.rst:2205
msgid ""
"``os.DirEntry`` instances are not intended to be stored in long-lived "
"data structures; if you know the file metadata has changed or if a long "
"time has elapsed since calling :func:`scandir`, call "
"``os.stat(entry.path)`` to fetch up-to-date information."
msgstr ""
"``os.DirEntry`` 인스턴스는 수명이 긴 데이터 구조에 저장하는 용도가 아닙니다; 파일 메타 데이터가 변경되었거나 "
":func:`scandir`\\를 호출한 후 오랜 시간이 지났음을 안다면, ``os.stat(entry.path)``\\를 호출하여"
" 최신 정보를 가져오십시오."

#: ../Doc/library/os.rst:2210
msgid ""
"Because the ``os.DirEntry`` methods can make operating system calls, they"
" may also raise :exc:`OSError`. If you need very fine-grained control "
"over errors, you can catch :exc:`OSError` when calling one of the "
"``os.DirEntry`` methods and handle as appropriate."
msgstr ""
"``os.DirEntry`` 메서드는 운영 체제 시스템 호출을 할 수 있으므로, :exc:`OSError`\\를 일으킬 수도 "
"있습니다. 에러에 대해 매우 세부적인 제어가 필요하면, ``os.DirEntry`` 메서드 중 하나를 호출할 때 "
":exc:`OSError`\\를 잡은 후 적절하게 처리할 수 있습니다."

#: ../Doc/library/os.rst:2215
msgid ""
"To be directly usable as a :term:`path-like object`, ``os.DirEntry`` "
"implements the :class:`PathLike` interface."
msgstr ""
":term:`경로류 객체 <path-like object>`\\로 직접 사용할 수 있도록, ``os.DirEntry``\\는 "
":class:`PathLike` 인터페이스를 구현합니다."

#: ../Doc/library/os.rst:2218
msgid "Attributes and methods on a ``os.DirEntry`` instance are as follows:"
msgstr "``os.DirEntry`` 인스턴스의 어트리뷰트 및 메서드는 다음과 같습니다:"

#: ../Doc/library/os.rst:2222
msgid ""
"The entry's base filename, relative to the :func:`scandir` *path* "
"argument."
msgstr ":func:`scandir` *path* 인자에 상대적인, 항목의 기본(base) 파일명."

#: ../Doc/library/os.rst:2225
msgid ""
"The :attr:`name` attribute will be ``bytes`` if the :func:`scandir` "
"*path* argument is of type ``bytes`` and ``str`` otherwise.  Use "
":func:`~os.fsdecode` to decode byte filenames."
msgstr ""
":attr:`name` 어트리뷰트는 :func:`scandir` *path* 인자가 ``bytes`` 형이면 ``bytes`` 고,"
" 그렇지 않으면 ``str`` 입니다. 바이트열 파일명을 디코딩하려면 :func:`~os.fsdecode`\\를 사용하십시오."

#: ../Doc/library/os.rst:2231
msgid ""
"The entry's full path name: equivalent to ``os.path.join(scandir_path, "
"entry.name)`` where *scandir_path* is the :func:`scandir` *path* "
"argument.  The path is only absolute if the :func:`scandir` *path* "
"argument was absolute.  If the :func:`scandir` *path* argument was a "
":ref:`file descriptor <path_fd>`, the :attr:`path` attribute is the same "
"as the :attr:`name` attribute."
msgstr ""
"항목의 전체 경로명: ``os.path.join(scandir_path, entry.name)``\\과 같습니다. 여기서 "
"*scandir_path* 는 :func:`scandir` *path* 인자입니다. 경로는 :func:`scandir` *path*"
" 인자가 절대 경로일 때만 절대 경로입니다. :func:`scandir` *path* 인자가 :ref:`파일 기술자 "
"<path_fd>`\\면, :attr:`path` 어트리뷰트는 :attr:`name` 어트리뷰트와 같습니다."

#: ../Doc/library/os.rst:2238
msgid ""
"The :attr:`path` attribute will be ``bytes`` if the :func:`scandir` "
"*path* argument is of type ``bytes`` and ``str`` otherwise.  Use "
":func:`~os.fsdecode` to decode byte filenames."
msgstr ""
":attr:`path` 어트리뷰트는 :func:`scandir` *path* 인자가 ``bytes`` 형이면 "
"``bytes``\\고, 그렇지 않으면 ``str`` 입니다. 바이트열 파일명을 디코딩하려면 "
":func:`~os.fsdecode`\\를 사용하십시오."

#: ../Doc/library/os.rst:2244
msgid "Return the inode number of the entry."
msgstr "항목의 아이노드(inode) 번호를 반환합니다."

#: ../Doc/library/os.rst:2246
msgid ""
"The result is cached on the ``os.DirEntry`` object. Use "
"``os.stat(entry.path, follow_symlinks=False).st_ino`` to fetch up-to-date"
" information."
msgstr ""
"결과는 ``os.DirEntry`` 객체에 캐시 됩니다. 최신 정보를 가져오려면 ``os.stat(entry.path, "
"follow_symlinks=False).st_ino``\\를 사용하십시오."

#: ../Doc/library/os.rst:2250
msgid ""
"On the first, uncached call, a system call is required on Windows but not"
" on Unix."
msgstr "최초의 캐시 되지 않은 호출에서, 윈도우 에서는 시스템 호출이 필요하지만, 유닉스에서는 그렇지 않습니다."

#: ../Doc/library/os.rst:2255
msgid ""
"Return ``True`` if this entry is a directory or a symbolic link pointing "
"to a directory; return ``False`` if the entry is or points to any other "
"kind of file, or if it doesn't exist anymore."
msgstr ""
"이 항목이 디렉터리 또는 디렉터리를 가리키는 심볼릭 링크면 ``True``\\를 반환합니다; 항목이 다른 종류의 파일이거나 다른 "
"종류의 파일을 가리키면, 또는 더는 존재하지 않으면 ``False``\\를 반환합니다."

#: ../Doc/library/os.rst:2259
msgid ""
"If *follow_symlinks* is ``False``, return ``True`` only if this entry is "
"a directory (without following symlinks); return ``False`` if the entry "
"is any other kind of file or if it doesn't exist anymore."
msgstr ""
"*follow_symlinks* 가 ``False``\\면, 이 항목이 디렉터리일 때만 (심볼릭 링크를 따르지 않고) "
"``True``\\를 반환합니다; 항목이 다른 종류의 파일이거나 더는 존재하지 않으면 ``False``\\를 반환합니다."

#: ../Doc/library/os.rst:2263
msgid ""
"The result is cached on the ``os.DirEntry`` object, with a separate cache"
" for *follow_symlinks* ``True`` and ``False``. Call :func:`os.stat` along"
" with :func:`stat.S_ISDIR` to fetch up-to-date information."
msgstr ""
"결과는 *follow_symlinks* 가 ``True`` 및 ``False``\\일 때에 대해 별도로 ``os.DirEntry``"
" 객체에 캐시 됩니다. 최신 정보를 가져오려면, :func:`stat.S_ISDIR`\\로 :func:`os.stat`\\을 "
"호출하십시오."

#: ../Doc/library/os.rst:2267
msgid ""
"On the first, uncached call, no system call is required in most cases. "
"Specifically, for non-symlinks, neither Windows or Unix require a system "
"call, except on certain Unix file systems, such as network file systems, "
"that return ``dirent.d_type == DT_UNKNOWN``. If the entry is a symlink, a"
" system call will be required to follow the symlink unless "
"*follow_symlinks* is ``False``."
msgstr ""
"최초의 캐시 되지 않은 호출에서, 대부분 시스템 호출이 필요하지 않습니다. 특히, 심볼릭 링크가 아니면, 윈도우나 유닉스 모두 "
"시스템 호출이 필요하지 않은데, 네트워크 파일 시스템과 같이 ``dirent.d_type == DT_UNKNOWN``\\를 반환하는"
" 특정 유닉스 파일 시스템은 예외입니다. 항목이 심볼릭 링크면, *follow_symlinks* 가 ``False``\\가 아닌 "
"이상, 심볼릭 링크를 따르기 위해 시스템 호출이 필요합니다."

#: ../Doc/library/os.rst:2274 ../Doc/library/os.rst:2304
msgid ""
"This method can raise :exc:`OSError`, such as :exc:`PermissionError`, but"
" :exc:`FileNotFoundError` is caught and not raised."
msgstr ""
"이 메서드는, :exc:`PermissionError`\\와 같은, :exc:`OSError`\\를 발생시킬 수 있지만, "
":exc:`FileNotFoundError`\\는 잡혀서 발생하지 않습니다."

#: ../Doc/library/os.rst:2279
msgid ""
"Return ``True`` if this entry is a file or a symbolic link pointing to a "
"file; return ``False`` if the entry is or points to a directory or other "
"non-file entry, or if it doesn't exist anymore."
msgstr ""
"이 항목이 파일이나 파일을 가리키는 심볼릭 링크면 ``True``\\를 반환합니다; 항목이 디렉터리 또는 다른 비 파일 항목이거나,"
" 그런 것을 가리키거나, 더는 존재하지 않으면 ``False``\\를 반환합니다."

#: ../Doc/library/os.rst:2283
msgid ""
"If *follow_symlinks* is ``False``, return ``True`` only if this entry is "
"a file (without following symlinks); return ``False`` if the entry is a "
"directory or other non-file entry, or if it doesn't exist anymore."
msgstr ""
"*follow_symlinks* 가 ``False``\\면, 이 항목이 파일일 때만 (심볼릭 링크를 따르지 않고) "
"``True``\\를 반환합니다; 항목이 디렉터리 나 다른 비 파일 항목이거나 더는 존재하지 않으면 ``False``\\를 "
"반환합니다."

#: ../Doc/library/os.rst:2287
msgid ""
"The result is cached on the ``os.DirEntry`` object. Caching, system calls"
" made, and exceptions raised are as per :func:`~os.DirEntry.is_dir`."
msgstr ""
"결과는 ``os.DirEntry`` 객체에 캐시 됩니다. 캐싱, 시스템 호출, 예외 발생은 "
":func:`~os.DirEntry.is_dir`\\과 같습니다."

#: ../Doc/library/os.rst:2292
msgid ""
"Return ``True`` if this entry is a symbolic link (even if broken); return"
" ``False`` if the entry points to a directory or any kind of file, or if "
"it doesn't exist anymore."
msgstr ""
"이 항목이 심볼릭 링크면 (망가졌다 하더라도) ``True``\\를 반환합니다; 항목이 디렉터리 나 어떤 종류의 파일이거나 더는 "
"존재하지 않으면 ``False``\\를 반환합니다."

#: ../Doc/library/os.rst:2296
msgid ""
"The result is cached on the ``os.DirEntry`` object. Call "
":func:`os.path.islink` to fetch up-to-date information."
msgstr ""
"결과는 ``os.DirEntry`` 객체에 캐시 됩니다. 최신 정보를 가져오려면 :func:`os.path.islink`\\를 "
"호출하십시오."

#: ../Doc/library/os.rst:2299
msgid ""
"On the first, uncached call, no system call is required in most cases. "
"Specifically, neither Windows or Unix require a system call, except on "
"certain Unix file systems, such as network file systems, that return "
"``dirent.d_type == DT_UNKNOWN``."
msgstr ""
"첫 번째, 캐시 되지 않은 호출에서는 시스템 호출이 필요하지 않습니다. 특히 윈도우 나 유닉스는 ``dirent.d_type == "
"DT_UNKNOWN``\\를 반환하는 특정 유닉스 파일 시스템 (예 : 네트워크 파일 시스템)을 제외하고는 시스템 호출이 필요하지 "
"않습니다."

#: ../Doc/library/os.rst:2309
msgid ""
"Return a :class:`stat_result` object for this entry. This method follows "
"symbolic links by default; to stat a symbolic link add the "
"``follow_symlinks=False`` argument."
msgstr ""
"이 항목의 :class:`stat_result` 객체를 돌려줍니다. 이 메서드는 기본적으로 심볼릭 링크를 따릅니다; 심볼릭 링크를 "
"stat 하려면, ``follow_symlinks=False`` 인자를 추가하십시오."

#: ../Doc/library/os.rst:2313
msgid ""
"On Unix, this method always requires a system call. On Windows, it only "
"requires a system call if *follow_symlinks* is ``True`` and the entry is "
"a symbolic link."
msgstr ""
"유닉스에서, 이 메서드는 항상 시스템 호출을 요구합니다. 윈도우에서, *follow_symlinks* 가 ``True``\\이고 "
"항목이 심볼릭 링크일 때만 시스템 호출이 필요합니다."

#: ../Doc/library/os.rst:2317
msgid ""
"On Windows, the ``st_ino``, ``st_dev`` and ``st_nlink`` attributes of the"
" :class:`stat_result` are always set to zero. Call :func:`os.stat` to get"
" these attributes."
msgstr ""
"윈도우에서, :class:`stat_result`\\의 ``st_ino``, ``st_dev`` 및 ``st_nlink`` "
"어트리뷰트는 항상 0으로 설정됩니다. 이러한 어트리뷰트를 얻으려면 :func:`os.stat`\\을 호출하십시오."

#: ../Doc/library/os.rst:2321
msgid ""
"The result is cached on the ``os.DirEntry`` object, with a separate cache"
" for *follow_symlinks* ``True`` and ``False``. Call :func:`os.stat` to "
"fetch up-to-date information."
msgstr ""
"결과는 *follow_symlinks* 가 ``True`` 및 ``False``\\일 때에 대해 별도로 ``os.DirEntry``"
" 객체에 캐시 됩니다. 최신 정보를 가져오려면, :func:`os.stat`\\을 호출하십시오."

#: ../Doc/library/os.rst:2325
msgid ""
"Note that there is a nice correspondence between several attributes and "
"methods of ``os.DirEntry`` and of :class:`pathlib.Path`.  In particular, "
"the ``name`` attribute has the same meaning, as do the ``is_dir()``, "
"``is_file()``, ``is_symlink()`` and ``stat()`` methods."
msgstr ""
"``os.DirEntry``\\와 :class:`pathlib.Path`\\의 여러 어트리뷰트와 메서드 사이에는 좋은 일치가 있음에"
" 유의하십시오. 특히, ``name`` 어트리뷰트는 ``is_dir()``, ``is_file()``, "
"``is_symlink()`` 및 ``stat()`` 메서드와 같은 의미가 있습니다."

#: ../Doc/library/os.rst:2333
msgid ""
"Added support for the :class:`~os.PathLike` interface.  Added support for"
" :class:`bytes` paths on Windows."
msgstr ""
":class:`~os.PathLike` 인터페이스에 대한 지원이 추가되었습니다. 윈도우에서 :class:`bytes` 경로에 대한 "
"지원이 추가되었습니다."

#: ../Doc/library/os.rst:2340
msgid ""
"Get the status of a file or a file descriptor. Perform the equivalent of "
"a :c:func:`stat` system call on the given path. *path* may be specified "
"as either a string or bytes -- directly or indirectly through the "
":class:`PathLike` interface -- or as an open file descriptor. Return a "
":class:`stat_result` object."
msgstr ""
"파일 또는 파일 기술자의 상태를 가져옵니다. 주어진 경로에 대해 :c:func:`stat` 시스템 호출과 같은 작업을 수행합니다. "
"*path* 는 문자열이나 바이트열 -- 직접 또는 :class:`PathLike` 인터페이스를 통해 간접적으로 -- 또는 열린 "
"파일 기술자로 지정될 수 있습니다. :class:`stat_result` 객체를 반환합니다."

#: ../Doc/library/os.rst:2346
msgid ""
"This function normally follows symlinks; to stat a symlink add the "
"argument ``follow_symlinks=False``, or use :func:`lstat`."
msgstr ""
"이 함수는 일반적으로 심볼릭 링크를 따릅니다; 심볼릭 링크를 stat 하려면, 인자 "
"``follow_symlinks=False``\\를 추가하거나 :func:`lstat`\\를 사용하십시오."

#: ../Doc/library/os.rst:2349 ../Doc/library/os.rst:2981
#: ../Doc/library/os.rst:2995 ../Doc/library/os.rst:3009
#: ../Doc/library/os.rst:3027
msgid ""
"This function can support :ref:`specifying a file descriptor <path_fd>` "
"and :ref:`not following symlinks <follow_symlinks>`."
msgstr ""
"이 함수는 :ref:`파일 기술자 지정 <path_fd>` 및 :ref:`심볼릭 링크를 따르지 않음 "
"<follow_symlinks>`\\을 지원할 수 있습니다."

#: ../Doc/library/os.rst:2354
msgid "Example::"
msgstr "예::"

#: ../Doc/library/os.rst:2367
msgid ":func:`fstat` and :func:`lstat` functions."
msgstr ":func:`fstat` 및 :func:`lstat` 함수."

#: ../Doc/library/os.rst:2369
msgid ""
"Added the *dir_fd* and *follow_symlinks* arguments, specifying a file "
"descriptor instead of a path."
msgstr "*dir_fd* 및 *follow_symlinks* 인자와 경로 대신 파일 기술자를 지정하는 것을 추가했습니다."

#: ../Doc/library/os.rst:2379
msgid ""
"Object whose attributes correspond roughly to the members of the "
":c:type:`stat` structure. It is used for the result of :func:`os.stat`, "
":func:`os.fstat` and :func:`os.lstat`."
msgstr ""
"어트리뷰트가 :c:type:`stat` 구조체의 멤버와 대략 일치하는 객체. :func:`os.stat`, "
":func:`os.fstat` 및 :func:`os.lstat`\\의 결과로 사용됩니다."

#: ../Doc/library/os.rst:2383
msgid "Attributes:"
msgstr "어트리뷰트:"

#: ../Doc/library/os.rst:2387
msgid "File mode: file type and file mode bits (permissions)."
msgstr "파일 모드: 파일 유형 및 파일 모드 비트 (사용 권한)."

#: ../Doc/library/os.rst:2391
msgid ""
"Platform dependent, but if non-zero, uniquely identifies the file for a "
"given value of ``st_dev``. Typically:"
msgstr "플랫폼에 따라 다르지만, 0이 아니면, 지정된 값의 ``st_dev``\\은 파일을 고유하게 식별합니다. 일반적으로:"

#: ../Doc/library/os.rst:2394
msgid "the inode number on Unix,"
msgstr "유닉스의 아이노드 번호,"

#: ../Doc/library/os.rst:2395
msgid ""
"the `file index <https://msdn.microsoft.com/en-us/library/aa363788>`_ on "
"Windows"
msgstr "윈도우의 `파일 인덱스 <https://msdn.microsoft.com/en-us/library/aa363788>`_"

#: ../Doc/library/os.rst:2401
msgid "Identifier of the device on which this file resides."
msgstr "이 파일이 있는 장치의 식별자."

#: ../Doc/library/os.rst:2405
msgid "Number of hard links."
msgstr "하드 링크 수."

#: ../Doc/library/os.rst:2409
msgid "User identifier of the file owner."
msgstr "파일 소유자의 사용자 식별자."

#: ../Doc/library/os.rst:2413
msgid "Group identifier of the file owner."
msgstr "파일 소유자의 그룹 식별자."

#: ../Doc/library/os.rst:2417
msgid ""
"Size of the file in bytes, if it is a regular file or a symbolic link. "
"The size of a symbolic link is the length of the pathname it contains, "
"without a terminating null byte."
msgstr ""
"일반 파일 또는 심볼릭 링크면, 바이트 단위의 파일의 크기. 심볼릭 링크의 크기는 포함하고 있는 경로명의 길이이며, 끝나는 널 "
"바이트는 포함하지 않습니다."

#: ../Doc/library/os.rst:2421
msgid "Timestamps:"
msgstr "타임스탬프:"

#: ../Doc/library/os.rst:2425
msgid "Time of most recent access expressed in seconds."
msgstr "초 단위의 가장 최근의 액세스 시간."

#: ../Doc/library/os.rst:2429
msgid "Time of most recent content modification expressed in seconds."
msgstr "초 단위의 가장 최근의 내용 수정 시간."

#: ../Doc/library/os.rst:2433 ../Doc/library/os.rst:2449
msgid "Platform dependent:"
msgstr "플랫폼에 따라 다릅니다:"

#: ../Doc/library/os.rst:2435 ../Doc/library/os.rst:2451
msgid "the time of most recent metadata change on Unix,"
msgstr "유닉스에서 가장 최근의 메타 데이터 변경 시간,"

#: ../Doc/library/os.rst:2436
msgid "the time of creation on Windows, expressed in seconds."
msgstr "윈도우에서 생성 시간, 단위는 초."

#: ../Doc/library/os.rst:2440
msgid "Time of most recent access expressed in nanoseconds as an integer."
msgstr "나노초 정수 단위의 가장 최근의 액세스 시간."

#: ../Doc/library/os.rst:2444
msgid ""
"Time of most recent content modification expressed in nanoseconds as an "
"integer."
msgstr "나노초 정수 단위의 가장 최근의 내용 수정 시간."

#: ../Doc/library/os.rst:2452
msgid "the time of creation on Windows, expressed in nanoseconds as an integer."
msgstr "윈도우에서 생성 시간, 단위는 나노초 정수."

#: ../Doc/library/os.rst:2457
msgid ""
"The exact meaning and resolution of the :attr:`st_atime`, "
":attr:`st_mtime`, and :attr:`st_ctime` attributes depend on the operating"
" system and the file system. For example, on Windows systems using the "
"FAT or FAT32 file systems, :attr:`st_mtime` has 2-second resolution, and "
":attr:`st_atime` has only 1-day resolution.  See your operating system "
"documentation for details."
msgstr ""
":attr:`st_atime`, :attr:`st_mtime` 및 :attr:`st_ctime` 어트리뷰트의 정확한 의미와 해상도는"
" 운영 체제와 파일 시스템에 따라 다릅니다. 예를 들어, FAT 또는 FAT32 파일 시스템을 사용하는 윈도우 시스템에서, "
":attr:`st_mtime`\\은 2초 해상도를, :attr:`st_atime`\\는 단지 1일 해상도를 갖습니다. 자세한 내용은"
" 운영 체제 설명서를 참조하십시오."

#: ../Doc/library/os.rst:2464
msgid ""
"Similarly, although :attr:`st_atime_ns`, :attr:`st_mtime_ns`, and "
":attr:`st_ctime_ns` are always expressed in nanoseconds, many systems do "
"not provide nanosecond precision.  On systems that do provide nanosecond "
"precision, the floating-point object used to store :attr:`st_atime`, "
":attr:`st_mtime`, and :attr:`st_ctime` cannot preserve all of it, and as "
"such will be slightly inexact. If you need the exact timestamps you "
"should always use :attr:`st_atime_ns`, :attr:`st_mtime_ns`, and "
":attr:`st_ctime_ns`."
msgstr ""
"마찬가지로, :attr:`st_atime_ns`, :attr:`st_mtime_ns` 및 :attr:`st_ctime_ns`\\가 "
"항상 나노초 단위로 표시되지만, 많은 시스템은 나노초 정밀도를 제공하지 않습니다. 나노초 정밀도를 제공하는 시스템에서, "
":attr:`st_atime`, :attr:`st_mtime` 및 :attr:`st_ctime`\\를 저장하는 데 사용되는 부동 "
"소수점 객체는, 이 값을 모두 보존할 수 없으므로, 약간 부정확합니다. 정확한 타임스탬프가 필요하면, 항상 "
":attr:`st_atime_ns`, :attr:`st_mtime_ns` 및 :attr:`st_ctime_ns`\\를 사용해야 "
"합니다."

#: ../Doc/library/os.rst:2473
msgid ""
"On some Unix systems (such as Linux), the following attributes may also "
"be available:"
msgstr "(리눅스와 같은) 일부 유닉스 시스템에서는, 다음 어트리뷰트도 사용할 수 있습니다:"

#: ../Doc/library/os.rst:2478
msgid ""
"Number of 512-byte blocks allocated for file. This may be smaller than "
":attr:`st_size`/512 when the file has holes."
msgstr "파일에 할당된 512-바이트 블록 수. 파일에 구멍이 있으면 :attr:`st_size`/512보다 작을 수 있습니다."

#: ../Doc/library/os.rst:2483
msgid ""
"\"Preferred\" blocksize for efficient file system I/O. Writing to a file "
"in smaller chunks may cause an inefficient read-modify-rewrite."
msgstr ""
"효율적인 파일 시스템 I/O를 위해 \"선호되는\" 블록 크기. 더 작은 크기로 파일에 기록하면 비효율적인 읽기-수정-다시 쓰기가 "
"발생할 수 있습니다."

#: ../Doc/library/os.rst:2488
msgid "Type of device if an inode device."
msgstr "아이노드 장치면 장치 유형."

#: ../Doc/library/os.rst:2492
msgid "User defined flags for file."
msgstr "파일에 대한 사용자 정의 플래그."

#: ../Doc/library/os.rst:2494
msgid ""
"On other Unix systems (such as FreeBSD), the following attributes may be "
"available (but may be only filled out if root tries to use them):"
msgstr ""
"(FreeBSD와 같은) 다른 유닉스 시스템에서는, 다음 어트리뷰트를 사용할 수 있습니다 (그러나 root가 사용하려고 할 때만 "
"채워질 수 있습니다):"

#: ../Doc/library/os.rst:2499
msgid "File generation number."
msgstr "파일 생성 번호."

#: ../Doc/library/os.rst:2503
msgid "Time of file creation."
msgstr "파일 생성 시간."

#: ../Doc/library/os.rst:2505
msgid ""
"On Solaris and derivatives, the following attributes may also be "
"available:"
msgstr "Solaris 및 파생 상품에서, 다음 어트리뷰트도 사용할 수 있습니다:"

#: ../Doc/library/os.rst:2510
msgid ""
"String that uniquely identifies the type of the filesystem that contains "
"the file."
msgstr "파일을 포함하는 파일 시스템의 유형을 고유하게 식별하는 문자열."

#: ../Doc/library/os.rst:2513
msgid "On Mac OS systems, the following attributes may also be available:"
msgstr "맥 OS 시스템에서는, 다음 어트리뷰트도 사용할 수 있습니다:"

#: ../Doc/library/os.rst:2517
msgid "Real size of the file."
msgstr "파일의 실제 크기."

#: ../Doc/library/os.rst:2521
msgid "Creator of the file."
msgstr "파일의 생성자."

#: ../Doc/library/os.rst:2525
msgid "File type."
msgstr "파일 유형."

#: ../Doc/library/os.rst:2527
msgid "On Windows systems, the following attribute is also available:"
msgstr "윈도우 시스템에서는, 다음 어트리뷰트도 사용할 수도 있습니다:"

#: ../Doc/library/os.rst:2531
msgid ""
"Windows file attributes: ``dwFileAttributes`` member of the "
"``BY_HANDLE_FILE_INFORMATION`` structure returned by "
":c:func:`GetFileInformationByHandle`. See the ``FILE_ATTRIBUTE_*`` "
"constants in the :mod:`stat` module."
msgstr ""
"윈도우 파일 어트리뷰트: :c:func:`GetFileInformationByHandle`\\에 의해 반환된 "
"``BY_HANDLE_FILE_INFORMATION`` 구조체의 ``dwFileAttributes`` 멤버. :mod:`stat` "
"모듈의 ``FILE_ATTRIBUTE_*`` 상수를 참조하십시오."

#: ../Doc/library/os.rst:2536
msgid ""
"The standard module :mod:`stat` defines functions and constants that are "
"useful for extracting information from a :c:type:`stat` structure. (On "
"Windows, some items are filled with dummy values.)"
msgstr ""
"표준 모듈 :mod:`stat`\\는 :c:type:`stat` 구조체에서 정보를 추출하는 데 유용한 함수와 상수를 정의합니다. "
"(윈도우에서는, 일부 항목에 더미 값이 채워집니다.)"

#: ../Doc/library/os.rst:2540
msgid ""
"For backward compatibility, a :class:`stat_result` instance is also "
"accessible as a tuple of at least 10 integers giving the most important "
"(and portable) members of the :c:type:`stat` structure, in the order "
":attr:`st_mode`, :attr:`st_ino`, :attr:`st_dev`, :attr:`st_nlink`, "
":attr:`st_uid`, :attr:`st_gid`, :attr:`st_size`, :attr:`st_atime`, "
":attr:`st_mtime`, :attr:`st_ctime`. More items may be added at the end by"
" some implementations. For compatibility with older Python versions, "
"accessing :class:`stat_result` as a tuple always returns integers."
msgstr ""
"이전 버전과의 호환성을 위해, :class:`stat_result` 인스턴스는 :c:type:`stat` 구조체의 가장 중요한 "
"(그리고 이식성 있는) 멤버를 제공하는 최소 10개의 정수로 구성된 튜플로 액세스할 수도 있는데, :attr:`st_mode`, "
":attr:`st_ino`, :attr:`st_dev`, :attr:`st_nlink`, :attr:`st_uid`, "
":attr:`st_gid`, :attr:`st_size`, :attr:`st_atime`, :attr:`st_mtime`, "
":attr:`st_ctime` 순서입니다. 일부 구현에서는 끝에 더 많은 항목을 추가 할 수 있습니다. 이전 버전의 파이썬과의 "
"호환성을 위해, :class:`stat_result`\\에 튜플로 액세스하면 항상 정수가 반환됩니다."

#: ../Doc/library/os.rst:2549
msgid ""
"Added the :attr:`st_atime_ns`, :attr:`st_mtime_ns`, and "
":attr:`st_ctime_ns` members."
msgstr ""
":attr:`st_atime_ns`, :attr:`st_mtime_ns` 및 :attr:`st_ctime_ns` 멤버가 "
"추가되었습니다."

#: ../Doc/library/os.rst:2553
msgid "Added the :attr:`st_file_attributes` member on Windows."
msgstr "윈도우에서 :attr:`st_file_attributes` 멤버를 추가했습니다."

#: ../Doc/library/os.rst:2556
msgid "Windows now returns the file index as :attr:`st_ino` when available."
msgstr "윈도우는 이제 사용 가능할 때 파일 인덱스를 :attr:`st_ino`\\로 반환합니다."

#: ../Doc/library/os.rst:2560
msgid "Added the :attr:`st_fstype` member to Solaris/derivatives."
msgstr "Solaris/파생 제품에 :attr:`st_fstype` 멤버를 추가했습니다."

#: ../Doc/library/os.rst:2565
msgid ""
"Perform a :c:func:`statvfs` system call on the given path.  The return "
"value is an object whose attributes describe the filesystem on the given "
"path, and correspond to the members of the :c:type:`statvfs` structure, "
"namely: :attr:`f_bsize`, :attr:`f_frsize`, :attr:`f_blocks`, "
":attr:`f_bfree`, :attr:`f_bavail`, :attr:`f_files`, :attr:`f_ffree`, "
":attr:`f_favail`, :attr:`f_flag`, :attr:`f_namemax`, :attr:`f_fsid`."
msgstr ""
"주어진 경로에 대해 :c:func:`statvfs` 시스템 호출을 수행합니다. 반환 값은 주어진 경로의 파일 시스템을 설명하는 "
"객체인데, 어트리뷰트가 :c:type:`statvfs` 구조체의 멤버인 :attr:`f_bsize`, "
":attr:`f_frsize`, :attr:`f_blocks`, :attr:`f_bfree`, :attr:`f_bavail`, "
":attr:`f_files`, :attr:`f_ffree`, :attr:`f_favail`, :attr:`f_flag`, "
":attr:`f_namemax`, :attr:`f_fsid`\\에 해당합니다."

#: ../Doc/library/os.rst:2572
msgid ""
"Two module-level constants are defined for the :attr:`f_flag` attribute's"
" bit-flags: if :const:`ST_RDONLY` is set, the filesystem is mounted read-"
"only, and if :const:`ST_NOSUID` is set, the semantics of setuid/setgid "
"bits are disabled or not supported."
msgstr ""
":attr:`f_flag` 어트리뷰트의 비트 플래그에 대해 두 개의 모듈 수준 상수가 정의됩니다: "
":const:`ST_RDONLY`\\가 설정되면, 파일 시스템은 읽기 전용으로 마운트되었고, :const:`ST_NOSUID`\\가"
" 설정되면, setuid/setgid 비트의 의미가 비활성화되었거나 지원되지 않습니다."

#: ../Doc/library/os.rst:2577
msgid ""
"Additional module-level constants are defined for GNU/glibc based "
"systems. These are :const:`ST_NODEV` (disallow access to device special "
"files), :const:`ST_NOEXEC` (disallow program execution), "
":const:`ST_SYNCHRONOUS` (writes are synced at once), :const:`ST_MANDLOCK`"
" (allow mandatory locks on an FS), :const:`ST_WRITE` (write on "
"file/directory/symlink), :const:`ST_APPEND` (append-only file), "
":const:`ST_IMMUTABLE` (immutable file), :const:`ST_NOATIME` (do not "
"update access times), :const:`ST_NODIRATIME` (do not update directory "
"access times), :const:`ST_RELATIME` (update atime relative to "
"mtime/ctime)."
msgstr ""
"추가적인 모듈 수준 상수가 GNU/glibc 기반 시스템에 대해 정의됩니다. 이들은 :const:`ST_NODEV` (장치 특수 "
"파일에 대한 액세스 금지), :const:`ST_NOEXEC` (프로그램 실행 금지), :const:`ST_SYNCHRONOUS` "
"(한 번에 쓰기 동기화), :const:`ST_MANDLOCK` (FS에 필수 잠금 허용), :const:`ST_WRITE` "
"(파일/디렉터리/심볼릭 링크 쓰기), :const:`ST_APPEND` (덧붙이기 전용 파일), "
":const:`ST_IMMUTABLE` (불변 파일), :const:`ST_NOATIME` (액세스 시간을 갱신하지 않음), "
":const:`ST_NODIRATIME` (디렉터리 액세스 시간을 갱신하지 않음), :const:`ST_RELATIME` "
"(mtime/ctime에 상대적으로 atime을 갱신)."

#: ../Doc/library/os.rst:2590
msgid "The :const:`ST_RDONLY` and :const:`ST_NOSUID` constants were added."
msgstr ":const:`ST_RDONLY` 및 :const:`ST_NOSUID` 상수가 추가되었습니다."

#: ../Doc/library/os.rst:2596
msgid ""
"The :const:`ST_NODEV`, :const:`ST_NOEXEC`, :const:`ST_SYNCHRONOUS`, "
":const:`ST_MANDLOCK`, :const:`ST_WRITE`, :const:`ST_APPEND`, "
":const:`ST_IMMUTABLE`, :const:`ST_NOATIME`, :const:`ST_NODIRATIME`, and "
":const:`ST_RELATIME` constants were added."
msgstr ""
":const:`ST_NODEV`, :const:`ST_NOEXEC`, :const:`ST_SYNCHRONOUS`, "
":const:`ST_MANDLOCK`, :const:`ST_WRITE`, :const:`ST_APPEND`, "
":const:`ST_IMMUTABLE`, :const:`ST_NOATIME`, :const:`ST_NODIRATIME` 및 "
":const:`ST_RELATIME` 상수가 추가되었습니다."

#: ../Doc/library/os.rst:2605
msgid "Added :attr:`f_fsid`."
msgstr ":attr:`f_fsid` 추가."

#: ../Doc/library/os.rst:2611
msgid ""
"A :class:`~collections.abc.Set` object indicating which functions in the "
":mod:`os` module permit use of their *dir_fd* parameter.  Different "
"platforms provide different functionality, and an option that might work "
"on one might be unsupported on another.  For consistency's sakes, "
"functions that support *dir_fd* always allow specifying the parameter, "
"but will raise an exception if the functionality is not actually "
"available."
msgstr ""
":mod:`os` 모듈의 어떤 함수가 *dir_fd* 매개 변수의 사용을 허용하는지를 나타내는 "
":class:`~collections.abc.Set` 객체입니다. 플랫폼마다 다른 기능을 제공하며, 한 플랫폼에서 작동할 수 있는 "
"옵션은 다른 플랫폼에서 지원되지 않을 수 있습니다. 일관성을 위해, *dir_fd* 를 지원하는 함수는 항상 매개 변수를 지정할 수"
" 있도록 하지만, 기능을 실제로 사용할 수 없으면 예외를 발생시킵니다."

#: ../Doc/library/os.rst:2618
msgid ""
"To check whether a particular function permits use of its *dir_fd* "
"parameter, use the ``in`` operator on ``supports_dir_fd``.  As an "
"example, this expression determines whether the *dir_fd* parameter of "
":func:`os.stat` is locally available::"
msgstr ""
"특정 함수가 *dir_fd* 매개 변수의 사용을 허용하는지를 확인하려면, ``supports_dir_fd``\\에 ``in`` "
"연산자를 사용하십시오. 예를 들어, 이 표현식은 :func:`os.stat`\\의 *dir_fd* 매개 변수가 로컬에서 사용 "
"가능한지를 판별합니다::"

#: ../Doc/library/os.rst:2625
msgid ""
"Currently *dir_fd* parameters only work on Unix platforms; none of them "
"work on Windows."
msgstr "현재 *dir_fd* 매개 변수는 유닉스 플랫폼에서만 작동합니다; 어느 것도 윈도우에서 작동하지 않습니다."

#: ../Doc/library/os.rst:2633
msgid ""
"A :class:`~collections.abc.Set` object indicating which functions in the "
":mod:`os` module permit use of the *effective_ids* parameter for "
":func:`os.access`.  If the local platform supports it, the collection "
"will contain :func:`os.access`, otherwise it will be empty."
msgstr ""
":mod:`os` 모듈의 어떤 함수가 :func:`os.access`\\의 *effective_ids* 매개 변수의 사용을 "
"허용하지를 나타내는 :class:`~collections.abc.Set` 객체입니다. 로컬 플랫폼이 지원하면, 컬렉션에 "
":func:`os.access`\\가 포함되고, 그렇지 않으면 비어있게 됩니다."

#: ../Doc/library/os.rst:2638
msgid ""
"To check whether you can use the *effective_ids* parameter for "
":func:`os.access`, use the ``in`` operator on ``supports_effective_ids``,"
" like so::"
msgstr ""
":func:`os.access`\\에 *effective_ids* 매개 변수를 사용할 수 있는지 확인하려면, "
"``supports_effective_ids``\\에 ``in`` 연산자를 사용하십시오. 예를 들면 다음과 같습니다::"

#: ../Doc/library/os.rst:2644
msgid ""
"Currently *effective_ids* only works on Unix platforms; it does not work "
"on Windows."
msgstr "현재 *effective_ids* 는 유닉스 플랫폼에서만 작동합니다; 윈도우에서는 작동하지 않습니다."

#: ../Doc/library/os.rst:2652
msgid ""
"A :class:`~collections.abc.Set` object indicating which functions in the "
":mod:`os` module permit specifying their *path* parameter as an open file"
" descriptor.  Different platforms provide different functionality, and an"
" option that might work on one might be unsupported on another.  For "
"consistency's sakes, functions that support *fd* always allow specifying "
"the parameter, but will raise an exception if the functionality is not "
"actually available."
msgstr ""
":mod:`os` 모듈의 어떤 함수가 자신의 *path* 매개 변수에 열린 파일 기술자를 지정하는 것을 허용하는지를 나타내는 "
":class:`~collections.abc.Set` 객체입니다. 플랫폼마다 다른 기능을 제공하며, 한 플랫폼에서 작동할 수 있는 "
"옵션은 다른 플랫폼에서 지원되지 않을 수 있습니다. 일관성을 위해, *fd* 를 지원하는 함수는 항상 매개 변수를 지정할 수 있도록"
" 하지만, 기능을 실제로 사용할 수 없으면 예외를 발생시킵니다."

#: ../Doc/library/os.rst:2660
msgid ""
"To check whether a particular function permits specifying an open file "
"descriptor for its *path* parameter, use the ``in`` operator on "
"``supports_fd``. As an example, this expression determines whether "
":func:`os.chdir` accepts open file descriptors when called on your local "
"platform::"
msgstr ""
"특정 함수가 *path* 매개 변수에 열린 파일 기술자를 지정할 수 있도록 허용하는지를 확인하려면, "
"``supports_fd``\\에 ``in`` 연산자를 사용하십시오. 예를 들어, 이 표현식은 로컬 플랫폼에서 "
":func:`os.chdir`\\가 호출될 때 열린 파일 기술자를 받아들이는지를 판별합니다::"

#: ../Doc/library/os.rst:2673
msgid ""
"A :class:`~collections.abc.Set` object indicating which functions in the "
":mod:`os` module permit use of their *follow_symlinks* parameter.  "
"Different platforms provide different functionality, and an option that "
"might work on one might be unsupported on another.  For consistency's "
"sakes, functions that support *follow_symlinks* always allow specifying "
"the parameter, but will raise an exception if the functionality is not "
"actually available."
msgstr ""
":mod:`os` 모듈의 어떤 함수가 *follow_symlinks* 매개 변수의 사용을 허용하는지를 나타내는 "
":class:`~collections.abc.Set` 객체입니다. 플랫폼마다 다른 기능을 제공하며, 한 플랫폼에서 작동할 수 있는 "
"옵션은 다른 플랫폼에서 지원되지 않을 수 있습니다. 일관성을 위해, *follow_symlinks* 를 지원하는 함수는 항상 매개 "
"변수를 지정할 수 있도록 하지만, 기능을 실제로 사용할 수 없으면 예외를 발생시킵니다."

#: ../Doc/library/os.rst:2680
msgid ""
"To check whether a particular function permits use of its "
"*follow_symlinks* parameter, use the ``in`` operator on "
"``supports_follow_symlinks``.  As an example, this expression determines "
"whether the *follow_symlinks* parameter of :func:`os.stat` is locally "
"available::"
msgstr ""
"특정 함수가 *follow_symlinks* 매개 변수의 사용을 허용하는지를 확인하려면, "
"``supports_follow_symlinks``\\에 ``in`` 연산자를 사용하십시오. 예를 들어, 이 표현식은 "
":func:`os.stat`\\의 *follow_symlinks* 매개 변수가 로컬에서 사용 가능한지를 판별합니다::"

#: ../Doc/library/os.rst:2692
msgid "Create a symbolic link pointing to *src* named *dst*."
msgstr "*src를* 가리키는 *dst* 라는 이름의 심볼릭 링크를 만듭니다."

#: ../Doc/library/os.rst:2694
msgid ""
"On Windows, a symlink represents either a file or a directory, and does "
"not morph to the target dynamically.  If the target is present, the type "
"of the symlink will be created to match. Otherwise, the symlink will be "
"created as a directory if *target_is_directory* is ``True`` or a file "
"symlink (the default) otherwise.  On non-Windows platforms, "
"*target_is_directory* is ignored."
msgstr ""
"윈도우에서, 심볼릭 링크는 파일이나 디렉터리를 나타내며, 동적으로 대상에 맞춰 변형되지 않습니다. 대상이 있으면, 일치하도록 심볼릭"
" 링크의 유형이 만들어집니다. 그렇지 않으면, *target_is_directory* 가 ``True`` 면 심볼릭 링크가 "
"디렉터리로 만들어지고, 그렇지 않으면 파일 심볼릭 링크(기본값)가 만들어집니다. 비 윈도우 플랫폼에서는 "
"*target_is_directory* 가 무시됩니다."

#: ../Doc/library/os.rst:2700
msgid ""
"Symbolic link support was introduced in Windows 6.0 (Vista).  "
":func:`symlink` will raise a :exc:`NotImplementedError` on Windows "
"versions earlier than 6.0."
msgstr ""
"심볼릭 링크 지원은 윈도우 6.0(Vista)에서 소개되었습니다. :func:`symlink`\\는 6.0 이전의 윈도우 버전에서 "
":exc:`NotImplementedError`\\를 발생시킵니다."

#: ../Doc/library/os.rst:2708
msgid ""
"On Windows, the *SeCreateSymbolicLinkPrivilege* is required in order to "
"successfully create symlinks. This privilege is not typically granted to "
"regular users but is available to accounts which can escalate privileges "
"to the administrator level. Either obtaining the privilege or running "
"your application as an administrator are ways to successfully create "
"symlinks."
msgstr ""
"윈도우에서, 심볼릭 링크를 성공적으로 만들려면 *SeCreateSymbolicLinkPrivilege* 가 필요합니다. 이 권한은 "
"보통 일반 사용자에게는 부여되지 않지만, 관리자 수준으로 권한을 상승시킬 수 있는 계정에서는 사용할 수 있습니다. 권한을 얻거나 "
"응용 프로그램을 관리자로 실행하는 것은 심볼릭 링크를 성공적으로 만들 방법입니다."

#: ../Doc/library/os.rst:2715
msgid ""
":exc:`OSError` is raised when the function is called by an unprivileged "
"user."
msgstr "권한이 없는 사용자가 함수를 호출하면 :exc:`OSError`\\가 발생합니다."

#: ../Doc/library/os.rst:2723
msgid ""
"Added the *dir_fd* argument, and now allow *target_is_directory* on non-"
"Windows platforms."
msgstr "*dir_fd* 인자를 추가했으며, 이제 비 윈도우 플랫폼에서 *target_is_directory* 를 허용합니다."

#: ../Doc/library/os.rst:2733
msgid "Force write of everything to disk."
msgstr "디스크에 모든 것을 쓰도록 강제합니다."

#: ../Doc/library/os.rst:2742
msgid ""
"Truncate the file corresponding to *path*, so that it is at most *length*"
" bytes in size."
msgstr "최대 *length* 바이트가 되도록 *path*\\에 해당하는 파일을 자릅니다."

#: ../Doc/library/os.rst:2760
msgid ""
"Remove (delete) the file *path*.  This function is semantically identical"
" to :func:`remove`; the ``unlink`` name is its traditional Unix name.  "
"Please see the documentation for :func:`remove` for further information."
msgstr ""
"파일 *path*\\를 제거(삭제)합니다. 이 함수는 의미상 :func:`remove`\\와 같습니다; ``unlink`` 라는 "
"이름은 전통적인 유닉스 이름입니다. 자세한 내용은 :func:`remove` 설명서를 참조하십시오."

#: ../Doc/library/os.rst:2774
msgid "Set the access and modified times of the file specified by *path*."
msgstr "*path*\\로 지정된 파일의 액세스 및 수정 시간을 설정합니다."

#: ../Doc/library/os.rst:2776
msgid ""
":func:`utime` takes two optional parameters, *times* and *ns*. These "
"specify the times set on *path* and are used as follows:"
msgstr ""
":func:`utime`\\은 *times* 과 *ns* 라는 두 개의 선택적 매개 변수를 취합니다. *path*\\에 설정할 "
"시간을 지정하며 다음과 같이 사용됩니다:"

#: ../Doc/library/os.rst:2779
msgid ""
"If *ns* is specified, it must be a 2-tuple of the form ``(atime_ns, "
"mtime_ns)`` where each member is an int expressing nanoseconds."
msgstr ""
"*ns* 가 지정되면, ``(atime_ns, mtime_ns)`` 형식의 2-튜플이어야 하며, 각 멤버는 나노초를 나타내는 "
"int입니다."

#: ../Doc/library/os.rst:2782
msgid ""
"If *times* is not ``None``, it must be a 2-tuple of the form ``(atime, "
"mtime)`` where each member is an int or float expressing seconds."
msgstr ""
"*times* 가 ``None``\\이 아니면, ``(atime, mtime)`` 형식의 2-튜플이어야 하며, 각 멤버는 초를 "
"나타내는 int 또는 float입니다."

#: ../Doc/library/os.rst:2785
msgid ""
"If *times* is ``None`` and *ns* is unspecified, this is equivalent to "
"specifying ``ns=(atime_ns, mtime_ns)`` where both times are the current "
"time."
msgstr ""
"*times* 가 ``None``\\이고 *ns* 가 지정되지 않으면, ``ns=(atime_ns, mtime_ns)``\\를 "
"지정하는 것과 같은데, 두 시간 모두 현재 시각입니다."

#: ../Doc/library/os.rst:2789
msgid "It is an error to specify tuples for both *times* and *ns*."
msgstr "*times* 와 *ns*\\에 모두 튜플을 지정하는 것은 에러입니다."

#: ../Doc/library/os.rst:2791
msgid ""
"Whether a directory can be given for *path* depends on whether the "
"operating system implements directories as files (for example, Windows "
"does not).  Note that the exact times you set here may not be returned by"
" a subsequent :func:`~os.stat` call, depending on the resolution with "
"which your operating system records access and modification times; see "
":func:`~os.stat`.  The best way to preserve exact times is to use the "
"*st_atime_ns* and *st_mtime_ns* fields from the :func:`os.stat` result "
"object with the *ns* parameter to `utime`."
msgstr ""
"디렉터리가 *path* 로 제공될 수 있는지는 운영 체제가 디렉터리를 파일로 구현하는지에 따라 다릅니다 (예를 들어, 윈도우는 "
"그렇지 않습니다). 여기서 설정한 정확한 시간은 운영 체제가 액세스 및 수정 시간을 기록하는 해상도에 따라 뒤따르는 "
":func:`~os.stat` 호출에서 반환되지 않을 수 있음에 주의해야 합니다; :func:`~os.stat`\\를 참조하세요. "
"정확한 시간을 보존하는 가장 좋은 방법은 `utime` 의 *ns* 매개 변수에 :func:`os.stat` 결과 객체의 "
"*st_atime_ns* 및 *st_mtime_ns* 필드를 사용하는 것입니다."

#: ../Doc/library/os.rst:2804
msgid ""
"Added support for specifying an open file descriptor for *path*, and the "
"*dir_fd*, *follow_symlinks*, and *ns* parameters."
msgstr ""
"*path*\\에 열린 파일 기술자를 지정하는 것과 *dir_fd* , *follow_symlinks* 및 *ns* 매개 변수 "
"지원이 추가되었습니다."

#: ../Doc/library/os.rst:2818
msgid ""
"Generate the file names in a directory tree by walking the tree either "
"top-down or bottom-up. For each directory in the tree rooted at directory"
" *top* (including *top* itself), it yields a 3-tuple ``(dirpath, "
"dirnames, filenames)``."
msgstr ""
"트리를 하향식 또는 상향식으로 탐색하여 디렉터리 트리에 있는 파일명을 생성합니다. 디렉터리 *top*\\을 루트로 하는 트리의 "
"디렉터리(*top* 자체를 포함합니다)마다, 3-튜플 ``(dirpath, dirnames, filenames)``\\를 "
"산출합니다."

#: ../Doc/library/os.rst:2823
msgid ""
"*dirpath* is a string, the path to the directory.  *dirnames* is a list "
"of the names of the subdirectories in *dirpath* (excluding ``'.'`` and "
"``'..'``). *filenames* is a list of the names of the non-directory files "
"in *dirpath*. Note that the names in the lists contain no path "
"components.  To get a full path (which begins with *top*) to a file or "
"directory in *dirpath*, do ``os.path.join(dirpath, name)``."
msgstr ""
"*dirpath* 는 디렉터리 경로인 문자열입니다. *dirnames* 는 *dirpath* 의 하위 디렉터리 이름 리스트입니다 "
"(``'.'`` 및 ``'..'`` 제외). *filenames* 는 *dirpath*\\에 있는 디렉터리가 아닌 파일의 이름 "
"리스트입니다. 리스트에 들어있는 이름에는 경로 구성 요소가 들어 있지 않음에 유의하십시오. *dirpath* 에 있는 파일이나 "
"디렉터리에 대한 전체 경로(*top*\\으로 시작하는)를 얻으려면, ``os.path.join(dirpath, name)``\\을 "
"수행하십시오."

#: ../Doc/library/os.rst:2830
msgid ""
"If optional argument *topdown* is ``True`` or not specified, the triple "
"for a directory is generated before the triples for any of its "
"subdirectories (directories are generated top-down).  If *topdown* is "
"``False``, the triple for a directory is generated after the triples for "
"all of its subdirectories (directories are generated bottom-up). No "
"matter the value of *topdown*, the list of subdirectories is retrieved "
"before the tuples for the directory and its subdirectories are generated."
msgstr ""
"선택적 인자 *topdown* 이 ``True``\\이거나 지정되지 않으면, 디렉터리에 대한 3-튜플은 하위 디렉터리에 대한 "
"3-튜플이 생성되기 전에 생성됩니다 (디렉터리는 하향식으로 생성됩니다). *topdown* 이 ``False``\\면, 모든 하위 "
"디렉터리에 대한 3-튜플 다음에 디렉터리에 대한 3-튜플이 생성됩니다 (디렉터리가 상향식으로 생성됨). *topdown* 의 값에 "
"상관없이, 디렉터리와 해당 하위 디렉터리의 튜플이 생성되기 전에 하위 디렉터리 목록이 조회됩니다."

#: ../Doc/library/os.rst:2838
msgid ""
"When *topdown* is ``True``, the caller can modify the *dirnames* list in-"
"place (perhaps using :keyword:`del` or slice assignment), and "
":func:`walk` will only recurse into the subdirectories whose names remain"
" in *dirnames*; this can be used to prune the search, impose a specific "
"order of visiting, or even to inform :func:`walk` about directories the "
"caller creates or renames before it resumes :func:`walk` again.  "
"Modifying *dirnames* when *topdown* is ``False`` has no effect on the "
"behavior of the walk, because in bottom-up mode the directories in "
"*dirnames* are generated before *dirpath* itself is generated."
msgstr ""
"*topdown* 이 ``True`` 일 때, 호출자는 (아마도 :keyword:`del` 또는 슬라이스 대입을 사용하여) "
"*dirnames* 리스트를 수정할 수 있으며, :func:`walk`\\는 이름이 *dirnames* 남아있는 하위 디렉터리로만 "
"재귀합니다; 검색을 가지치기하거나, 특정 방문 순서를 지정하거나, 심지어 :func:`walk`\\가 다시 시작하기 전에 호출자가 "
"새로 만들거나 이름을 바꾼 디렉터리에 대해 :func:`walk`\\에 알릴 때도 사용할 수 있습니다. *topdown* 이 "
"``False``\\일 때 *dirnames*\\를 수정하는 것은 walk의 동작에 영향을 주지 못하는데, 상향식 모드에서 "
"*dirnames*\\의 디렉터리는 *dirpath* 자체가 생성되기 전에 생성되기 때문입니다."

#: ../Doc/library/os.rst:2847
msgid ""
"By default, errors from the :func:`scandir` call are ignored.  If "
"optional argument *onerror* is specified, it should be a function; it "
"will be called with one argument, an :exc:`OSError` instance.  It can "
"report the error to continue with the walk, or raise the exception to "
"abort the walk.  Note that the filename is available as the ``filename`` "
"attribute of the exception object."
msgstr ""
"기본적으로, :func:`scandir` 호출의 에러는 무시됩니다. 선택적 인자 *onerror* 가 지정되면, 함수여야 합니다; "
"하나의 인자 :exc:`OSError` 인스턴스로 호출됩니다. 에러를 보고하고 walk를 계속하도록 하거나, 예외를 발생시켜 "
"walk를 중단할 수 있습니다. 파일명은 예외 객체의 ``filename`` 어트리뷰트로 제공됩니다."

#: ../Doc/library/os.rst:2853
msgid ""
"By default, :func:`walk` will not walk down into symbolic links that "
"resolve to directories. Set *followlinks* to ``True`` to visit "
"directories pointed to by symlinks, on systems that support them."
msgstr ""
"기본적으로, :func:`walk`\\는 디렉터리로 해석되는 심볼릭 링크로 이동하지 않습니다. 지원하는 시스템에서, 심볼릭 링크가 "
"가리키는 디렉터리를 방문하려면, *followlinks*\\를 ``True``\\로 설정하십시오."

#: ../Doc/library/os.rst:2859
msgid ""
"Be aware that setting *followlinks* to ``True`` can lead to infinite "
"recursion if a link points to a parent directory of itself. :func:`walk` "
"does not keep track of the directories it visited already."
msgstr ""
"심볼릭 링크가 자신의 부모 디렉터리를 가리킬 때, *followlinks*\\를 ``True``\\로 설정하면 무한 재귀가 발생할 "
"수 있음에 주의해야 합니다. :func:`walk`\\는 이미 방문한 디렉터리를 추적하지 않습니다."

#: ../Doc/library/os.rst:2865
msgid ""
"If you pass a relative pathname, don't change the current working "
"directory between resumptions of :func:`walk`.  :func:`walk` never "
"changes the current directory, and assumes that its caller doesn't "
"either."
msgstr ""
"상대 경로명을 전달할 때는, :func:`walk`\\가 실행되는 도중 현재 작업 디렉터리를 변경하지 마십시오. "
":func:`walk`\\는 현재 디렉터리를 절대로 변경하지 않으며, 호출자도 마찬가지라고 가정합니다."

#: ../Doc/library/os.rst:2869 ../Doc/library/os.rst:2928
msgid ""
"This example displays the number of bytes taken by non-directory files in"
" each directory under the starting directory, except that it doesn't look"
" under any CVS subdirectory::"
msgstr ""
"이 예는 시작 디렉터리 아래의 각 디렉터리에 있는 비 디렉터리 파일이 차지한 바이트 수를 표시합니다. 단, CVS 하위 디렉터리 "
"아래는 보지 않습니다::"

#: ../Doc/library/os.rst:2882
msgid ""
"In the next example (simple implementation of :func:`shutil.rmtree`), "
"walking the tree bottom-up is essential, :func:`rmdir` doesn't allow "
"deleting a directory before the directory is empty::"
msgstr ""
"다음 예(:func:`shutil.rmtree`\\의 간단한 구현)에서는, 트리를 상향식으로 탐색하는 것이 필수적입니다, "
":func:`rmdir`\\는 비어 있지 않은 디렉터리를 삭제할 수 없습니다::"

#: ../Doc/library/os.rst:2897
msgid ""
"This function now calls :func:`os.scandir` instead of :func:`os.listdir`,"
" making it faster by reducing the number of calls to :func:`os.stat`."
msgstr ""
"이 함수는 이제 :func:`os.listdir` 대신 :func:`os.scandir`\\를 호출하기 때문에, "
":func:`os.stat` 호출 수를 줄여 더 빨라졌습니다."

#: ../Doc/library/os.rst:2911
msgid ""
"This behaves exactly like :func:`walk`, except that it yields a 4-tuple "
"``(dirpath, dirnames, filenames, dirfd)``, and it supports ``dir_fd``."
msgstr ""
"이 함수는 :func:`walk`\\와 똑같이 동작합니다. 단, 4-튜플 ``(dirpath, dirnames, filenames,"
" dirfd)``\\를 산출하고 ``dir_fd``\\를 지원합니다."

#: ../Doc/library/os.rst:2914
msgid ""
"*dirpath*, *dirnames* and *filenames* are identical to :func:`walk` "
"output, and *dirfd* is a file descriptor referring to the directory "
"*dirpath*."
msgstr ""
"*dirpath* , *dirnames* 및 *filenames* 은 :func:`walk` 출력과 같고, *dirfd* 는 "
"*dirpath* 디렉터리를 가리키는 파일 기술자입니다."

#: ../Doc/library/os.rst:2917
msgid ""
"This function always supports :ref:`paths relative to directory "
"descriptors <dir_fd>` and :ref:`not following symlinks "
"<follow_symlinks>`.  Note however that, unlike other functions, the "
":func:`fwalk` default value for *follow_symlinks* is ``False``."
msgstr ""
"이 함수는 항상 :ref:`디렉터리 기술자에 상대적인 경로 <dir_fd>` 및 :ref:`심볼릭 링크를 따르지 않음 "
"<follow_symlinks>`\\을 지원합니다. 하지만, 다른 함수와는 달리, *follow_symlinks*\\에 대한 "
":func:`fwalk`\\의 기본값은 ``False``\\임에 주의하십시오."

#: ../Doc/library/os.rst:2924
msgid ""
"Since :func:`fwalk` yields file descriptors, those are only valid until "
"the next iteration step, so you should duplicate them (e.g. with "
":func:`dup`) if you want to keep them longer."
msgstr ""
":func:`fwalk`\\는 다음 이터레이션 단계까지만 유효한 파일 기술자를 산출하기 때문에, 더 오래 유지하려면 복제해야 합니다"
" (예를 들어, :func:`dup`\\로)."

#: ../Doc/library/os.rst:2941
msgid ""
"In the next example, walking the tree bottom-up is essential: "
":func:`rmdir` doesn't allow deleting a directory before the directory is "
"empty::"
msgstr ""
"다음 예에서는, 트리를 상향식으로 탐색하는 것이 필수적입니다: :func:`rmdir`\\는 비어 있지 않은 디렉터리를 삭제할 수 "
"없습니다::"

#: ../Doc/library/os.rst:2963
msgid "Added support for :class:`bytes` paths."
msgstr ":class:`bytes` 경로에 대한 지원이 추가되었습니다."

#: ../Doc/library/os.rst:2968
msgid "Linux extended attributes"
msgstr "리눅스 확장 어트리뷰트"

#: ../Doc/library/os.rst:2972
msgid "These functions are all available on Linux only."
msgstr "이 함수들은 모두 리눅스에서만 사용 가능합니다."

#: ../Doc/library/os.rst:2976
msgid ""
"Return the value of the extended filesystem attribute *attribute* for "
"*path*. *attribute* can be bytes or str (directly or indirectly through "
"the :class:`PathLike` interface). If it is str, it is encoded with the "
"filesystem encoding."
msgstr ""
"*path*\\의 확장 파일 시스템 어트리뷰트 *attribute*\\의 값을 반환합니다. *attribute* 는 bytes 또는"
" str(직접 또는 :class:`PathLike` 인터페이스를 통해 간접적으로)일 수 있습니다. str이면, 파일 시스템 "
"인코딩으로 인코딩됩니다."

#: ../Doc/library/os.rst:2984 ../Doc/library/os.rst:3012
#: ../Doc/library/os.rst:3035
msgid "Accepts a :term:`path-like object` for *path* and *attribute*."
msgstr "*path* 및 *attribute*\\에 대해 :term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: ../Doc/library/os.rst:2990
msgid ""
"Return a list of the extended filesystem attributes on *path*.  The "
"attributes in the list are represented as strings decoded with the "
"filesystem encoding.  If *path* is ``None``, :func:`listxattr` will "
"examine the current directory."
msgstr ""
"*path* 의 확장 파일 시스템 어트리뷰트 목록을 반환합니다. 목록의 어트리뷰트는 파일 시스템 인코딩으로 디코딩된 문자열로 "
"표시됩니다. *path* 가 ``None``\\이면, :func:`listxattr`\\는 현재 디렉터리를 검사합니다."

#: ../Doc/library/os.rst:3004
msgid ""
"Removes the extended filesystem attribute *attribute* from *path*. "
"*attribute* should be bytes or str (directly or indirectly through the "
":class:`PathLike` interface). If it is a string, it is encoded with the "
"filesystem encoding."
msgstr ""
"*path* 에서 확장 파일 시스템 어트리뷰트 *attribute* 을 제거합니다. *attribute* 는 bytes 또는 "
"str(직접 또는 :class:`PathLike` 인터페이스를 통해 간접적으로)이어야합니다. 문자열이면, 파일 시스템 인코딩으로 "
"인코딩됩니다."

#: ../Doc/library/os.rst:3018
msgid ""
"Set the extended filesystem attribute *attribute* on *path* to *value*. "
"*attribute* must be a bytes or str with no embedded NULs (directly or "
"indirectly through the :class:`PathLike` interface). If it is a str, it "
"is encoded with the filesystem encoding.  *flags* may be "
":data:`XATTR_REPLACE` or :data:`XATTR_CREATE`. If :data:`XATTR_REPLACE` "
"is given and the attribute does not exist, ``EEXISTS`` will be raised. If"
" :data:`XATTR_CREATE` is given and the attribute already exists, the "
"attribute will not be created and ``ENODATA`` will be raised."
msgstr ""
"*path* 에 있는 확장 파일 시스템 어트리뷰트 *attribute*\\를 *value*\\로 설정합니다. *attribute* "
"는 내장된 NUL이 없는 bytes 또는 str(직접 또는 :class:`PathLike` 인터페이스를 통해 간접적으로)이어야 "
"합니다. str이면, 파일 시스템 인코딩으로 인코딩됩니다. *flags* 는 :data:`XATTR_REPLACE` 또는 "
":data:`XATTR_CREATE` 일 수 있습니다. :data:`XATTR_REPLACE`\\가 주어지고 어트리뷰트가 존재하지 "
"않으면, ``EEXISTS``\\가 발생합니다. :data:`XATTR_CREATE`\\가 주어지고 어트리뷰트가 이미 존재하면, "
"어트리뷰트는 만들어지지 않고 ``ENODATA``\\가 발생합니다."

#: ../Doc/library/os.rst:3032
msgid ""
"A bug in Linux kernel versions less than 2.6.39 caused the flags argument"
" to be ignored on some filesystems."
msgstr "리눅스 커널 버전 2.6.39 미만의 버그로 인해 flags 인자가 일부 파일 시스템에서 무시되었습니다."

#: ../Doc/library/os.rst:3041
msgid ""
"The maximum size the value of an extended attribute can be. Currently, "
"this is 64 KiB on Linux."
msgstr "확장 어트리뷰트 값의 최대 크기입니다. 현재, 리눅스에서 64 KiB입니다."

#: ../Doc/library/os.rst:3047
msgid ""
"This is a possible value for the flags argument in :func:`setxattr`. It "
"indicates the operation must create an attribute."
msgstr ""
"이것은 :func:`setxattr`\\의 flags 인자를 위한 값입니다. 연산이 반드시 어트리뷰트를 새로 만들어야 함을 "
"나타냅니다."

#: ../Doc/library/os.rst:3053
msgid ""
"This is a possible value for the flags argument in :func:`setxattr`. It "
"indicates the operation must replace an existing attribute."
msgstr ""
"이것은 :func:`setxattr`\\의 flags 인자를 위한 값입니다. 연산이 반드시 기존 어트리뷰트를 대체해야 함을 "
"나타냅니다."

#: ../Doc/library/os.rst:3060
msgid "Process Management"
msgstr "프로세스 관리"

#: ../Doc/library/os.rst:3062
msgid "These functions may be used to create and manage processes."
msgstr "이 함수들은 프로세스를 만들고 관리하는데 사용될 수 있습니다."

#: ../Doc/library/os.rst:3064
msgid ""
"The various :func:`exec\\* <execl>` functions take a list of arguments "
"for the new program loaded into the process.  In each case, the first of "
"these arguments is passed to the new program as its own name rather than "
"as an argument a user may have typed on a command line.  For the C "
"programmer, this is the ``argv[0]`` passed to a program's :c:func:`main`."
"  For example, ``os.execv('/bin/echo', ['foo', 'bar'])`` will only print "
"``bar`` on standard output; ``foo`` will seem to be ignored."
msgstr ""
"다양한 :func:`exec\\* <execl>` 함수는 프로세스로 로드되는 새 프로그램에 대한 인자 목록을 받아들입니다. 각각의 "
"경우에, 첫 번째 인자는 사용자가 명령 줄에 입력할 수 있는 인자가 아닌 프로그램 자체의 이름으로 새 프로그램에 전달됩니다. C "
"프로그래머에게, 이것은 프로그램의 :c:func:`main`\\에 전달된 ``argv[0]``\\입니다. 예를 들어, "
"``os.execv('/bin/echo', ['foo', 'bar'])``\\는 표준 출력에 ``bar``\\만 인쇄합니다; "
"``foo``\\는 무시되는 것처럼 보이게 됩니다."

#: ../Doc/library/os.rst:3075
msgid ""
"Generate a :const:`SIGABRT` signal to the current process.  On Unix, the "
"default behavior is to produce a core dump; on Windows, the process "
"immediately returns an exit code of ``3``.  Be aware that calling this "
"function will not call the Python signal handler registered for "
":const:`SIGABRT` with :func:`signal.signal`."
msgstr ""
"현재 프로세스에 :const:`SIGABRT` 시그널을 생성합니다. 유닉스에서, 기본 동작은 코어 덤프를 생성하는 것입니다; "
"윈도우에서, 프로세스는 즉시 종료 코드 ``3``\\을 반환합니다. 이 함수를 호출하면 :func:`signal.signal`\\를"
" 사용하여 :const:`SIGABRT`\\에 등록된 파이썬 시그널 처리기를 호출하지 않게 됨에 주의하시기 바랍니다."

#: ../Doc/library/os.rst:3091
msgid ""
"These functions all execute a new program, replacing the current process;"
" they do not return.  On Unix, the new executable is loaded into the "
"current process, and will have the same process id as the caller.  Errors"
" will be reported as :exc:`OSError` exceptions."
msgstr ""
"이 함수들은 모두 현재 프로세스를 대체해서 새로운 프로그램을 실행합니다; 반환되지 않습니다. 유닉스에서, 새로운 실행 파일이 현재 "
"프로세스에 로드되고, 호출자와 같은 프로세스 ID를 갖게 됩니다. 에러는 :exc:`OSError` 예외로 보고됩니다."

#: ../Doc/library/os.rst:3096
msgid ""
"The current process is replaced immediately. Open file objects and "
"descriptors are not flushed, so if there may be data buffered on these "
"open files, you should flush them using :func:`sys.stdout.flush` or "
":func:`os.fsync` before calling an :func:`exec\\* <execl>` function."
msgstr ""
"현재 프로세스가 즉시 교체됩니다. 열린 파일 객체와 기술자는 플러시 되지 않으므로, 이러한 열린 파일에 버퍼링 된 데이터가 있으면,"
" :func:`exec\\* <execl>` 함수를 호출하기 전에 :func:`sys.stdout.flush` 또는 "
":func:`os.fsync`\\를 사용하여 플러시 해야 합니다."

#: ../Doc/library/os.rst:3102
msgid ""
"The \"l\" and \"v\" variants of the :func:`exec\\* <execl>` functions "
"differ in how command-line arguments are passed.  The \"l\" variants are "
"perhaps the easiest to work with if the number of parameters is fixed "
"when the code is written; the individual parameters simply become "
"additional parameters to the :func:`execl\\*` functions.  The \"v\" "
"variants are good when the number of parameters is variable, with the "
"arguments being passed in a list or tuple as the *args* parameter.  In "
"either case, the arguments to the child process should start with the "
"name of the command being run, but this is not enforced."
msgstr ""
":func:`exec\\* <execl>` 함수의 \"l\" 및 \"v\" 변형은 명령 줄 인자가 전달되는 방식이 다릅니다. "
"\"l\" 변형은 아마도 코드가 작성될 때 매개 변수의 수가 고정되어 있다면 가장 작업하기 쉬운 것입니다; 개별 매개 변수는 단순히"
" :func:`execl\\*` 함수에 대한 추가 매개 변수가 됩니다. \"v\" 변형은 매개 변수의 개수가 가변적일 때 좋으며, "
"리스트나 튜플에 들어있는 인자가 *args* 매개 변수로 전달됩니다. 두 경우 모두, 자식 프로세스에 대한 인자는 실행 중인 명령의"
" 이름으로 시작해야 하지만, 강제되지는 않습니다."

#: ../Doc/library/os.rst:3111
msgid ""
"The variants which include a \"p\" near the end (:func:`execlp`, "
":func:`execlpe`, :func:`execvp`, and :func:`execvpe`) will use the "
":envvar:`PATH` environment variable to locate the program *file*.  When "
"the environment is being replaced (using one of the :func:`exec\\*e "
"<execl>` variants, discussed in the next paragraph), the new environment "
"is used as the source of the :envvar:`PATH` variable. The other variants,"
" :func:`execl`, :func:`execle`, :func:`execv`, and :func:`execve`, will "
"not use the :envvar:`PATH` variable to locate the executable; *path* must"
" contain an appropriate absolute or relative path."
msgstr ""
"끝 근처에 \"p\"가 포함된 변형(:func:`execlp`, :func:`execlpe`, :func:`execvp` 및 "
":func:`execvpe`)은 :envvar:`PATH` 환경 변수를 사용하여 프로그램 *file* 을 찾습니다. 환경이 대체 될"
" 때 (다음 단락에서 설명할 :func:`exec\\*e <execl>` 변형 중 하나를 사용하여), 새 환경이 "
":envvar:`PATH` 변수의 소스로 사용됩니다. 다른 변형 :func:`execl`, :func:`execle`, "
":func:`execv` 및 :func:`execve`\\는 :envvar:`PATH` 변수를 사용하여 실행 파일을 찾지 않습니다;"
" *path* 에는 반드시 적절한 절대 또는 상대 경로가 있어야 합니다."

#: ../Doc/library/os.rst:3121
msgid ""
"For :func:`execle`, :func:`execlpe`, :func:`execve`, and :func:`execvpe` "
"(note that these all end in \"e\"), the *env* parameter must be a mapping"
" which is used to define the environment variables for the new process "
"(these are used instead of the current process' environment); the "
"functions :func:`execl`, :func:`execlp`, :func:`execv`, and "
":func:`execvp` all cause the new process to inherit the environment of "
"the current process."
msgstr ""
":func:`execle`, :func:`execlpe`, :func:`execve`, :func:`execvpe`\\의 경우 "
"(모두 \"e\"로 끝납니다), *env* 매개 변수는 새 프로세스의 환경 변수를 정의하는 데 사용되는 매핑이어야 합니다 (이것이 "
"현재 프로세스의 환경 대신 사용됩니다); 함수 :func:`execl`, :func:`execlp`, :func:`execv` 및 "
":func:`execvp`\\는 모두 새 프로세스가 현재 프로세스의 환경을 상속하게 합니다."

#: ../Doc/library/os.rst:3128
msgid ""
"For :func:`execve` on some platforms, *path* may also be specified as an "
"open file descriptor.  This functionality may not be supported on your "
"platform; you can check whether or not it is available using "
":data:`os.supports_fd`. If it is unavailable, using it will raise a "
":exc:`NotImplementedError`."
msgstr ""
"일부 플랫폼에서 :func:`execve`\\의 경우, *path* 는 열린 파일 기술자로도 지정될 수 있습니다. 이 기능은 "
"여러분의 플랫폼에서 지원되지 않을 수 있습니다; :data:`os.supports_fd`\\를 사용하여 사용할 수 있는지를 확인할 "
"수 있습니다. 사용할 수 없을 때, 이를 사용하면 :exc:`NotImplementedError`\\가 발생합니다."

#: ../Doc/library/os.rst:3135
msgid ""
"Added support for specifying an open file descriptor for *path* for "
":func:`execve`."
msgstr ":func:`execve`\\의 *path*\\에 열린 파일 기술자를 지정하는 지원이 추가되었습니다."

#: ../Doc/library/os.rst:3144
msgid ""
"Exit the process with status *n*, without calling cleanup handlers, "
"flushing stdio buffers, etc."
msgstr ""
"상태 *n*\\으로 프로세스를 종료합니다. 클린업 처리기를 호출하거나, stdio 버퍼를 플러시 하거나 등등은 수행하지 않습니다."

#: ../Doc/library/os.rst:3149
msgid ""
"The standard way to exit is ``sys.exit(n)``.  :func:`_exit` should "
"normally only be used in the child process after a :func:`fork`."
msgstr ""
"종료하는 표준 방법은 ``sys.exit(n)``\\입니다. :func:`_exit`\\는 일반적으로 :func:`fork` 이후의"
" 자식 프로세스에서만 사용해야 합니다."

#: ../Doc/library/os.rst:3152
msgid ""
"The following exit codes are defined and can be used with :func:`_exit`, "
"although they are not required.  These are typically used for system "
"programs written in Python, such as a mail server's external command "
"delivery program."
msgstr ""
"필수 조건은 아니지만, 다음 종료 코드가 정의되어 있으며 :func:`_exit`\\와 함께 사용할 수 있습니다. 이것은 메일 "
"서버의 외부 명령 배달 프로그램과 같이 파이썬으로 작성된 시스템 프로그램에서 일반적으로 사용됩니다."

#: ../Doc/library/os.rst:3158
msgid ""
"Some of these may not be available on all Unix platforms, since there is "
"some variation.  These constants are defined where they are defined by "
"the underlying platform."
msgstr ""
"약간의 차이점이 있어서, 이들 중 일부는 모든 유닉스 플랫폼에서 사용하지는 못할 수 있습니다. 이 상수는 하부 플랫폼에서 정의될 "
"때만 정의됩니다."

#: ../Doc/library/os.rst:3165
msgid "Exit code that means no error occurred."
msgstr "에러가 발생하지 않았음을 나타내는 종료 코드."

#: ../Doc/library/os.rst:3172
msgid ""
"Exit code that means the command was used incorrectly, such as when the "
"wrong number of arguments are given."
msgstr "잘못된 개수의 인자가 제공된 경우처럼, 명령이 잘못 사용되었음을 나타내는 종료 코드."

#: ../Doc/library/os.rst:3180
msgid "Exit code that means the input data was incorrect."
msgstr "입력 데이터가 잘못되었음을 나타내는 종료 코드."

#: ../Doc/library/os.rst:3187
msgid "Exit code that means an input file did not exist or was not readable."
msgstr "입력 파일이 없거나 읽을 수 없음을 나타내는 종료 코드."

#: ../Doc/library/os.rst:3194
msgid "Exit code that means a specified user did not exist."
msgstr "지정된 사용자가 존재하지 않음을 나타내는 종료 코드."

#: ../Doc/library/os.rst:3201
msgid "Exit code that means a specified host did not exist."
msgstr "지정된 호스트가 존재하지 않음을 나타내는 종료 코드."

#: ../Doc/library/os.rst:3208
msgid "Exit code that means that a required service is unavailable."
msgstr "필수 서비스를 사용할 수 없음을 나타내는 종료 코드."

#: ../Doc/library/os.rst:3215
msgid "Exit code that means an internal software error was detected."
msgstr "내부 소프트웨어 에러가 감지되었음을 나타내는 종료 코드."

#: ../Doc/library/os.rst:3222
msgid ""
"Exit code that means an operating system error was detected, such as the "
"inability to fork or create a pipe."
msgstr "포크 하거나 파이프를 만들 수 없는 등, 운영 체제 에러가 감지되었음을 나타내는 종료 코드."

#: ../Doc/library/os.rst:3230
msgid ""
"Exit code that means some system file did not exist, could not be opened,"
" or had some other kind of error."
msgstr "일부 시스템 파일이 없거나, 열 수 없거나, 다른 에러가 있음을 나타내는 종료 코드."

#: ../Doc/library/os.rst:3238
msgid "Exit code that means a user specified output file could not be created."
msgstr "사용자가 지정한 출력 파일을 만들 수 없음을 나타내는 종료 코드."

#: ../Doc/library/os.rst:3245
msgid "Exit code that means that an error occurred while doing I/O on some file."
msgstr "일부 파일에서 I/O를 수행하는 동안 에러가 발생했음을 나타내는 종료 코드."

#: ../Doc/library/os.rst:3252
msgid ""
"Exit code that means a temporary failure occurred.  This indicates "
"something that may not really be an error, such as a network connection "
"that couldn't be made during a retryable operation."
msgstr ""
"임시 에러가 발생했음을 나타내는 종료 코드. 이는 재시도 가능한 작업 중에 만들 수 없었던 네트워크 연결과 같이 실제로는 에러가 "
"아닐 수 있는 것을 나타냅니다."

#: ../Doc/library/os.rst:3261
msgid ""
"Exit code that means that a protocol exchange was illegal, invalid, or "
"not understood."
msgstr "프로토콜 교환이 불법이거나 유효하지 않거나 이해되지 않았음을 나타내는 종료 코드."

#: ../Doc/library/os.rst:3269
msgid ""
"Exit code that means that there were insufficient permissions to perform "
"the operation (but not intended for file system problems)."
msgstr "작업을 수행할 수 있는 권한이 충분하지 않음을 나타내는 종료 코드 (파일 시스템 문제에는 사용하지 않습니다)."

#: ../Doc/library/os.rst:3277
msgid "Exit code that means that some kind of configuration error occurred."
msgstr "어떤 종류의 구성 에러가 발생했음을 나타내는 종료 코드."

#: ../Doc/library/os.rst:3284
msgid "Exit code that means something like \"an entry was not found\"."
msgstr "\"항목을 찾을 수 없습니다\" 와 같은 것을 의미하는 종료 코드."

#: ../Doc/library/os.rst:3291
msgid ""
"Fork a child process.  Return ``0`` in the child and the child's process "
"id in the parent.  If an error occurs :exc:`OSError` is raised."
msgstr ""
"자식 프로세스를 포크 합니다. 자식에서는 ``0``\\을 반환하고, 부모에서는 자식의 프로세스 ID를 반환합니다. 에러가 발생하면 "
":exc:`OSError`\\를 일으킵니다."

#: ../Doc/library/os.rst:3294
msgid ""
"Note that some platforms including FreeBSD <= 6.3 and Cygwin have known "
"issues when using fork() from a thread."
msgstr ""
"FreeBSD <= 6.3 및 Cygwin을 포함한 일부 플랫폼은 스레드에서 fork()를 사용할 때 알려진 문제점이 있습니다."

#: ../Doc/library/os.rst:3299
msgid "See :mod:`ssl` for applications that use the SSL module with fork()."
msgstr "fork()와 함께 SSL 모듈을 사용하는 응용 프로그램의 경우 :mod:`ssl`\\를 참조하십시오."

#: ../Doc/library/os.rst:3306
msgid ""
"Fork a child process, using a new pseudo-terminal as the child's "
"controlling terminal. Return a pair of ``(pid, fd)``, where *pid* is "
"``0`` in the child, the new child's process id in the parent, and *fd* is"
" the file descriptor of the master end of the pseudo-terminal.  For a "
"more portable approach, use the :mod:`pty` module.  If an error occurs "
":exc:`OSError` is raised."
msgstr ""
"새 의사 터미널을 자식의 제어 터미널로 사용하여 자식 프로세스를 포크 합니다. ``(pid, fd)`` 쌍을 반환하는데, 여기서 "
"*pid* 는 자식에서 ``0``\\이고, 부모에서는 새 자식의 프로세스 ID이고, *fd* 는 의사 터미널의 마스터 단의 파일 "
"기술자입니다. 좀 더 이식성 있는 접근법을 사용하려면, :mod:`pty` 모듈을 사용하십시오. 에러가 발생하면 "
":exc:`OSError`\\를 일으킵니다."

#: ../Doc/library/os.rst:3321
msgid ""
"Send signal *sig* to the process *pid*.  Constants for the specific "
"signals available on the host platform are defined in the :mod:`signal` "
"module."
msgstr ""
"프로세스 *pid*\\에 시그널 *sig*\\를 보냅니다. 호스트 플랫폼에서 사용할 수 있는 구체적인 시그널에 대한 상수는 "
":mod:`signal` 모듈에 정의되어 있습니다."

#: ../Doc/library/os.rst:3324
msgid ""
"Windows: The :data:`signal.CTRL_C_EVENT` and "
":data:`signal.CTRL_BREAK_EVENT` signals are special signals which can "
"only be sent to console processes which share a common console window, "
"e.g., some subprocesses. Any other value for *sig* will cause the process"
" to be unconditionally killed by the TerminateProcess API, and the exit "
"code will be set to *sig*. The Windows version of :func:`kill` "
"additionally takes process handles to be killed."
msgstr ""
"윈도우: :data:`signal.CTRL_C_EVENT` 및 :data:`signal.CTRL_BREAK_EVENT` 시그널은 "
"같은 콘솔 창을 공유하는 콘솔 프로세스(예를 들어, 일부 자식 프로세스)로만 보낼 수 있는 특수 시그널입니다. *sig*\\에 대한"
" 다른 값은, 프로세스가 TerminateProcess API에 의해 무조건 종료되게 하고, 종료 코드는 *sig* 로 설정됩니다."
" 윈도우 버전의 :func:`kill`\\은 종료시킬 프로세스 핸들도 받아들입니다."

#: ../Doc/library/os.rst:3332
msgid "See also :func:`signal.pthread_kill`."
msgstr ":func:`signal.pthread_kill`\\도 참조하십시오."

#: ../Doc/library/os.rst:3334
msgid "Windows support."
msgstr "윈도우 지원."

#: ../Doc/library/os.rst:3344
msgid "Send the signal *sig* to the process group *pgid*."
msgstr "시그널 *sig* 를 프로세스 그룹 *pgid* 로 보냅니다."

#: ../Doc/library/os.rst:3351
msgid "Add *increment* to the process's \"niceness\".  Return the new niceness."
msgstr "프로세스의 \"우선도(niceness)\"에 *increment* 을 추가합니다. 새로운 우선도를 반환합니다."

#: ../Doc/library/os.rst:3358
msgid ""
"Lock program segments into memory.  The value of *op* (defined in "
"``<sys/lock.h>``) determines which segments are locked."
msgstr ""
"프로그램 세그먼트를 메모리에 잠급니다. (``<sys/lock.h>``\\에서 정의된) *op* 값은 잠기는 세그먼트를 판별합니다."

#: ../Doc/library/os.rst:3366
msgid ""
"Open a pipe to or from command *cmd*. The return value is an open file "
"object connected to the pipe, which can be read or written depending on "
"whether *mode* is ``'r'`` (default) or ``'w'``. The *buffering* argument "
"has the same meaning as the corresponding argument to the built-in "
":func:`open` function. The returned file object reads or writes text "
"strings rather than bytes."
msgstr ""
"명령 *cmd*\\와의 파이프 연결을 엽니다. 반환 값은 파이프에 연결된 열린 파일 객체이며, *mode* 가 "
"``'r'``(기본값)인지 ``'w'``\\인지에 따라 읽거나 쓸 수 있습니다. *buffering* 인자는 내장 "
":func:`open` 함수에서와 같은 의미가 있습니다. 반환된 파일 객체는 바이트열이 아닌 텍스트 문자열을 읽거나 씁니다."

#: ../Doc/library/os.rst:3373
msgid ""
"The ``close`` method returns :const:`None` if the subprocess exited "
"successfully, or the subprocess's return code if there was an error. On "
"POSIX systems, if the return code is positive it represents the return "
"value of the process left-shifted by one byte.  If the return code is "
"negative, the process was terminated by the signal given by the negated "
"value of the return code.  (For example, the return value might be ``- "
"signal.SIGKILL`` if the subprocess was killed.)  On Windows systems, the "
"return value contains the signed integer return code from the child "
"process."
msgstr ""
"``close`` 메서드는 자식 프로세스가 성공적으로 종료되면 :const:`None`\\을 반환하고, 에러가 있으면 자식 "
"프로세스가 반환한 코드를 반환합니다. POSIX 시스템에서, 반환 코드가 양수면, 프로세스의 반환 값을 1바이트 왼쪽으로 시프트 한"
" 값을 나타냅니다. 반환 코드가 음수면, 음의 반환 코드로 주어진 시그널에 의해 강제 종료된 것입니다. 예를 들어, 자식 프로세스가"
" 죽었을(kill) 때 반환 값은 ``- signal.SIGKILL`` 일 수 있습니다. 윈도우 시스템에서, 반환 값은 자식 "
"프로세스의 부호 있는 정수 반환 코드를 포함합니다."

#: ../Doc/library/os.rst:3383
msgid ""
"This is implemented using :class:`subprocess.Popen`; see that class's "
"documentation for more powerful ways to manage and communicate with "
"subprocesses."
msgstr ""
"이것은 :class:`subprocess.Popen`\\를 사용하여 구현됩니다; 자식 프로세스를 관리하고 통신하는 보다 강력한 "
"방법에 대해서는 이 클래스의 설명서를 참조하십시오."

#: ../Doc/library/os.rst:3391
msgid ""
"Register callables to be executed when a new child process is forked "
"using :func:`os.fork` or similar process cloning APIs. The parameters are"
" optional and keyword-only. Each specifies a different call point."
msgstr ""
":func:`os.fork` 또는 유사한 프로세스 복제 API를 사용하여 새 자식 프로세스가 포크 될 때 실행될 콜러블들을 "
"등록합니다. 매개 변수는 선택적이며 키워드 전용입니다. 각각은 다른 호출 지점을 지정합니다."

#: ../Doc/library/os.rst:3396
msgid "*before* is a function called before forking a child process."
msgstr "*before* 는 자식 프로세스를 포크 하기 전에 호출되는 함수입니다."

#: ../Doc/library/os.rst:3397
msgid ""
"*after_in_parent* is a function called from the parent process after "
"forking a child process."
msgstr "*after_in_parent* 는 자식 프로세스를 포크 한 후에 부모 프로세스에서 호출되는 함수입니다."

#: ../Doc/library/os.rst:3399
msgid "*after_in_child* is a function called from the child process."
msgstr "*after_in_child* 는 자식 프로세스에서 호출되는 함수입니다."

#: ../Doc/library/os.rst:3401
msgid ""
"These calls are only made if control is expected to return to the Python "
"interpreter.  A typical :mod:`subprocess` launch will not trigger them as"
" the child is not going to re-enter the interpreter."
msgstr ""
"이러한 호출은 제거가 파이썬 인터프리터로 반환될 것으로 예상되는 경우에만 수행됩니다. 일반적인 :mod:`subprocess` "
"실행은 자식이 인터프리터로 재진입하지 않기 때문에, 이 호출들이 일어나지 않습니다."

#: ../Doc/library/os.rst:3405
msgid ""
"Functions registered for execution before forking are called in reverse "
"registration order.  Functions registered for execution after forking "
"(either in the parent or in the child) are called in registration order."
msgstr ""
"포크 이전에 실행되도록 등록된 함수는 등록 역순으로 실행됩니다. 포크 후에 실행되도록 등록된 함수(부모나 자식 모두)는 등록 순서로"
" 호출됩니다."

#: ../Doc/library/os.rst:3410
msgid ""
"Note that :c:func:`fork` calls made by third-party C code may not call "
"those functions, unless it explicitly calls :c:func:`PyOS_BeforeFork`, "
":c:func:`PyOS_AfterFork_Parent` and :c:func:`PyOS_AfterFork_Child`."
msgstr ""
"제삼자 C 코드에 의한 :c:func:`fork` 호출은, 그것이 명시적으로 :c:func:`PyOS_BeforeFork`, "
":c:func:`PyOS_AfterFork_Parent` 및 :c:func:`PyOS_AfterFork_Child`\\를 호출하지 "
"않는 한, 이 함수들을 호출하지 않습니다."

#: ../Doc/library/os.rst:3414
msgid "There is no way to unregister a function."
msgstr "함수 등록을 취소할 방법은 없습니다."

#: ../Doc/library/os.rst:3430
msgid "Execute the program *path* in a new process."
msgstr "새 프로세스에서 프로그램 *path* 를 실행합니다."

#: ../Doc/library/os.rst:3432
msgid ""
"(Note that the :mod:`subprocess` module provides more powerful facilities"
" for spawning new processes and retrieving their results; using that "
"module is preferable to using these functions.  Check especially the :ref"
":`subprocess-replacements` section.)"
msgstr ""
"(:mod:`subprocess` 모듈은 새 프로세스를 생성하고 결과를 조회하는데, 더욱 강력한 기능을 제공합니다; 이 모듈을 "
"사용하는 것이 이 함수들을 사용하는 것보다 더 바람직합니다. 특히 :ref:`subprocess-replacements` 섹션을 "
"확인하십시오.)"

#: ../Doc/library/os.rst:3437
msgid ""
"If *mode* is :const:`P_NOWAIT`, this function returns the process id of "
"the new process; if *mode* is :const:`P_WAIT`, returns the process's exit"
" code if it exits normally, or ``-signal``, where *signal* is the signal "
"that killed the process.  On Windows, the process id will actually be the"
" process handle, so can be used with the :func:`waitpid` function."
msgstr ""
"*mode* 가 :const:`P_NOWAIT`\\면, 이 함수는 새 프로세스의 프로세스 ID를 반환합니다; *mode*\\가 "
":const:`P_WAIT`\\면, 종료 코드(정상적으로 종료했을 때)나 ``-signal``\\(*signal*\\은 프로세스를 "
"죽인 시그널입니다)을 반환합니다. 윈도우에서, 프로세스 ID는 실제로 프로세스 핸들이므로, :func:`waitpid` 함수에 "
"사용할 수 있습니다."

#: ../Doc/library/os.rst:3443
msgid ""
"The \"l\" and \"v\" variants of the :func:`spawn\\* <spawnl>` functions "
"differ in how command-line arguments are passed.  The \"l\" variants are "
"perhaps the easiest to work with if the number of parameters is fixed "
"when the code is written; the individual parameters simply become "
"additional parameters to the :func:`spawnl\\*` functions.  The \"v\" "
"variants are good when the number of parameters is variable, with the "
"arguments being passed in a list or tuple as the *args* parameter.  In "
"either case, the arguments to the child process must start with the name "
"of the command being run."
msgstr ""
":func:`spawn\\* <spawnl>` 함수의 \"l\" 및 \"v\" 변형은 명령 줄 인자가 전달되는 방식이 다릅니다. "
"\"l\" 변형은 아마도 코드가 작성될 때 매개 변수의 수가 고정되어 있다면 가장 작업하기 쉬운 것입니다; 개별 매개 변수는 단순히"
" :func:`spawnl\\*` 함수에 대한 추가 매개 변수가 됩니다. \"v\" 변형은 매개 변수의 개수가 가변적일 때 좋으며,"
" 리스트나 튜플에 들어있는 인자가 *args* 매개 변수로 전달됩니다. 두 경우 모두, 자식 프로세스에 대한 인자는 반드시 실행 "
"중인 명령의 이름으로 시작해야 합니다."

#: ../Doc/library/os.rst:3452
msgid ""
"The variants which include a second \"p\" near the end (:func:`spawnlp`, "
":func:`spawnlpe`, :func:`spawnvp`, and :func:`spawnvpe`) will use the "
":envvar:`PATH` environment variable to locate the program *file*.  When "
"the environment is being replaced (using one of the :func:`spawn\\*e "
"<spawnl>` variants, discussed in the next paragraph), the new environment"
" is used as the source of the :envvar:`PATH` variable.  The other "
"variants, :func:`spawnl`, :func:`spawnle`, :func:`spawnv`, and "
":func:`spawnve`, will not use the :envvar:`PATH` variable to locate the "
"executable; *path* must contain an appropriate absolute or relative path."
msgstr ""
"끝 근처에 두 번째 \"p\"가 포함된 변형(:func:`spawnlp`, :func:`spawnlpe`, "
":func:`spawnvp` 및 :func:`spawnvpe`)은 :envvar:`PATH` 환경 변수를 사용하여 프로그램 "
"*file* 을 찾습니다. 환경이 대체 될 때 (다음 단락에서 설명할 :func:`spawn\\*e <spawnl>` 변형 중 "
"하나를 사용하여), 새 환경이 :envvar:`PATH` 변수의 소스로 사용됩니다. 다른 변형 :func:`spawnl`, "
":func:`spawnle`, :func:`spawnv` 및 :func:`spawnve`\\는 :envvar:`PATH` 변수를 "
"사용하여 실행 파일을 찾지 않습니다; *path* 에는 반드시 적절한 절대 또는 상대 경로가 있어야 합니다."

#: ../Doc/library/os.rst:3462
msgid ""
"For :func:`spawnle`, :func:`spawnlpe`, :func:`spawnve`, and "
":func:`spawnvpe` (note that these all end in \"e\"), the *env* parameter "
"must be a mapping which is used to define the environment variables for "
"the new process (they are used instead of the current process' "
"environment); the functions :func:`spawnl`, :func:`spawnlp`, "
":func:`spawnv`, and :func:`spawnvp` all cause the new process to inherit "
"the environment of the current process.  Note that keys and values in the"
" *env* dictionary must be strings; invalid keys or values will cause the "
"function to fail, with a return value of ``127``."
msgstr ""
":func:`spawnle`, :func:`spawnlpe`, :func:`spawnve` 및 :func:`spawnvpe`\\의 "
"경우 (모두 \"e\"로 끝납니다), *env* 매개 변수는 새 프로세스의 환경 변수를 정의하는 데 사용되는 매핑이어야 합니다 "
"(이것이 현재 프로세스의 환경 대신 사용됩니다); 함수 :func:`spawnl`, :func:`spawnlp`, "
":func:`spawnv` 및 :func:`spawnvp`\\는 모두 새 프로세스가 현재 프로세스의 환경을 상속하게 합니다. "
"*env* 딕셔너리의 키와 값은 반드시 문자열이어야 함에 주의하십시오; 잘못된 키나 값은 반환 값 ``127``\\로 함수가 "
"실패하게 합니다."

#: ../Doc/library/os.rst:3471
msgid ""
"As an example, the following calls to :func:`spawnlp` and "
":func:`spawnvpe` are equivalent::"
msgstr "예를 들어, :func:`spawnlp` 및 :func:`spawnvpe`\\에 대한 다음 호출은 동등합니다::"

#: ../Doc/library/os.rst:3484
msgid ""
":ref:`Availability <availability>`: Unix, Windows.  :func:`spawnlp`, "
":func:`spawnlpe`, :func:`spawnvp` and :func:`spawnvpe` are not available "
"on Windows.  :func:`spawnle` and :func:`spawnve` are not thread-safe on "
"Windows; we advise you to use the :mod:`subprocess` module instead."
msgstr ""
":ref:`가용성 <availability>`: 유닉스, 윈도우. :func:`spawnlp`, :func:`spawnlpe`, "
":func:`spawnvp`, :func:`spawnvpe`\\는 윈도우에서 사용할 수 없습니다. :func:`spawnle`\\와 "
":func:`spawnve`\\는 윈도우에서 스레드 안전하지 않습니다; 대신 :mod:`subprocess` 모듈을 사용하도록 "
"권고합니다."

#: ../Doc/library/os.rst:3492
msgid ""
"Possible values for the *mode* parameter to the :func:`spawn\\* <spawnl>`"
" family of functions.  If either of these values is given, the "
":func:`spawn\\*` functions will return as soon as the new process has "
"been created, with the process id as the return value."
msgstr ""
":func:`spawn\\* <spawnl>` 계열 함수의 *mode* 매개 변수에 사용할 수 있는 값. 이 값 중 하나가 "
"주어지면, :func:`spawn\\*` 함수는 새로운 프로세스가 생성되자마자 프로세스 ID를 반환 값으로 사용하여 반환됩니다."

#: ../Doc/library/os.rst:3502
msgid ""
"Possible value for the *mode* parameter to the :func:`spawn\\* <spawnl>` "
"family of functions.  If this is given as *mode*, the :func:`spawn\\*` "
"functions will not return until the new process has run to completion and"
" will return the exit code of the process the run is successful, or "
"``-signal`` if a signal kills the process."
msgstr ""
":func:`spawn\\* <spawnl>` 계열 함수의 *mode* 매개 변수에 사용할 수 있는 값. 이것이 *mode* 로 "
"주어지면, :func:`spawn\\*` 함수는 새 프로세스가 완료될 때까지 반환되지 않고, 실행이 성공한 프로세스의 종료 코드를 "
"반환하거나, 시그널이 프로세스를 죽이면 ``-signal``\\을 반환합니다."

#: ../Doc/library/os.rst:3514
msgid ""
"Possible values for the *mode* parameter to the :func:`spawn\\* <spawnl>`"
" family of functions.  These are less portable than those listed above. "
":const:`P_DETACH` is similar to :const:`P_NOWAIT`, but the new process is"
" detached from the console of the calling process. If :const:`P_OVERLAY` "
"is used, the current process will be replaced; the :func:`spawn\\* "
"<spawnl>` function will not return."
msgstr ""
":func:`spawn\\* <spawnl>` 계열 함수의 *mode* 매개 변수에 사용할 수 있는 값. 이들은 위에 나열된 것보다"
" 이식성이 낮습니다. :const:`P_DETACH`\\는 :const:`P_NOWAIT`\\와 비슷하지만, 새 프로세스는 호출 "
"프로세스의 콘솔에서 분리됩니다. :const:`P_OVERLAY`\\가 사용되면, 현재 프로세스가 대체됩니다; "
":func:`spawn\\* <spawnl>` 함수가 반환되지 않습니다."

#: ../Doc/library/os.rst:3525
msgid "Start a file with its associated application."
msgstr "연관된 응용 프로그램으로 파일을 시작합니다."

#: ../Doc/library/os.rst:3527
msgid ""
"When *operation* is not specified or ``'open'``, this acts like double-"
"clicking the file in Windows Explorer, or giving the file name as an "
"argument to the :program:`start` command from the interactive command "
"shell: the file is opened with whatever application (if any) its "
"extension is associated."
msgstr ""
"*operation* 이 지정되지 않았거나 ``'open'``\\이면, 윈도우 탐색기에서 파일을 두 번 클릭하거나, 대화형 명령 "
"셸에서 :program:`start` 명령에 인자로 파일명을 지정하는 것과 같은 역할을 합니다: 파일의 확장자와 연관된 (있다면) "
"응용 프로그램으로 파일이 열립니다."

#: ../Doc/library/os.rst:3532
msgid ""
"When another *operation* is given, it must be a \"command verb\" that "
"specifies what should be done with the file. Common verbs documented by "
"Microsoft are ``'print'`` and  ``'edit'`` (to be used on files) as well "
"as ``'explore'`` and ``'find'`` (to be used on directories)."
msgstr ""
"다른 *operation* 이 주어지면, 파일로 수행해야 할 작업을 지정하는 \"명령 동사\"여야 합니다. 마이크로소프트에서 문서화"
" 한 일반적인 동사는 ``'print'`` 와 ``'edit'`` (파일에 사용됨) 및 ``'explore'`` 와 "
"``'find'`` (디렉터리에 사용됨)입니다."

#: ../Doc/library/os.rst:3537
msgid ""
":func:`startfile` returns as soon as the associated application is "
"launched. There is no option to wait for the application to close, and no"
" way to retrieve the application's exit status.  The *path* parameter is "
"relative to the current directory.  If you want to use an absolute path, "
"make sure the first character is not a slash (``'/'``); the underlying "
"Win32 :c:func:`ShellExecute` function doesn't work if it is.  Use the "
":func:`os.path.normpath` function to ensure that the path is properly "
"encoded for Win32."
msgstr ""
":func:`startfile`\\는 연관된 응용 프로그램이 시작되자마자 반환합니다. 응용 프로그램이 닫히기를 기다리는 옵션과 응용"
" 프로그램의 종료 상태를 검색할 방법이 없습니다. *path* 매개 변수는 현재 디렉터리에 상대적입니다. 절대 경로를 사용하려면 첫"
" 번째 문자가 슬래시 (``'/'``)가 아닌지 확인하십시오; 하부 Win32 :c:func:`ShellExecute` 함수는 첫 "
"번째 문자가 슬래시면 작동하지 않습니다. :func:`os.path.normpath` 함수를 사용하여 경로가 Win32 용으로 "
"올바르게 인코딩되도록 하십시오."

#: ../Doc/library/os.rst:3545
msgid ""
"To reduce interpreter startup overhead, the Win32 :c:func:`ShellExecute` "
"function is not resolved until this function is first called.  If the "
"function cannot be resolved, :exc:`NotImplementedError` will be raised."
msgstr ""
"인터프리터 시작 오버헤드를 줄이기 위해, Win32 :c:func:`ShellExecute` 함수는 이 함수가 처음 호출될 때까지 "
"결정(resolve)되지 않습니다. 함수를 결정할 수 없으면 :exc:`NotImplementedError`\\가 발생합니다."

#: ../Doc/library/os.rst:3554
msgid ""
"Execute the command (a string) in a subshell.  This is implemented by "
"calling the Standard C function :c:func:`system`, and has the same "
"limitations. Changes to :data:`sys.stdin`, etc. are not reflected in the "
"environment of the executed command. If *command* generates any output, "
"it will be sent to the interpreter standard output stream."
msgstr ""
"서브 셸에서 명령(문자열)을 실행합니다. 이것은 표준 C 함수 :c:func:`system`\\를 호출하여 구현되며, 같은 제한이 "
"있습니다. :data:`sys.stdin` 등의 변경 사항은 실행된 명령의 환경에 반영되지 않습니다. *command*\\가 출력을"
" 생성하면, 인터프리터 표준 출력 스트림으로 전송됩니다."

#: ../Doc/library/os.rst:3560
msgid ""
"On Unix, the return value is the exit status of the process encoded in "
"the format specified for :func:`wait`.  Note that POSIX does not specify "
"the meaning of the return value of the C :c:func:`system` function, so "
"the return value of the Python function is system-dependent."
msgstr ""
"유닉스에서, 반환 값은 :func:`wait`\\에 지정된 형식으로 인코딩된 프로세스의 종료 상태입니다. POSIX는 C "
":c:func:`system` 함수의 반환 값의 의미를 지정하지 않으므로, 파이썬 함수의 반환 값은 시스템 종속적입니다."

#: ../Doc/library/os.rst:3565
msgid ""
"On Windows, the return value is that returned by the system shell after "
"running *command*.  The shell is given by the Windows environment "
"variable :envvar:`COMSPEC`: it is usually :program:`cmd.exe`, which "
"returns the exit status of the command run; on systems using a non-native"
" shell, consult your shell documentation."
msgstr ""
"윈도우에서, 반환 값은 *command*\\를 실행한 후 시스템 셸에서 반환한 값입니다. 셸은 윈도우 환경 변수 "
":envvar:`COMSPEC`\\에 의해 제공됩니다: 보통 :program:`cmd.exe`\\인데, 명령 실행의 종료 상태를 "
"반환합니다; 기본이 아닌 셸을 사용하는 시스템에서는 셸 설명서를 참조하십시오."

#: ../Doc/library/os.rst:3571
msgid ""
"The :mod:`subprocess` module provides more powerful facilities for "
"spawning new processes and retrieving their results; using that module is"
" preferable to using this function.  See the :ref:`subprocess-"
"replacements` section in the :mod:`subprocess` documentation for some "
"helpful recipes."
msgstr ""
":mod:`subprocess` 모듈은 새 프로세스를 생성하고 결과를 조회하는데, 더욱 강력한 기능을 제공합니다; 이 모듈을 "
"사용하는 것이 이 함수들을 사용하는 것보다 더 바람직합니다. :mod:`subprocess` 설명서의 :ref"
":`subprocess-replacements` 섹션에서 유용한 조리법을 확인하십시오."

#: ../Doc/library/os.rst:3581
msgid ""
"Returns the current global process times. The return value is an object "
"with five attributes:"
msgstr "현재 전역 프로세스 시간을 반환합니다. 반환 값은 5가지 어트리뷰트를 가진 객체입니다:"

#: ../Doc/library/os.rst:3584
msgid ":attr:`user` - user time"
msgstr ":attr:`user` - 사용자 시간"

#: ../Doc/library/os.rst:3585
msgid ":attr:`system` - system time"
msgstr ":attr:`system` - 시스템 시간"

#: ../Doc/library/os.rst:3586
msgid ":attr:`children_user` - user time of all child processes"
msgstr ":attr:`children_user` - 모든 자식 프로세스의 사용자 시간"

#: ../Doc/library/os.rst:3587
msgid ":attr:`children_system` - system time of all child processes"
msgstr ":attr:`children_system` - 모든 자식 프로세스의 시스템 시간"

#: ../Doc/library/os.rst:3588
msgid ":attr:`elapsed` - elapsed real time since a fixed point in the past"
msgstr ":attr:`elapsed` - 과거의 고정된 시점 이후 실제 경과 시간"

#: ../Doc/library/os.rst:3590
msgid ""
"For backwards compatibility, this object also behaves like a five-tuple "
"containing :attr:`user`, :attr:`system`, :attr:`children_user`, "
":attr:`children_system`, and :attr:`elapsed` in that order."
msgstr ""
"과거 호환성을 위해, 이 객체는 :attr:`user`, :attr:`system`, :attr:`children_user`, "
":attr:`children_system` 및 :attr:`elapsed`\\가 이 순서로 포함된 5-튜플처럼 작동합니다."

#: ../Doc/library/os.rst:3594
msgid ""
"See the Unix manual page :manpage:`times(2)` or the corresponding Windows"
" Platform API documentation. On Windows, only :attr:`user` and "
":attr:`system` are known; the other attributes are zero."
msgstr ""
"유닉스 매뉴얼 페이지 :manpage:`times(2)` 또는 해당 윈도우 플랫폼 API 설명서를 참조하십시오. 윈도우에서는, "
":attr:`user` 및 :attr:`system` 만 알려져 있습니다; 다른 어트리뷰트는 0입니다."

#: ../Doc/library/os.rst:3608
msgid ""
"Wait for completion of a child process, and return a tuple containing its"
" pid and exit status indication: a 16-bit number, whose low byte is the "
"signal number that killed the process, and whose high byte is the exit "
"status (if the signal number is zero); the high bit of the low byte is "
"set if a core file was produced."
msgstr ""
"자식 프로세스가 완료될 때까지 기다렸다가, pid 및 종료 상태 표시를 포함하는 튜플을 반환합니다: 종료 상태 표시는 16비트 "
"숫자인데, 하위 바이트가 프로세스를 죽인 시그널 번호이고, 상위 바이트가 종료 상태(시그널 번호가 0이면)입니다; 코어 파일이 "
"생성되면 하위 바이트의 상위 비트가 설정됩니다."

#: ../Doc/library/os.rst:3618
msgid ""
"Wait for the completion of one or more child processes. *idtype* can be "
":data:`P_PID`, :data:`P_PGID` or :data:`P_ALL`. *id* specifies the pid to"
" wait on. *options* is constructed from the ORing of one or more of "
":data:`WEXITED`, :data:`WSTOPPED` or :data:`WCONTINUED` and additionally "
"may be ORed with :data:`WNOHANG` or :data:`WNOWAIT`. The return value is "
"an object representing the data contained in the :c:type:`siginfo_t` "
"structure, namely: :attr:`si_pid`, :attr:`si_uid`, :attr:`si_signo`, "
":attr:`si_status`, :attr:`si_code` or ``None`` if :data:`WNOHANG` is "
"specified and there are no children in a waitable state."
msgstr ""
"하나 이상의 자식 프로세스가 완료될 때까지 기다립니다. *idtype* 은 :data:`P_PID`, :data:`P_PGID` "
"또는 :data:`P_ALL`\\이 될 수 있습니다. *id* 는 기다릴 pid를 지정합니다. *options*\\는 하나 이상의 "
":data:`WEXITED`, :data:`WSTOPPED` 또는 :data:`WCONTINUED`\\의 OR로 구성되며, 추가로 "
":data:`WNOHANG` 또는 :data:`WNOWAIT`\\와 OR 될 수 있습니다. 반환 값은 "
":c:type:`siginfo_t` 구조체에 포함된 데이터(즉, :attr:`si_pid`, :attr:`si_uid`, "
":attr:`si_signo`, :attr:`si_status`, :attr:`si_code`)를 나타내는 객체이거나, "
":data:`WNOHANG`\\가 지정되고 대기 가능한 상태의 자식이 없으면 ``None``\\입니다."

#: ../Doc/library/os.rst:3637
msgid ""
"These are the possible values for *idtype* in :func:`waitid`. They affect"
" how *id* is interpreted."
msgstr ""
"이것들은 :func:`waitid`\\의 *idtype* 에 사용 가능한 값입니다. *id* 가 어떻게 해석되는지에 영향을 미칩니다."

#: ../Doc/library/os.rst:3648
msgid ""
"Flags that can be used in *options* in :func:`waitid` that specify what "
"child signal to wait for."
msgstr "기다릴 자식 시그널을 지정하는, :func:`waitid`\\의 *options* 에서 사용할 수 있는 플래그."

#: ../Doc/library/os.rst:3661
msgid ""
"These are the possible values for :attr:`si_code` in the result returned "
"by :func:`waitid`."
msgstr "이것은 :func:`waitid`\\에 의해 반환된 결과에서 :attr:`si_code`\\의 가능한 값입니다."

#: ../Doc/library/os.rst:3671
msgid "The details of this function differ on Unix and Windows."
msgstr "이 함수의 세부 사항은 유닉스 및 윈도우에서 다릅니다."

#: ../Doc/library/os.rst:3673
msgid ""
"On Unix: Wait for completion of a child process given by process id "
"*pid*, and return a tuple containing its process id and exit status "
"indication (encoded as for :func:`wait`).  The semantics of the call are "
"affected by the value of the integer *options*, which should be ``0`` for"
" normal operation."
msgstr ""
"유닉스에서: 프로세스 ID *pid*\\에 의해 주어진 자식 프로세스의 완료를 기다리고, 프로세스 ID와 종료 상태 "
"표시(:func:`wait`\\처럼 인코딩됨)를 포함하는 튜플을 반환합니다. 호출의 의미는 정수 *options* 의 값에 영향을 "
"받는데, 일반 작업의 경우 ``0`` 이어야 합니다."

#: ../Doc/library/os.rst:3678
msgid ""
"If *pid* is greater than ``0``, :func:`waitpid` requests status "
"information for that specific process.  If *pid* is ``0``, the request is"
" for the status of any child in the process group of the current process."
"  If *pid* is ``-1``, the request pertains to any child of the current "
"process.  If *pid* is less than ``-1``, status is requested for any "
"process in the process group ``-pid`` (the absolute value of *pid*)."
msgstr ""
"*pid* 가 ``0``\\보다 크면, :func:`waitpid`\\는 해당 프로세스에 대한 상태 정보를 요청합니다. *pid* "
"가 ``0``\\이면, 현재 프로세스의 프로세스 그룹에 있는 모든 자식의 상태를 요청합니다. *pid* 가 ``-1``\\이면, "
"현재 프로세스의 모든 자식의 상태를 요청합니다. *pid* 가 ``-1``\\보다 작으면, 프로세스 그룹 "
"``-pid``\\(*pid* 의 절댓값)에 있는 모든 프로세스의 상태를 요청합니다."

#: ../Doc/library/os.rst:3685
msgid ""
"An :exc:`OSError` is raised with the value of errno when the syscall "
"returns -1."
msgstr "시스템 호출이 -1을 반환하면, :exc:`OSError`\\가 errno 값으로 발생합니다."

#: ../Doc/library/os.rst:3688
msgid ""
"On Windows: Wait for completion of a process given by process handle "
"*pid*, and return a tuple containing *pid*, and its exit status shifted "
"left by 8 bits (shifting makes cross-platform use of the function "
"easier). A *pid* less than or equal to ``0`` has no special meaning on "
"Windows, and raises an exception. The value of integer *options* has no "
"effect. *pid* can refer to any process whose id is known, not necessarily"
" a child process. The :func:`spawn\\* <spawnl>` functions called with "
":const:`P_NOWAIT` return suitable process handles."
msgstr ""
"윈도우에서: 프로세스 핸들 *pid*\\로 지정된 프로세스가 완료될 때까지 기다리고, *pid*\\와 종료 상태를 8비트 왼쪽으로 "
"시프트 한 값을 포함하는 튜플을 반환합니다 (시프팅이 함수를 더 이식성 있게 만듭니다). ``0``\\보다 작거나 같은 *pid* "
"는 윈도우에서 특별한 의미가 없고 예외가 발생합니다. 정수 *options* 의 값은 아무 효과가 없습니다. *pid* 는 id가 "
"알려진 모든 프로세스를 가리킬 수 있습니다, 반드시 자식 프로세스일 필요는 없습니다. :const:`P_NOWAIT`\\로 호출된 "
":func:`spawn\\* <spawnl>` 함수는 적절한 프로세스 핸들을 반환합니다."

#: ../Doc/library/os.rst:3704
msgid ""
"Similar to :func:`waitpid`, except no process id argument is given and a "
"3-element tuple containing the child's process id, exit status "
"indication, and resource usage information is returned.  Refer to "
":mod:`resource`.\\ :func:`~resource.getrusage` for details on resource "
"usage information.  The option argument is the same as that provided to "
":func:`waitpid` and :func:`wait4`."
msgstr ""
":func:`waitpid`\\와 비슷하지만, 프로세스 ID 인자가 제공되지 않고 자식 프로세스 ID, 종료 상태 표시 및 자원 "
"사용 정보가 포함된 3-요소 튜플이 반환된다는 점이 다릅니다. 자원 사용 정보에 대한 자세한 내용은 "
":mod:`resource`.\\ :func:`~resource.getrusage`\\를 참조하십시오. 옵션 인자는 "
":func:`waitpid` 및 :func:`wait4`\\에 제공된 인자와 같습니다."

#: ../Doc/library/os.rst:3716
msgid ""
"Similar to :func:`waitpid`, except a 3-element tuple, containing the "
"child's process id, exit status indication, and resource usage "
"information is returned. Refer to :mod:`resource`.\\ "
":func:`~resource.getrusage` for details on resource usage information.  "
"The arguments to :func:`wait4` are the same as those provided to "
":func:`waitpid`."
msgstr ""
":func:`waitpid`\\와 비슷하지만, 자식 프로세스 ID, 종료 상태 표시 및 자원 사용 정보가 포함된 3-요소 튜플이 "
"반환된다는 점이 다릅니다. 자원 사용 정보에 대한 자세한 내용은 :mod:`resource`.\\ "
":func:`~resource.getrusage`\\를 참조하십시오. :func:`wait4`\\의 인자는 "
":func:`waitpid`\\와 같습니다."

#: ../Doc/library/os.rst:3727
msgid ""
"The option for :func:`waitpid` to return immediately if no child process "
"status is available immediately. The function returns ``(0, 0)`` in this "
"case."
msgstr ""
"자식 프로세스 상태를 즉시 사용할 수 없으면, :func:`waitpid`\\가 즉시 반환하는 옵션입니다. 이 경우 이 함수는 "
"``(0, 0)``\\를 반환합니다."

#: ../Doc/library/os.rst:3735
msgid ""
"This option causes child processes to be reported if they have been "
"continued from a job control stop since their status was last reported."
msgstr "이 옵션은 자식 프로세스의 상태가 마지막으로 보고된 이후에 작업 제어 중지에서 재개한 경우 보고되도록 합니다."

#: ../Doc/library/os.rst:3738
msgid ":ref:`Availability <availability>`: some Unix systems."
msgstr ":ref:`가용성 <availability>`: 일부 유닉스 시스템."

#: ../Doc/library/os.rst:3743
msgid ""
"This option causes child processes to be reported if they have been "
"stopped but their current state has not been reported since they were "
"stopped."
msgstr "이 옵션은 자식 프로세스가 중지되었지만, 현재 상태가 중지된 이후 보고되지 않았으면 보고되게 합니다."

#: ../Doc/library/os.rst:3749
msgid ""
"The following functions take a process status code as returned by "
":func:`system`, :func:`wait`, or :func:`waitpid` as a parameter.  They "
"may be used to determine the disposition of a process."
msgstr ""
"다음 함수들은 :func:`system`, :func:`wait` 또는 :func:`waitpid`\\에 의해 반환된 프로세스 상태"
" 코드를 매개 변수로 받아들입니다. 이것들은 프로세스의 처리를 결정하는 데 사용될 수 있습니다."

#: ../Doc/library/os.rst:3755
msgid ""
"Return ``True`` if a core dump was generated for the process, otherwise "
"return ``False``."
msgstr "프로세스에 대해 코어 덤프가 생성되었으면 ``True``\\를 반환하고, 그렇지 않으면 ``False``\\를 반환합니다."

#: ../Doc/library/os.rst:3763
msgid ""
"Return ``True`` if the process has been continued from a job control "
"stop, otherwise return ``False``."
msgstr "작업 제어 중지에서 프로세스가 재개했으면 ``True``\\를 반환하고, 그렇지 않으면 ``False``\\를 반환합니다."

#: ../Doc/library/os.rst:3771
msgid ""
"Return ``True`` if the process has been stopped, otherwise return "
"``False``."
msgstr "프로세스가 중지되었으면 ``True``\\를 반환하고, 그렇지 않으면 ``False``\\를 반환합니다."

#: ../Doc/library/os.rst:3779
msgid ""
"Return ``True`` if the process exited due to a signal, otherwise return "
"``False``."
msgstr "시그널로 인해 프로세스가 종료되었으면 ``True``\\를 반환하고, 그렇지 않으면 ``False``\\를 반환합니다."

#: ../Doc/library/os.rst:3787
msgid ""
"Return ``True`` if the process exited using the :manpage:`exit(2)` system"
" call, otherwise return ``False``."
msgstr ""
"프로세스가 :manpage:`exit(2)` 시스템 호출을 사용하여 종료되었으면 ``True``\\를 반환하고, 그렇지 않으면 "
"``False``\\를 반환합니다."

#: ../Doc/library/os.rst:3795
msgid ""
"If ``WIFEXITED(status)`` is true, return the integer parameter to the "
":manpage:`exit(2)` system call.  Otherwise, the return value is "
"meaningless."
msgstr ""
"``WIFEXITED(status)``\\가 참이면, :manpage:`exit(2)` 시스템 호출로 준 정수 매개 변수를 "
"반환합니다. 그렇지 않으면 반환 값은 의미가 없습니다."

#: ../Doc/library/os.rst:3803
msgid "Return the signal which caused the process to stop."
msgstr "프로세스를 멈추게 한 시그널을 반환합니다."

#: ../Doc/library/os.rst:3810
msgid "Return the signal which caused the process to exit."
msgstr "프로세스를 종료시킨 시그널을 반환합니다."

#: ../Doc/library/os.rst:3816
msgid "Interface to the scheduler"
msgstr "스케줄러에 대한 인터페이스"

#: ../Doc/library/os.rst:3818
msgid ""
"These functions control how a process is allocated CPU time by the "
"operating system. They are only available on some Unix platforms. For "
"more detailed information, consult your Unix manpages."
msgstr ""
"이 함수들은 운영 체제가 프로세스에 CPU 시간을 할당하는 방법을 제어합니다. 일부 유닉스 플랫폼에서만 사용할 수 있습니다. 자세한"
" 내용은 유닉스 매뉴얼 페이지를 참조하십시오."

#: ../Doc/library/os.rst:3824
msgid ""
"The following scheduling policies are exposed if they are supported by "
"the operating system."
msgstr "다음 스케줄 정책은 운영 체제에서 지원하는 경우 공개됩니다."

#: ../Doc/library/os.rst:3829
msgid "The default scheduling policy."
msgstr "기본 스케줄 정책."

#: ../Doc/library/os.rst:3833
msgid ""
"Scheduling policy for CPU-intensive processes that tries to preserve "
"interactivity on the rest of the computer."
msgstr "컴퓨터의 나머지 부분에서 반응성을 유지하려고 하는 CPU 집약적인 프로세스를 위한 스케줄 정책."

#: ../Doc/library/os.rst:3838
msgid "Scheduling policy for extremely low priority background tasks."
msgstr "매우 낮은 우선순위의 배경 작업에 대한 스케줄 정책."

#: ../Doc/library/os.rst:3842
msgid "Scheduling policy for sporadic server programs."
msgstr "간헐적인 서버 프로그램을 위한 스케줄 정책."

#: ../Doc/library/os.rst:3846
msgid "A First In First Out scheduling policy."
msgstr "선입 선출 (First In First Out) 스케줄 정책."

#: ../Doc/library/os.rst:3850
msgid "A round-robin scheduling policy."
msgstr "라운드 로빈 스케줄 정책."

#: ../Doc/library/os.rst:3854
msgid ""
"This flag can be OR'ed with any other scheduling policy. When a process "
"with this flag set forks, its child's scheduling policy and priority are "
"reset to the default."
msgstr ""
"이 플래그는 다른 스케줄 정책과 OR 될 수 있습니다. 이 플래그가 설정되어있는 프로세스가 포크 할 때, 자식의 스케줄링 정책 및 "
"우선순위가 기본값으로 재설정됩니다."

#: ../Doc/library/os.rst:3861
msgid ""
"This class represents tunable scheduling parameters used in "
":func:`sched_setparam`, :func:`sched_setscheduler`, and "
":func:`sched_getparam`. It is immutable."
msgstr ""
"이 클래스는 :func:`sched_setparam`, :func:`sched_setscheduler`, 및 "
":func:`sched_getparam`\\에서 사용되는 튜닝 가능한 스케줄 파라미터를 나타냅니다. 불변입니다."

#: ../Doc/library/os.rst:3865
msgid "At the moment, there is only one possible parameter:"
msgstr "현재, 가능한 매개 변수는 하나뿐입니다:"

#: ../Doc/library/os.rst:3869
msgid "The scheduling priority for a scheduling policy."
msgstr "스케줄 정책의 스케줄 우선순위."

#: ../Doc/library/os.rst:3874
msgid ""
"Get the minimum priority value for *policy*. *policy* is one of the "
"scheduling policy constants above."
msgstr "*policy*\\의 최소 우선순위 값을 가져옵니다. *policy* 는 위의 스케줄 정책 상수 중 하나입니다."

#: ../Doc/library/os.rst:3880
msgid ""
"Get the maximum priority value for *policy*. *policy* is one of the "
"scheduling policy constants above."
msgstr "*policy*\\의 최대 우선순위 값을 가져옵니다. *policy* 는 위의 스케줄 정책 상수 중 하나입니다."

#: ../Doc/library/os.rst:3886
msgid ""
"Set the scheduling policy for the process with PID *pid*. A *pid* of 0 "
"means the calling process. *policy* is one of the scheduling policy "
"constants above. *param* is a :class:`sched_param` instance."
msgstr ""
"PID가 *pid*\\인 프로세스의 스케줄 정책을 설정합니다. *pid* 가 0이면, 호출하는 프로세스를 의미합니다. "
"*policy* 는 위의 스케줄 정책 상수 중 하나입니다. *param* 은 :class:`sched_param` 인스턴스입니다."

#: ../Doc/library/os.rst:3893
msgid ""
"Return the scheduling policy for the process with PID *pid*. A *pid* of 0"
" means the calling process. The result is one of the scheduling policy "
"constants above."
msgstr ""
"PID가 *pid*\\인 프로세스의 스케줄 정책을 반환합니다. *pid* 가 0이면, 호출하는 프로세스를 의미합니다. 결과는 위의 "
"스케줄 정책 상수 중 하나입니다."

#: ../Doc/library/os.rst:3900
msgid ""
"Set a scheduling parameters for the process with PID *pid*. A *pid* of 0 "
"means the calling process. *param* is a :class:`sched_param` instance."
msgstr ""
"PID가 *pid*\\인 프로세스의 스케줄 매개 변수를 설정합니다. *pid* 가 0이면 호출하는 프로세스를 의미합니다. "
"*param* 은 :class:`sched_param` 인스턴스입니다."

#: ../Doc/library/os.rst:3906
msgid ""
"Return the scheduling parameters as a :class:`sched_param` instance for "
"the process with PID *pid*. A *pid* of 0 means the calling process."
msgstr ""
"PID가 *pid*\\인 프로세스의 스케줄 매개 변수를 :class:`sched_param` 인스턴스로 반환합니다. *pid* 가 "
"0이면 호출하는 프로세스를 의미합니다."

#: ../Doc/library/os.rst:3912
msgid ""
"Return the round-robin quantum in seconds for the process with PID *pid*."
" A *pid* of 0 means the calling process."
msgstr ""
"PID가 *pid*\\인 프로세스의 라운드 로빈 퀀텀을 초 단위로 반환합니다. *pid* 가 0이면 호출하는 프로세스를 의미합니다."

#: ../Doc/library/os.rst:3918
msgid "Voluntarily relinquish the CPU."
msgstr "자발적으로 CPU를 양도합니다."

#: ../Doc/library/os.rst:3923
msgid ""
"Restrict the process with PID *pid* (or the current process if zero) to a"
" set of CPUs.  *mask* is an iterable of integers representing the set of "
"CPUs to which the process should be restricted."
msgstr ""
"PID가 *pid*\\인 프로세스(또는 0이면 현재 프로세스)를 CPU 집합으로 제한합니다. *mask* 는 프로세스가 제한되어야 "
"하는 CPU 집합을 나타내는 정수의 이터러블입니다."

#: ../Doc/library/os.rst:3930
msgid ""
"Return the set of CPUs the process with PID *pid* (or the current process"
" if zero) is restricted to."
msgstr "PID가 *pid*\\인 프로세스(또는 0이면 현재 프로세스)가 제한되는 CPU 집합을 반환합니다."

#: ../Doc/library/os.rst:3937
msgid "Miscellaneous System Information"
msgstr "기타 시스템 정보"

#: ../Doc/library/os.rst:3942
msgid ""
"Return string-valued system configuration values. *name* specifies the "
"configuration value to retrieve; it may be a string which is the name of "
"a defined system value; these names are specified in a number of "
"standards (POSIX, Unix 95, Unix 98, and others).  Some platforms define "
"additional names as well. The names known to the host operating system "
"are given as the keys of the ``confstr_names`` dictionary.  For "
"configuration variables not included in that mapping, passing an integer "
"for *name* is also accepted."
msgstr ""
"문자열 값 시스템 구성 값을 반환합니다. *name* 은 조회할 구성 값을 지정합니다; 정의된 시스템 값의 이름인 문자열일 수 "
"있습니다; 이 이름은 여러 표준(POSIX, 유닉스 95, 유닉스 98 및 기타)에서 지정됩니다. 일부 플랫폼은 추가 이름도 "
"정의합니다. 호스트 운영 체제에 알려진 이름은 ``confstr_names`` 딕셔너리의 키로 제공됩니다. 해당 매핑에 포함되지 "
"않은 구성 변수를 위해, *name*\\에 정수를 전달하는 것도 허용됩니다."

#: ../Doc/library/os.rst:3950
msgid ""
"If the configuration value specified by *name* isn't defined, ``None`` is"
" returned."
msgstr "*name* 으로 지정된 구성 값이 정의되어 있지 않으면, ``None``\\이 반환됩니다."

#: ../Doc/library/os.rst:3953
msgid ""
"If *name* is a string and is not known, :exc:`ValueError` is raised.  If "
"a specific value for *name* is not supported by the host system, even if "
"it is included in ``confstr_names``, an :exc:`OSError` is raised with "
":const:`errno.EINVAL` for the error number."
msgstr ""
"*name* 이 문자열이고 알 수 없으면, :exc:`ValueError`\\가 발생합니다. *name*\\에 대한 특정 값이 "
"호스트 시스템에서 지원되지 않으면, ``confstr_names``\\에 포함되어 있어도, 에러 번호 "
":const:`errno.EINVAL`\\로 :exc:`OSError`\\가 발생합니다."

#: ../Doc/library/os.rst:3963
msgid ""
"Dictionary mapping names accepted by :func:`confstr` to the integer "
"values defined for those names by the host operating system. This can be "
"used to determine the set of names known to the system."
msgstr ""
":func:`confstr`\\에서 허용하는 이름을 호스트 운영 체제가 해당 이름에 대해 정의한 정숫값으로 매핑하는 딕셔너리입니다."
" 이것은 시스템에 알려진 이름 집합을 판별하는 데 사용될 수 있습니다."

#: ../Doc/library/os.rst:3972
msgid "Return the number of CPUs in the system. Returns ``None`` if undetermined."
msgstr "시스템의 CPU 수를 반환합니다. 파악할 수 없으면, ``None``\\을 반환합니다."

#: ../Doc/library/os.rst:3974
msgid ""
"This number is not equivalent to the number of CPUs the current process "
"can use.  The number of usable CPUs can be obtained with "
"``len(os.sched_getaffinity(0))``"
msgstr ""
"이 숫자는 현재 프로세스에서 사용할 수 있는 CPU 수와 같지 않습니다. 사용 가능한 CPU 수는 "
"``len(os.sched_getaffinity(0))``\\로 얻을 수 있습니다."

#: ../Doc/library/os.rst:3984
msgid ""
"Return the number of processes in the system run queue averaged over the "
"last 1, 5, and 15 minutes or raises :exc:`OSError` if the load average "
"was unobtainable."
msgstr ""
"마지막 1, 5, 15분에 걸쳐 평균한 시스템 실행 대기열의 프로세스 수를 반환하거나, 로드 평균을 얻을 수 없으면, "
":exc:`OSError`\\를 발생시킵니다."

#: ../Doc/library/os.rst:3993
msgid ""
"Return integer-valued system configuration values. If the configuration "
"value specified by *name* isn't defined, ``-1`` is returned.  The "
"comments regarding the *name* parameter for :func:`confstr` apply here as"
" well; the dictionary that provides information on the known names is "
"given by ``sysconf_names``."
msgstr ""
"정숫값 시스템 구성 값을 반환합니다. *name* 으로 지정된 구성 값이 정의되어 있지 않으면, ``-1``\\이 반환됩니다. "
":func:`confstr`\\의 *name* 매개 변수에 관한 주석은 여기에도 적용됩니다; 알려진 이름에 대한 정보를 제공하는 "
"딕셔너리는 ``sysconf_names``\\에 의해 제공됩니다."

#: ../Doc/library/os.rst:4003
msgid ""
"Dictionary mapping names accepted by :func:`sysconf` to the integer "
"values defined for those names by the host operating system. This can be "
"used to determine the set of names known to the system."
msgstr ""
":func:`sysconf`\\에서 허용하는 이름을 호스트 운영 체제가 해당 이름에 대해 정의한 정숫값으로 매핑하는 딕셔너리입니다."
" 이것은 시스템에 알려진 이름 집합을 판별하는 데 사용될 수 있습니다."

#: ../Doc/library/os.rst:4009
msgid ""
"The following data values are used to support path manipulation "
"operations.  These are defined for all platforms."
msgstr "다음 데이터값들은 경로 조작 연산을 지원하는 데 사용됩니다. 이는 모든 플랫폼에서 정의됩니다."

#: ../Doc/library/os.rst:4012
msgid ""
"Higher-level operations on pathnames are defined in the :mod:`os.path` "
"module."
msgstr "경로명에 대한 고수준 연산은 :mod:`os.path` 모듈에서 정의됩니다."

#: ../Doc/library/os.rst:4018
msgid ""
"The constant string used by the operating system to refer to the current "
"directory. This is ``'.'`` for Windows and POSIX. Also available via "
":mod:`os.path`."
msgstr ""
"현재 디렉터리를 가리키기 위해 운영 체제에서 사용하는 상수 문자열. 이것은 윈도우 및 POSIX의 경우 ``'.'``\\입니다. "
":mod:`os.path`\\를 통해서도 제공됩니다."

#: ../Doc/library/os.rst:4026
msgid ""
"The constant string used by the operating system to refer to the parent "
"directory. This is ``'..'`` for Windows and POSIX. Also available via "
":mod:`os.path`."
msgstr ""
"부모 디렉터리를 가리키기 위해 운영 체제에서 사용하는 상수 문자열입니다. 이것은 윈도우 및 POSIX의 경우 "
"``'..'``\\입니다. :mod:`os.path`\\를 통해서도 제공됩니다."

#: ../Doc/library/os.rst:4035
msgid ""
"The character used by the operating system to separate pathname "
"components. This is ``'/'`` for POSIX and ``'\\\\'`` for Windows.  Note "
"that knowing this is not sufficient to be able to parse or concatenate "
"pathnames --- use :func:`os.path.split` and :func:`os.path.join` --- but "
"it is occasionally useful. Also available via :mod:`os.path`."
msgstr ""
"경로명 구성 요소를 분리하기 위해 운영 체제에서 사용하는 문자. 이것은 POSIX의 경우 ``'/'``\\이고, 윈도우의 경우 "
"``'\\\\'``\\입니다. 이것을 아는 것만으로는 경로명을 구문 분석하거나 이어붙일 수는 없습니다만 --- "
":func:`os.path.split`\\와 :func:`os.path.join`\\를 사용하세요 --- 가끔 유용합니다. "
":mod:`os.path`\\를 통해서도 제공됩니다."

#: ../Doc/library/os.rst:4045
msgid ""
"An alternative character used by the operating system to separate "
"pathname components, or ``None`` if only one separator character exists."
"  This is set to ``'/'`` on Windows systems where ``sep`` is a backslash."
" Also available via :mod:`os.path`."
msgstr ""
"경로명 구성 요소를 분리하기 위해 운영 체제에서 사용하는 대체 문자이거나, 단 하나의 구분 문자만 있는 경우 "
"``None``\\입니다. ``sep``\\가 백 슬래시인 윈도우 시스템에서는 ``'/'``\\로 설정됩니다. "
":mod:`os.path`\\를 통해서도 제공됩니다."

#: ../Doc/library/os.rst:4054
msgid ""
"The character which separates the base filename from the extension; for "
"example, the ``'.'`` in :file:`os.py`. Also available via :mod:`os.path`."
msgstr ""
"기본 파일명과 확장자를 구분하는 문자; 예를 들어, :file:`os.py`\\에서 ``'.'``. :mod:`os.path`\\를"
" 통해서도 제공됩니다."

#: ../Doc/library/os.rst:4062
msgid ""
"The character conventionally used by the operating system to separate "
"search path components (as in :envvar:`PATH`), such as ``':'`` for POSIX "
"or ``';'`` for Windows. Also available via :mod:`os.path`."
msgstr ""
"검색 경로 구성 요소(:envvar:`PATH`\\에서와 같이)를 분리하기 위해 운영 체제에서 관습적으로 사용하는 문자, 가령 "
"POSIX의 ``':'`` 또는 윈도우의 ``';'``. :mod:`os.path`\\를 통해서도 제공됩니다."

#: ../Doc/library/os.rst:4069
msgid ""
"The default search path used by :func:`exec\\*p\\* <execl>` and "
":func:`spawn\\*p\\* <spawnl>` if the environment doesn't have a "
"``'PATH'`` key. Also available via :mod:`os.path`."
msgstr ""
"환경에 ``'PATH'`` 키가 없을 때, :func:`exec\\*p\\* <execl>` 및 :func:`spawn\\*p\\*"
" <spawnl>`\\에서 사용하는 기본 검색 경로. :mod:`os.path`\\를 통해서도 제공됩니다."

#: ../Doc/library/os.rst:4076
msgid ""
"The string used to separate (or, rather, terminate) lines on the current "
"platform.  This may be a single character, such as ``'\\n'`` for POSIX, "
"or multiple characters, for example, ``'\\r\\n'`` for Windows. Do not use"
" *os.linesep* as a line terminator when writing files opened in text mode"
" (the default); use a single ``'\\n'`` instead, on all platforms."
msgstr ""
"현재 플랫폼에서 행을 분리(또는 종료)하는 데 사용되는 문자열. 이는 POSIX의 ``'\\n'``\\와 같은 단일 문자이거나, "
"윈도우의 ``'\\r\\n'``\\와 같은 여러 문자일 수 있습니다. 텍스트 모드로 열린(기본값) 파일에 쓸 때 줄 종결자로 "
"*os.linesep*\\를 사용하지 마십시오; 대신 모든 플랫폼에서 단일 ``'\\n'``\\를 사용하십시오."

#: ../Doc/library/os.rst:4085
msgid ""
"The file path of the null device. For example: ``'/dev/null'`` for POSIX,"
" ``'nul'`` for Windows.  Also available via :mod:`os.path`."
msgstr ""
"널(null) 장치의 파일 경로. 예를 들어: POSIX의 경우 ``'/dev/null'``, 윈도우의 경우 ``'nul'``. "
":mod:`os.path`\\를 통해서도 제공됩니다."

#: ../Doc/library/os.rst:4096
msgid ""
"Flags for use with the :func:`~sys.setdlopenflags` and "
":func:`~sys.getdlopenflags` functions.  See the Unix manual page "
":manpage:`dlopen(3)` for what the different flags mean."
msgstr ""
":func:`~sys.setdlopenflags` 및 :func:`~sys.getdlopenflags` 함수에 사용하는 플래그. 각"
" 플래그가 의미하는 바는 유닉스 매뉴얼 페이지 :manpage:`dlopen(3)`\\를 참조하십시오."

#: ../Doc/library/os.rst:4104
msgid "Random numbers"
msgstr "난수"

#: ../Doc/library/os.rst:4109
msgid ""
"Get up to *size* random bytes. The function can return less bytes than "
"requested."
msgstr "최대 *size* 크기의 난수 바이트열을 업습니다. 이 함수는 요청한 것보다 짧은 바이트열를 반환할 수 있습니다."

#: ../Doc/library/os.rst:4112
msgid ""
"These bytes can be used to seed user-space random number generators or "
"for cryptographic purposes."
msgstr "이 바이트열은 사용자 공간 난수 발생기를 시드 하거나 암호화 목적으로 사용할 수 있습니다."

#: ../Doc/library/os.rst:4115
msgid ""
"``getrandom()`` relies on entropy gathered from device drivers and other "
"sources of environmental noise. Unnecessarily reading large quantities of"
" data will have a negative impact on  other users  of the ``/dev/random``"
" and ``/dev/urandom`` devices."
msgstr ""
"``getrandom()``\\는 장치 드라이버 및 기타 환경 소음원에서 수집한 엔트로피에 의존합니다. 대량의 데이터를 불필요하게 "
"읽는 것은 ``/dev/random`` 및 ``/dev/urandom`` 장치의 다른 사용자에게 부정적인 영향을 미칩니다."

#: ../Doc/library/os.rst:4120
msgid ""
"The flags argument is a bit mask that can contain zero or more of the "
"following values ORed together: :py:data:`os.GRND_RANDOM` and "
":py:data:`GRND_NONBLOCK`."
msgstr ""
"flags 인자는 다음 값 중 0개 이상의 값들과 함께 OR 될 수 있는 비트 마스크입니다: "
":py:data:`os.GRND_RANDOM` 및 :py:data:`GRND_NONBLOCK`."

#: ../Doc/library/os.rst:4124
msgid ""
"See also the `Linux getrandom() manual page <http://man7.org/linux/man-"
"pages/man2/getrandom.2.html>`_."
msgstr ""
"`리눅스 getrandom() 매뉴얼 페이지 <http://man7.org/linux/man-"
"pages/man2/getrandom.2.html>`_\\도 참조하십시오."

#: ../Doc/library/os.rst:4128
msgid ":ref:`Availability <availability>`: Linux 3.17 and newer."
msgstr ":ref:`가용성 <availability>`: 리눅스 3.17 이상."

#: ../Doc/library/os.rst:4133
msgid "Return a string of *size* random bytes suitable for cryptographic use."
msgstr "암호화에 적합한 *size* 크기의 난수 바이트열을 돌려줍니다."

#: ../Doc/library/os.rst:4135
msgid ""
"This function returns random bytes from an OS-specific randomness source."
"  The returned data should be unpredictable enough for cryptographic "
"applications, though its exact quality depends on the OS implementation."
msgstr ""
"이 함수는 OS 종속적인 임의성 소스에서 난수 바이트열을 반환합니다. 반환된 데이터는 암호화 응용에 충분하도록 예측할 수 없어야 "
"하지만, 정확한 품질은 OS 구현에 따라 달라집니다."

#: ../Doc/library/os.rst:4139
msgid ""
"On Linux, if the ``getrandom()`` syscall is available, it is used in "
"blocking mode: block until the system urandom entropy pool is initialized"
" (128 bits of entropy are collected by the kernel). See the :pep:`524` "
"for the rationale. On Linux, the :func:`getrandom` function can be used "
"to get random bytes in non-blocking mode (using the :data:`GRND_NONBLOCK`"
" flag) or to poll until the system urandom entropy pool is initialized."
msgstr ""
"리눅스에서, ``getrandom()`` 시스템 호출을 사용할 수 있으면, 블로킹 모드로 사용됩니다: 시스템의 urandom "
"엔트로피 풀이 초기화될 때까지 블록 됩니다 (커널이 128비트의 엔트로피를 수집합니다). 이유는 :pep:`524`\\를 "
"참조하십시오. 리눅스에서, :func:`getrandom` 함수는 (:data:`GRND_NONBLOCK` 플래그를 사용하여) 비 "
"블로킹 모드로 난수 바이트열을 얻거나, 시스템 urandom 엔트로피 풀이 초기화될 때까지 폴링 할 수 있습니다."

#: ../Doc/library/os.rst:4146
msgid ""
"On a Unix-like system, random bytes are read from the ``/dev/urandom`` "
"device. If the ``/dev/urandom`` device is not available or not readable, "
"the :exc:`NotImplementedError` exception is raised."
msgstr ""
"유닉스류 시스템에서, ``/dev/urandom`` 장치에서 난수 바이트열을 읽습니다. ``/dev/urandom`` 장치를 사용할"
" 수 없거나 읽을 수 없으면, :exc:`NotImplementedError` 예외가 발생합니다."

#: ../Doc/library/os.rst:4150
msgid "On Windows, it will use ``CryptGenRandom()``."
msgstr "윈도우에서, ``CryptGenRandom()``\\을 사용합니다."

#: ../Doc/library/os.rst:4153
msgid ""
"The :mod:`secrets` module provides higher level functions. For an easy-"
"to-use interface to the random number generator provided by your "
"platform, please see :class:`random.SystemRandom`."
msgstr ""
":mod:`secrets` 모듈은 고수준 함수를 제공합니다. 플랫폼에서 제공되는 난수 발생기에 대한 사용하기 쉬운 인터페이스는 "
":class:`random.SystemRandom`\\를 참조하십시오."

#: ../Doc/library/os.rst:4157
msgid ""
"On Linux, ``getrandom()`` is now used in blocking mode to increase the "
"security."
msgstr "리눅스에서, ``getrandom()``\\은 이제 보안을 강화하기 위해 블로킹 모드로 사용됩니다."

#: ../Doc/library/os.rst:4161
msgid ""
"On Linux, if the ``getrandom()`` syscall blocks (the urandom entropy pool"
" is not initialized yet), fall back on reading ``/dev/urandom``."
msgstr ""
"리눅스에서, ``getrandom()`` 시스템 호출이 블록 하면 (urandom 엔트로피 풀이 아직 초기화되지 않았으면), "
"``/dev/urandom``\\을 읽는 것으로 대체됩니다."

#: ../Doc/library/os.rst:4165
msgid ""
"On Linux 3.17 and newer, the ``getrandom()`` syscall is now used when "
"available.  On OpenBSD 5.6 and newer, the C ``getentropy()`` function is "
"now used. These functions avoid the usage of an internal file descriptor."
msgstr ""
"리눅스 3.17 및 이후 버전에서, 이제 ``getrandom()`` 시스템 호출을 사용할 수 있으면 사용합니다. OpenBSD "
"5.6 이상에서, C ``getentropy()`` 함수가 이제 사용됩니다. 이 함수들은 내부 파일 기술자의 사용을 피합니다."

#: ../Doc/library/os.rst:4173
msgid ""
"By  default, when reading from ``/dev/random``, :func:`getrandom` blocks "
"if no random bytes are available, and when reading from ``/dev/urandom``,"
" it blocks if the entropy pool has not yet been initialized."
msgstr ""
"기본적으로, ``/dev/random``\\에서 읽을 때, :func:`getrandom`\\는 사용할 수 있는 난수 바이트열이 "
"없으면 블록 하고, ``/dev/urandom``\\에서 읽을 때는, 엔트로피 풀이 아직 초기화되지 않았으면 블록 합니다."

#: ../Doc/library/os.rst:4177
msgid ""
"If the :py:data:`GRND_NONBLOCK` flag is set, then :func:`getrandom` does "
"not block in these cases, but instead immediately raises "
":exc:`BlockingIOError`."
msgstr ""
":py:data:`GRND_NONBLOCK` 플래그가 설정되면, :func:`getrandom`\\는 이럴 때 블록 하지 않고, "
"대신 즉시 :exc:`BlockingIOError`\\를 발생시킵니다."

#: ../Doc/library/os.rst:4184
msgid ""
"If  this  bit  is  set,  then  random bytes are drawn from the "
"``/dev/random`` pool instead of the ``/dev/urandom`` pool."
msgstr "이 비트가 설정되면, ``/dev/urandom`` 풀 대신 ``/dev/random`` 풀에서 난수 바이트열을 얻습니다."
