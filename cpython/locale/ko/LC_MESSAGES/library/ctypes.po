# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-10-23 06:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/library/ctypes.rst:2
msgid ":mod:`ctypes` --- A foreign function library for Python"
msgstr ":mod:`ctypes` --- 파이썬용 외부 함수 라이브러리"

#: ../Doc/library/ctypes.rst:11
msgid ""
":mod:`ctypes` is a foreign function library for Python.  It provides C "
"compatible data types, and allows calling functions in DLLs or shared "
"libraries.  It can be used to wrap these libraries in pure Python."
msgstr ""
":mod:`ctypes`\\는 파이썬용 외부 함수(foreign function) 라이브러리입니다. C 호환 데이터형을 제공하며, DLL"
" 또는 공유 라이브러리에 있는 함수를 호출할 수 있습니다. 이 라이브러리들을 순수 파이썬으로 감싸는 데 사용할 수 있습니다."

#: ../Doc/library/ctypes.rst:19
msgid "ctypes tutorial"
msgstr "ctypes 자습서"

#: ../Doc/library/ctypes.rst:21
msgid ""
"Note: The code samples in this tutorial use :mod:`doctest` to make sure "
"that they actually work.  Since some code samples behave differently "
"under Linux, Windows, or Mac OS X, they contain doctest directives in "
"comments."
msgstr ""
"참고: 이 자습서의 코드 예제는 :mod:`doctest`\\를 사용하여 실제로 작동하는지 확인합니다. 일부 코드 예제는 리눅스, 윈도우"
" 또는 맥 OS X에서 다르게 동작하므로, 주석에 doctest 지시문이 포함되어 있습니다."

#: ../Doc/library/ctypes.rst:25
msgid ""
"Note: Some code samples reference the ctypes :class:`c_int` type.  On "
"platforms where ``sizeof(long) == sizeof(int)`` it is an alias to "
":class:`c_long`. So, you should not be confused if :class:`c_long` is "
"printed if you would expect :class:`c_int` --- they are actually the same"
" type."
msgstr ""
"참고: 일부 코드 예제는 ctypes :class:`c_int` 형을 참조합니다. ``sizeof(long) == "
"sizeof(int)``\\인 플랫폼에서, 이는 :class:`c_long`\\의 별칭입니다. 따라서 :class:`c_int`\\를 "
"기대할 때 :class:`c_long`\\가 인쇄되더라도 혼란스러워하지 않아도 됩니다 --- 이것들은 실제로 같은 형입니다."

#: ../Doc/library/ctypes.rst:33
msgid "Loading dynamic link libraries"
msgstr "동적 링크 라이브러리 로드하기"

#: ../Doc/library/ctypes.rst:35
msgid ""
":mod:`ctypes` exports the *cdll*, and on Windows *windll* and *oledll* "
"objects, for loading dynamic link libraries."
msgstr ""
":mod:`ctypes`\\는 동적 링크 라이브러리 로드를 위해 *cdll*\\을, 그리고 윈도우에서는 *windll* 및 "
"*oledll* 객체를, 노출합니다."

#: ../Doc/library/ctypes.rst:38
msgid ""
"You load libraries by accessing them as attributes of these objects. "
"*cdll* loads libraries which export functions using the standard "
"``cdecl`` calling convention, while *windll* libraries call functions "
"using the ``stdcall`` calling convention. *oledll* also uses the "
"``stdcall`` calling convention, and assumes the functions return a "
"Windows :c:type:`HRESULT` error code. The error code is used to "
"automatically raise an :class:`OSError` exception when the function call "
"fails."
msgstr ""
"이 객체의 어트리뷰트를 액세스하여 라이브러리를 로드합니다. *cdll*\\은 표준 ``cdecl`` 호출 규칙을 사용하는 함수를 내보내는"
" 라이브러리를 로드하는 반면, *windll* 라이브러리는 ``stdcall`` 호출 규칙을 사용하여 함수를 호출합니다. *oledll*"
" 또한 ``stdcall`` 호출 규칙을 사용하고, 함수가 윈도우 :c:type:`HRESULT` 에러 코드를 반환한다고 가정합니다. "
"에러 코드는 함수 호출이 실패할 때 :class:`OSError` 예외를 자동으로 발생시키는 데 사용됩니다."

#: ../Doc/library/ctypes.rst:46
msgid ""
"Windows errors used to raise :exc:`WindowsError`, which is now an alias "
"of :exc:`OSError`."
msgstr "윈도우 에러는 :exc:`WindowsError`\\를 일으켜왔습니다. 이제는 :exc:`OSError`\\의 별칭입니다."

#: ../Doc/library/ctypes.rst:51
msgid ""
"Here are some examples for Windows. Note that ``msvcrt`` is the MS "
"standard C library containing most standard C functions, and uses the "
"cdecl calling convention::"
msgstr ""
"다음은 윈도우 용 예제입니다. ``msvcrt``\\는 대부분 표준 C 함수가 포함된 MS 표준 C 라이브러리며, cdecl 호출 규칙을"
" 사용합니다::"

#: ../Doc/library/ctypes.rst:63
msgid "Windows appends the usual ``.dll`` file suffix automatically."
msgstr "윈도우는 일반적인 ``.dll`` 파일 접미사를 자동으로 추가합니다."

#: ../Doc/library/ctypes.rst:66
msgid ""
"Accessing the standard C library through ``cdll.msvcrt`` will use an "
"outdated version of the library that may be incompatible with the one "
"being used by Python. Where possible, use native Python functionality, or"
" else import and use the ``msvcrt`` module."
msgstr ""
"``cdll.msvcrt``\\를 통해 표준 C 라이브러리에 액세스하면 파이썬에서 사용되는 라이브러리와 호환되지 않는 오래된 라이브러리 "
"버전이 사용됩니다. 가능하면 파이썬 자체의 기능을 사용하거나, ``msvcrt`` 모듈을 임포트 해서 사용하십시오."

#: ../Doc/library/ctypes.rst:71
msgid ""
"On Linux, it is required to specify the filename *including* the "
"extension to load a library, so attribute access can not be used to load "
"libraries. Either the :meth:`LoadLibrary` method of the dll loaders "
"should be used, or you should load the library by creating an instance of"
" CDLL by calling the constructor::"
msgstr ""
"리눅스에서, 라이브러리를 로드하기 위해서는 확장자를 *포함하는* 파일명을 지정해야 하므로, 어트리뷰트 액세스를 사용하여 라이브러리를 로드"
" 할 수 없습니다. dll 로더의 :meth:`LoadLibrary` 메서드를 사용하거나 CDLL의 생성자를 호출하여 인스턴스를 만들어 "
"라이브러리를 로드해야 합니다::"

#: ../Doc/library/ctypes.rst:89
msgid "Accessing functions from loaded dlls"
msgstr "로드된 dll에서 함수에 액세스하기"

#: ../Doc/library/ctypes.rst:91
msgid "Functions are accessed as attributes of dll objects::"
msgstr "함수는 dll 객체의 어트리뷰트로 액세스 됩니다::"

#: ../Doc/library/ctypes.rst:106
msgid ""
"Note that win32 system dlls like ``kernel32`` and ``user32`` often export"
" ANSI as well as UNICODE versions of a function. The UNICODE version is "
"exported with an ``W`` appended to the name, while the ANSI version is "
"exported with an ``A`` appended to the name. The win32 "
"``GetModuleHandle`` function, which returns a *module handle* for a given"
" module name, has the following C prototype, and a macro is used to "
"expose one of them as ``GetModuleHandle`` depending on whether UNICODE is"
" defined or not::"
msgstr ""
"``kernel32`` 와 ``user32``\\와 같은 win32 시스템 dll은 종종 ANSI뿐만 아니라 UNICODE 버전의 함수를"
" 내보냅니다. UNICODE 버전은 이름에 ``W``\\가 추가된 상태로 내보내지고, ANSI 버전은 이름에 ``A``\\가 추가되어 "
"내보내 집니다. 지정된 모듈 이름의 *모듈 핸들*\\을 반환하는 win32 ``GetModuleHandle`` 함수는, 다음과 같은 C "
"프로토타입을 가지며, UNICODE가 정의되어 있는지에 따라 그중 하나를 ``GetModuleHandle``\\로 노출하기 위해 매크로가"
" 사용됩니다::"

#: ../Doc/library/ctypes.rst:119
msgid ""
"*windll* does not try to select one of them by magic, you must access the"
" version you need by specifying ``GetModuleHandleA`` or "
"``GetModuleHandleW`` explicitly, and then call it with bytes or string "
"objects respectively."
msgstr ""
"*windll*\\는 마술적으로 이 중 하나를 선택하려고 하지 않으므로, ``GetModuleHandleA`` 나 "
"``GetModuleHandleW``\\를 명시적으로 지정하여 필요한 버전에 액세스해야 하고, 그런 다음 각각 바이트열이나 문자열 객체로"
" 호출해야 합니다."

#: ../Doc/library/ctypes.rst:123
msgid ""
"Sometimes, dlls export functions with names which aren't valid Python "
"identifiers, like ``\"??2@YAPAXI@Z\"``. In this case you have to use "
":func:`getattr` to retrieve the function::"
msgstr ""
"때때로, dll은 ``\"??2@YAPAXI@Z\"``\\와 같은 유효한 파이썬 식별자가 아닌 이름으로 함수를 내보냅니다. 이때는 "
":func:`getattr`\\를 사용하여 함수를 조회해야 합니다::"

#: ../Doc/library/ctypes.rst:131
msgid ""
"On Windows, some dlls export functions not by name but by ordinal. These "
"functions can be accessed by indexing the dll object with the ordinal "
"number::"
msgstr ""
"윈도우에서, 일부 dll은 이름이 아니라 서수(ordinal)로 함수를 내보냅니다. 이 함수는 서수로 dll 객체를 인덱싱하여 액세스할 "
"수 있습니다::"

#: ../Doc/library/ctypes.rst:148
msgid "Calling functions"
msgstr "함수 호출하기"

#: ../Doc/library/ctypes.rst:150
msgid ""
"You can call these functions like any other Python callable. This example"
" uses the ``time()`` function, which returns system time in seconds since"
" the Unix epoch, and the ``GetModuleHandleA()`` function, which returns a"
" win32 module handle."
msgstr ""
"다른 파이썬 콜러블처럼 이 함수를 호출할 수 있습니다. 이 예제에서는 시스템 시간을 유닉스 에포크부터의 초로 반환하는 ``time()``"
" 함수와 win32 모듈 핸들을 반환하는 ``GetModuleHandleA()`` 함수를 사용합니다."

#: ../Doc/library/ctypes.rst:155
msgid ""
"This example calls both functions with a NULL pointer (``None`` should be"
" used as the NULL pointer)::"
msgstr "이 예는 NULL 포인터로 두 함수를 호출합니다 (``None``\\을 NULL 포인터로 사용해야 합니다)::"

#: ../Doc/library/ctypes.rst:166
msgid ""
":mod:`ctypes` may raise a :exc:`ValueError` after calling the function, "
"if it detects that an invalid number of arguments were passed.  This "
"behavior should not be relied upon.  It is deprecated in 3.6.2, and will "
"be removed in 3.7."
msgstr ""
"유효하지 않은 수의 인자가 전달된 것을 감지하면, :mod:`ctypes`\\는 함수를 호출한 후 :exc:`ValueError`\\를 "
"발생시킬 수 있습니다. 이 동작에 의존하지 않아야 합니다. 3.6.2에서 폐지되었으며, 3.7에서 제거될 것입니다."

#: ../Doc/library/ctypes.rst:171
msgid ""
":exc:`ValueError` is raised when you call an ``stdcall`` function with "
"the ``cdecl`` calling convention, or vice versa::"
msgstr ""
"``cdecl`` 호출 규칙을 사용하여 ``stdcall`` 함수를 호출하면 :exc:`ValueError`\\가 발생하고, 그 반대도 "
"마찬가지입니다::"

#: ../Doc/library/ctypes.rst:186
msgid ""
"To find out the correct calling convention you have to look into the C "
"header file or the documentation for the function you want to call."
msgstr "올바른 호출 규칙을 찾으려면 C 헤더 파일이나 호출할 함수에 대한 설명서를 살펴봐야 합니다."

#: ../Doc/library/ctypes.rst:189
msgid ""
"On Windows, :mod:`ctypes` uses win32 structured exception handling to "
"prevent crashes from general protection faults when functions are called "
"with invalid argument values::"
msgstr ""
"윈도우에서, :mod:`ctypes`\\는 함수가 유효하지 않은 인자 값을 사용하여 호출될 때, 일반적인 보호 오류로 인한 충돌을 "
"방지하기 위해 win32 구조적 예외 처리를 사용합니다::"

#: ../Doc/library/ctypes.rst:199
msgid ""
"There are, however, enough ways to crash Python with :mod:`ctypes`, so "
"you should be careful anyway.  The :mod:`faulthandler` module can be "
"helpful in debugging crashes (e.g. from segmentation faults produced by "
"erroneous C library calls)."
msgstr ""
"그러나, :mod:`ctypes`\\로 파이썬을 충돌시킬 방법이 많으므로, 어쨌든 주의해야 합니다. :mod:`faulthandler` "
"모듈은 충돌을 디버깅하는 데 도움이 될 수 있습니다 (예를 들어, 오류가 있는 C 라이브러리 호출로 인한 세그먼트 오류)."

#: ../Doc/library/ctypes.rst:204
msgid ""
"``None``, integers, bytes objects and (unicode) strings are the only "
"native Python objects that can directly be used as parameters in these "
"function calls. ``None`` is passed as a C ``NULL`` pointer, bytes objects"
" and strings are passed as pointer to the memory block that contains "
"their data (:c:type:`char *` or :c:type:`wchar_t *`).  Python integers "
"are passed as the platforms default C :c:type:`int` type, their value is "
"masked to fit into the C type."
msgstr ""
"``None``, 정수, 바이트열 객체 및 (유니코드) 문자열은 이러한 함수 호출에서 매개 변수로 직접 사용할 수 있는 유일한 파이썬 "
"자체의 객체입니다. ``None``\\는 C ``NULL`` 포인터로 전달되고, 바이트열 객체와 문자열은 데이터가 저장된 메모리 블록에 "
"대한 포인터로 전달됩니다 (:c:type:`char *` 이나 :c:type:`wchar_t *`). 파이썬 정수는 플랫폼의 기본 C "
":c:type:`int` 형으로 전달되며, 그 값은 C 형에 맞게 마스크 됩니다."

#: ../Doc/library/ctypes.rst:211
msgid ""
"Before we move on calling functions with other parameter types, we have "
"to learn more about :mod:`ctypes` data types."
msgstr "다른 매개 변수 형으로 함수를 호출하기 전에, :mod:`ctypes` 데이터형에 대해 더 알아야 합니다."

#: ../Doc/library/ctypes.rst:218 ../Doc/library/ctypes.rst:2066
msgid "Fundamental data types"
msgstr "기본 데이터형"

#: ../Doc/library/ctypes.rst:220
msgid ":mod:`ctypes` defines a number of primitive C compatible data types:"
msgstr ":mod:`ctypes`\\는 많은 기본적인 C 호환 데이터형을 정의합니다.:"

#: ../Doc/library/ctypes.rst:223
msgid "ctypes type"
msgstr "ctypes 형"

#: ../Doc/library/ctypes.rst:223
msgid "C type"
msgstr "C 형"

#: ../Doc/library/ctypes.rst:223
msgid "Python type"
msgstr "파이썬 형"

#: ../Doc/library/ctypes.rst:225
msgid ":class:`c_bool`"
msgstr ":class:`c_bool`"

#: ../Doc/library/ctypes.rst:225
msgid ":c:type:`_Bool`"
msgstr ":c:type:`_Bool`"

#: ../Doc/library/ctypes.rst:225
msgid "bool (1)"
msgstr "bool (1)"

#: ../Doc/library/ctypes.rst:227
msgid ":class:`c_char`"
msgstr ":class:`c_char`"

#: ../Doc/library/ctypes.rst:227 ../Doc/library/ctypes.rst:231
msgid ":c:type:`char`"
msgstr ":c:type:`char`"

#: ../Doc/library/ctypes.rst:227
msgid "1-character bytes object"
msgstr "1-문자 바이트열 객체"

#: ../Doc/library/ctypes.rst:229
msgid ":class:`c_wchar`"
msgstr ":class:`c_wchar`"

#: ../Doc/library/ctypes.rst:229
msgid ":c:type:`wchar_t`"
msgstr ":c:type:`wchar_t`"

#: ../Doc/library/ctypes.rst:229
msgid "1-character string"
msgstr "1-문자 문자열"

#: ../Doc/library/ctypes.rst:231
msgid ":class:`c_byte`"
msgstr ":class:`c_byte`"

#: ../Doc/library/ctypes.rst:231 ../Doc/library/ctypes.rst:233
#: ../Doc/library/ctypes.rst:235 ../Doc/library/ctypes.rst:237
#: ../Doc/library/ctypes.rst:239 ../Doc/library/ctypes.rst:241
#: ../Doc/library/ctypes.rst:243 ../Doc/library/ctypes.rst:245
#: ../Doc/library/ctypes.rst:247 ../Doc/library/ctypes.rst:249
#: ../Doc/library/ctypes.rst:252 ../Doc/library/ctypes.rst:254
msgid "int"
msgstr "int"

#: ../Doc/library/ctypes.rst:233
msgid ":class:`c_ubyte`"
msgstr ":class:`c_ubyte`"

#: ../Doc/library/ctypes.rst:233
msgid ":c:type:`unsigned char`"
msgstr ":c:type:`unsigned char`"

#: ../Doc/library/ctypes.rst:235
msgid ":class:`c_short`"
msgstr ":class:`c_short`"

#: ../Doc/library/ctypes.rst:235
msgid ":c:type:`short`"
msgstr ":c:type:`short`"

#: ../Doc/library/ctypes.rst:237
msgid ":class:`c_ushort`"
msgstr ":class:`c_ushort`"

#: ../Doc/library/ctypes.rst:237
msgid ":c:type:`unsigned short`"
msgstr ":c:type:`unsigned short`"

#: ../Doc/library/ctypes.rst:239
msgid ":class:`c_int`"
msgstr ":class:`c_int`"

#: ../Doc/library/ctypes.rst:239
msgid ":c:type:`int`"
msgstr ":c:type:`int`"

#: ../Doc/library/ctypes.rst:241
msgid ":class:`c_uint`"
msgstr ":class:`c_uint`"

#: ../Doc/library/ctypes.rst:241
msgid ":c:type:`unsigned int`"
msgstr ":c:type:`unsigned int`"

#: ../Doc/library/ctypes.rst:243
msgid ":class:`c_long`"
msgstr ":class:`c_long`"

#: ../Doc/library/ctypes.rst:243
msgid ":c:type:`long`"
msgstr ":c:type:`long`"

#: ../Doc/library/ctypes.rst:245
msgid ":class:`c_ulong`"
msgstr ":class:`c_ulong`"

#: ../Doc/library/ctypes.rst:245
msgid ":c:type:`unsigned long`"
msgstr ":c:type:`unsigned long`"

#: ../Doc/library/ctypes.rst:247
msgid ":class:`c_longlong`"
msgstr ":class:`c_longlong`"

#: ../Doc/library/ctypes.rst:247
msgid ":c:type:`__int64` or :c:type:`long long`"
msgstr ":c:type:`__int64` 나 :c:type:`long long`"

#: ../Doc/library/ctypes.rst:249
msgid ":class:`c_ulonglong`"
msgstr ":class:`c_ulonglong`"

#: ../Doc/library/ctypes.rst:249
msgid ":c:type:`unsigned __int64` or :c:type:`unsigned long long`"
msgstr ":c:type:`unsigned __int64` 나 :c:type:`unsigned long long`"

#: ../Doc/library/ctypes.rst:252
msgid ":class:`c_size_t`"
msgstr ":class:`c_size_t`"

#: ../Doc/library/ctypes.rst:252
msgid ":c:type:`size_t`"
msgstr ":c:type:`size_t`"

#: ../Doc/library/ctypes.rst:254
msgid ":class:`c_ssize_t`"
msgstr ":class:`c_ssize_t`"

#: ../Doc/library/ctypes.rst:254
msgid ":c:type:`ssize_t` or :c:type:`Py_ssize_t`"
msgstr ":c:type:`ssize_t` 나 :c:type:`Py_ssize_t`"

#: ../Doc/library/ctypes.rst:257
msgid ":class:`c_float`"
msgstr ":class:`c_float`"

#: ../Doc/library/ctypes.rst:257
msgid ":c:type:`float`"
msgstr ":c:type:`float`"

#: ../Doc/library/ctypes.rst:257 ../Doc/library/ctypes.rst:259
#: ../Doc/library/ctypes.rst:261
msgid "float"
msgstr "float"

#: ../Doc/library/ctypes.rst:259
msgid ":class:`c_double`"
msgstr ":class:`c_double`"

#: ../Doc/library/ctypes.rst:259
msgid ":c:type:`double`"
msgstr ":c:type:`double`"

#: ../Doc/library/ctypes.rst:261
msgid ":class:`c_longdouble`"
msgstr ":class:`c_longdouble`"

#: ../Doc/library/ctypes.rst:261
msgid ":c:type:`long double`"
msgstr ":c:type:`long double`"

#: ../Doc/library/ctypes.rst:263
msgid ":class:`c_char_p`"
msgstr ":class:`c_char_p`"

#: ../Doc/library/ctypes.rst:263
msgid ":c:type:`char *` (NUL terminated)"
msgstr ":c:type:`char *` (NUL 종료됨)"

#: ../Doc/library/ctypes.rst:263
msgid "bytes object or ``None``"
msgstr "바이트열 객체나 ``None``"

#: ../Doc/library/ctypes.rst:265
msgid ":class:`c_wchar_p`"
msgstr ":class:`c_wchar_p`"

#: ../Doc/library/ctypes.rst:265
msgid ":c:type:`wchar_t *` (NUL terminated)"
msgstr ":c:type:`wchar_t *` (NUL 종료됨)"

#: ../Doc/library/ctypes.rst:265
msgid "string or ``None``"
msgstr "문자열이나 ``None``"

#: ../Doc/library/ctypes.rst:267
msgid ":class:`c_void_p`"
msgstr ":class:`c_void_p`"

#: ../Doc/library/ctypes.rst:267
msgid ":c:type:`void *`"
msgstr ":c:type:`void *`"

#: ../Doc/library/ctypes.rst:267
msgid "int or ``None``"
msgstr "int 나 ``None``"

#: ../Doc/library/ctypes.rst:271
msgid "The constructor accepts any object with a truth value."
msgstr "생성자는 논릿값을 가진 모든 객체를 받아들입니다."

#: ../Doc/library/ctypes.rst:273
msgid ""
"All these types can be created by calling them with an optional "
"initializer of the correct type and value::"
msgstr "이 모든 형은 올바른 형과 값의 선택적 초기화자로 호출해서 만들어질 수 있습니다::"

#: ../Doc/library/ctypes.rst:284
msgid ""
"Since these types are mutable, their value can also be changed "
"afterwards::"
msgstr "이러한 형은 가변이므로, 값을 나중에 변경할 수도 있습니다::"

#: ../Doc/library/ctypes.rst:296
msgid ""
"Assigning a new value to instances of the pointer types "
":class:`c_char_p`, :class:`c_wchar_p`, and :class:`c_void_p` changes the "
"*memory location* they point to, *not the contents* of the memory block "
"(of course not, because Python bytes objects are immutable)::"
msgstr ""
":class:`c_char_p`, :class:`c_wchar_p` 및 :class:`c_void_p` 포인터형의 인스턴스에 새 값을 "
"대입하면 포인터가 가리키는 *메모리 위치*\\가 변경됩니다, 메모리 블록의 *내용이 아닙니다* (당연히 아닙니다, 파이썬 바이트열 객체는"
" 불변입니다)::"

#: ../Doc/library/ctypes.rst:316
msgid ""
"You should be careful, however, not to pass them to functions expecting "
"pointers to mutable memory. If you need mutable memory blocks, ctypes has"
" a :func:`create_string_buffer` function which creates these in various "
"ways.  The current memory block contents can be accessed (or changed) "
"with the ``raw`` property; if you want to access it as NUL terminated "
"string, use the ``value`` property::"
msgstr ""
"그러나, 이것들을 가변 메모리에 대한 포인터를 예상하는 함수에 전달하지 않도록 주의해야 합니다. 가변 메모리 블록이 필요하다면, "
"ctypes에는 다양한 방법으로 이를 만드는 :func:`create_string_buffer` 함수가 있습니다. 현재 메모리 블록 "
"내용은 ``raw`` 프로퍼티를 사용하여 액세스(또는 변경)할 수 있습니다; NUL 종료 문자열로 액세스하려면 ``value`` "
"프로퍼티를 사용하십시오::"

#: ../Doc/library/ctypes.rst:340
msgid ""
"The :func:`create_string_buffer` function replaces the :func:`c_buffer` "
"function (which is still available as an alias), as well as the "
":func:`c_string` function from earlier ctypes releases.  To create a "
"mutable memory block containing unicode characters of the C type "
":c:type:`wchar_t` use the :func:`create_unicode_buffer` function."
msgstr ""
":func:`create_string_buffer` 함수는 이전 ctypes 배포에 있는 :func:`c_string` 함수뿐만 아니라 "
":func:`c_buffer` 함수(아직 별칭으로 사용할 수 있습니다)를 대체합니다. C 형 :c:type:`wchar_t`\\의 "
"유니코드 문자를 포함하는 가변 메모리 블록을 생성하려면 :func:`create_unicode_buffer` 함수를 사용하십시오."

#: ../Doc/library/ctypes.rst:350
msgid "Calling functions, continued"
msgstr "함수 호출하기, 계속"

#: ../Doc/library/ctypes.rst:352
msgid ""
"Note that printf prints to the real standard output channel, *not* to "
":data:`sys.stdout`, so these examples will only work at the console "
"prompt, not from within *IDLE* or *PythonWin*::"
msgstr ""
"printf는 :data:`sys.stdout`\\이 *아니라* 실제 표준 출력으로 인쇄하므로, 이 예제는 콘솔 프롬프트에서만 작동하고 "
"*IDLE* 이나 *PythonWin*\\에서는 작동하지 않음에 유의하십시오::"

#: ../Doc/library/ctypes.rst:372
msgid ""
"As has been mentioned before, all Python types except integers, strings, "
"and bytes objects have to be wrapped in their corresponding :mod:`ctypes`"
" type, so that they can be converted to the required C data type::"
msgstr ""
"이전에 언급했듯이, 정수, 문자열 및 바이트열 객체를 제외한 모든 파이썬 형은 필요한 C 데이터형으로 변환될 수 있도록 해당하는 "
":mod:`ctypes` 형으로 래핑 되어야 합니다::"

#: ../Doc/library/ctypes.rst:385
msgid "Calling functions with your own custom data types"
msgstr "사용자 정의 데이터형을 사용하여 함수 호출하기"

#: ../Doc/library/ctypes.rst:387
msgid ""
"You can also customize :mod:`ctypes` argument conversion to allow "
"instances of your own classes be used as function arguments.  "
":mod:`ctypes` looks for an :attr:`_as_parameter_` attribute and uses this"
" as the function argument.  Of course, it must be one of integer, string,"
" or bytes::"
msgstr ""
"또한 :mod:`ctypes` 인자 변환을 사용자 정의하여 사용자 고유 클래스의 인스턴스를 함수 인자로 사용할 수 있습니다. "
":mod:`ctypes`\\는 :attr:`_as_parameter_` 어트리뷰트를 찾고, 이를 함수 인자로 사용합니다. 물론 정수, "
"문자열 또는 바이트열 중 하나여야 합니다::"

#: ../Doc/library/ctypes.rst:402
msgid ""
"If you don't want to store the instance's data in the "
":attr:`_as_parameter_` instance variable, you could define a "
":class:`property` which makes the attribute available on request."
msgstr ""
":attr:`_as_parameter_` 인스턴스 변수에 인스턴스의 데이터를 저장하지 않으려면, :class:`property`\\를 "
"정의하여 요청 시 어트리뷰트를 사용할 수 있게 할 수 있습니다."

#: ../Doc/library/ctypes.rst:410
msgid "Specifying the required argument types (function prototypes)"
msgstr "필수 인자 형 (함수 프로토타입) 지정하기"

#: ../Doc/library/ctypes.rst:412
msgid ""
"It is possible to specify the required argument types of functions "
"exported from DLLs by setting the :attr:`argtypes` attribute."
msgstr ":attr:`argtypes` 어트리뷰트를 설정하여 DLL에서 내보낸 함수의 필수 인자 형을 지정할 수 있습니다."

#: ../Doc/library/ctypes.rst:415
msgid ""
":attr:`argtypes` must be a sequence of C data types (the ``printf`` "
"function is probably not a good example here, because it takes a variable"
" number and different types of parameters depending on the format string,"
" on the other hand this is quite handy to experiment with this feature)::"
msgstr ""
":attr:`argtypes`\\는 C 데이터형의 시퀀스 여야 합니다 (``printf`` 함수는 포맷 문자열에 따라 개수와 형이 다른 "
"매개 변수를 받아들이기 때문에, 여기서는 좋은 예가 아닐 수 있습니다. 반면에 이 기능을 실험하기에 매우 편리하기도 합니다)::"

#: ../Doc/library/ctypes.rst:426
msgid ""
"Specifying a format protects against incompatible argument types (just as"
" a prototype for a C function), and tries to convert the arguments to "
"valid types::"
msgstr ""
"포맷을 지정하면 호환되지 않는 인자 형으로부터 보호하고(C 함수의 프로토타입처럼), 유효한 형으로 인자를 변환하려고 시도합니다::"

#: ../Doc/library/ctypes.rst:438
msgid ""
"If you have defined your own classes which you pass to function calls, "
"you have to implement a :meth:`from_param` class method for them to be "
"able to use them in the :attr:`argtypes` sequence. The :meth:`from_param`"
" class method receives the Python object passed to the function call, it "
"should do a typecheck or whatever is needed to make sure this object is "
"acceptable, and then return the object itself, its :attr:`_as_parameter_`"
" attribute, or whatever you want to pass as the C function argument in "
"this case. Again, the result should be an integer, string, bytes, a "
":mod:`ctypes` instance, or an object with an :attr:`_as_parameter_` "
"attribute."
msgstr ""
"함수 호출에 전달하는 여러분 자신의 클래스를 정의했으면, :attr:`argtypes` 시퀀스에서 해당 클래스를 사용할 수 있도록, "
":meth:`from_param` 클래스 메서드를 구현해야 합니다. :meth:`from_param` 클래스 메서드는 함수 호출에 전달된"
" 파이썬 객체를 받습니다. 형 검사나 이 객체가 수용 가능한지 확인하는 데 필요한 모든 작업을 수행한 다음, 객체 자체나 "
":attr:`_as_parameter_` 어트리뷰트나 무엇이건 이 경우에 C 함수 인자로 전달되길 원하는 것을 반환해야 합니다. 다시 "
"말하지만, 결과는 정수, 문자열, 바이트열, :mod:`ctypes` 인스턴스 또는 :attr:`_as_parameter_` 어트리뷰트가"
" 있는 객체여야 합니다."

#: ../Doc/library/ctypes.rst:452
msgid "Return types"
msgstr "반환형"

#: ../Doc/library/ctypes.rst:454
msgid ""
"By default functions are assumed to return the C :c:type:`int` type.  "
"Other return types can be specified by setting the :attr:`restype` "
"attribute of the function object."
msgstr ""
"기본적으로 함수는 C :c:type:`int` 형을 반환한다고 가정합니다. 다른 반환형은 함수 객체의 :attr:`restype` "
"어트리뷰트를 설정하여 지정할 수 있습니다."

#: ../Doc/library/ctypes.rst:458
msgid ""
"Here is a more advanced example, it uses the ``strchr`` function, which "
"expects a string pointer and a char, and returns a pointer to a string::"
msgstr ""
"다음은 더 고급 예제입니다. ``strchr`` 함수를 사용하는데, 문자열 포인터와 char을 기대하고, 문자열에 대한 포인터를 "
"반환합니다::"

#: ../Doc/library/ctypes.rst:471
msgid ""
"If you want to avoid the ``ord(\"x\")`` calls above, you can set the "
":attr:`argtypes` attribute, and the second argument will be converted "
"from a single character Python bytes object into a C char::"
msgstr ""
"위의 ``ord(\"x\")`` 호출을 피하려면, :attr:`argtypes` 어트리뷰트를 설정할 수 있으며, 두 번째 인자는 한 글자"
" 파이썬 바이트열 객체에서 C char로 변환됩니다::"

#: ../Doc/library/ctypes.rst:489
msgid ""
"You can also use a callable Python object (a function or a class for "
"example) as the :attr:`restype` attribute, if the foreign function "
"returns an integer.  The callable will be called with the *integer* the C"
" function returns, and the result of this call will be used as the result"
" of your function call. This is useful to check for error return values "
"and automatically raise an exception::"
msgstr ""
"외부 함수가 정수를 반환하면, 콜러블 파이썬 객체(예를 들어, 함수나 클래스)를 :attr:`restype` 어트리뷰트로 사용할 수도 "
"있습니다. 콜러블은 C 함수가 돌려주는 *정수*\\로 호출되며, 이 호출의 결과는 함수 호출의 결과로 사용됩니다. 이것은 에러 반환 값을"
" 검사하고 자동으로 예외를 발생시키는 데 유용합니다::"

#: ../Doc/library/ctypes.rst:512
msgid ""
"``WinError`` is a function which will call Windows ``FormatMessage()`` "
"api to get the string representation of an error code, and *returns* an "
"exception. ``WinError`` takes an optional error code parameter, if no one"
" is used, it calls :func:`GetLastError` to retrieve it."
msgstr ""
"``WinError``\\는 윈도우 ``FormatMessage()`` api를 호출하여 에러 코드의 문자열 표현을 가져오고, 예외를 "
"*반환하는* 함수입니다. ``WinError``\\는 선택적 에러 코드 매개 변수를 취합니다, 제공하지 않으면 "
":func:`GetLastError`\\를 호출하여 에러 코드를 가져옵니다."

#: ../Doc/library/ctypes.rst:517
msgid ""
"Please note that a much more powerful error checking mechanism is "
"available through the :attr:`errcheck` attribute; see the reference "
"manual for details."
msgstr ""
"훨씬 더 강력한 에러 검사 메커니즘을 :attr:`errcheck` 어트리뷰트를 통해 사용할 수 있음에 유의하십시오; 자세한 내용은 "
"레퍼런스 설명서를 참조하십시오."

#: ../Doc/library/ctypes.rst:524
msgid "Passing pointers (or: passing parameters by reference)"
msgstr "포인터 전달하기 (또는: 참조로 매개 변수 전달하기)"

#: ../Doc/library/ctypes.rst:526
msgid ""
"Sometimes a C api function expects a *pointer* to a data type as "
"parameter, probably to write into the corresponding location, or if the "
"data is too large to be passed by value. This is also known as *passing "
"parameters by reference*."
msgstr ""
"때때로 C api 함수는 매개 변수로 데이터형을 가리키는 *포인터*\\를 기대합니다, 아마도 해당 위치에 쓰기 위해서, 또는 데이터가 "
"너무 커서 값으로 전달할 수 없어서. 이것은 *참조로 매개 변수 전달하기*\\로 알려져 있기도 합니다."

#: ../Doc/library/ctypes.rst:530
msgid ""
":mod:`ctypes` exports the :func:`byref` function which is used to pass "
"parameters by reference.  The same effect can be achieved with the "
":func:`pointer` function, although :func:`pointer` does a lot more work "
"since it constructs a real pointer object, so it is faster to use "
":func:`byref` if you don't need the pointer object in Python itself::"
msgstr ""
":mod:`ctypes`\\는 매개 변수를 참조로 전달하는 데 사용되는 :func:`byref` 함수를 내보냅니다. 같은 효과를 "
":func:`pointer` 함수로도 얻을 수 있습니다. 하지만 :func:`pointer`\\는 실제 포인터 객체를 생성하기 때문에 더"
" 많은 작업을 수행하므로, 파이썬 자체에서 포인터 객체가 필요하지 않으면 :func:`byref`\\를 사용하는 것이 더 빠릅니다.::"

#: ../Doc/library/ctypes.rst:552
msgid "Structures and unions"
msgstr "구조체와 공용체"

#: ../Doc/library/ctypes.rst:554
msgid ""
"Structures and unions must derive from the :class:`Structure` and "
":class:`Union` base classes which are defined in the :mod:`ctypes` "
"module. Each subclass must define a :attr:`_fields_` attribute.  "
":attr:`_fields_` must be a list of *2-tuples*, containing a *field name* "
"and a *field type*."
msgstr ""
"구조체와 공용체는 :mod:`ctypes` 모듈에 정의된 :class:`Structure`\\와 :class:`Union` 베이스 "
"클래스에서 파생되어야 합니다. 각 서브 클래스는 :attr:`_fields_` 어트리뷰트를 정의해야 합니다. "
":attr:`_fields_`\\는 *필드 이름* 과 *필드형*\\을 포함하는 *2-튜플*\\의 리스트여야 합니다."

#: ../Doc/library/ctypes.rst:559
msgid ""
"The field type must be a :mod:`ctypes` type like :class:`c_int`, or any "
"other derived :mod:`ctypes` type: structure, union, array, pointer."
msgstr ""
"필드형은 :class:`c_int`\\와 같은 :mod:`ctypes` 형이거나 다른 파생된 :mod:`ctypes` 형(구조체, "
"공용체, 배열, 포인터)이어야 합니다."

#: ../Doc/library/ctypes.rst:562
msgid ""
"Here is a simple example of a POINT structure, which contains two "
"integers named *x* and *y*, and also shows how to initialize a structure "
"in the constructor::"
msgstr ""
"다음은 *x* 및 *y*\\라는 두 개의 정수가 포함된 POINT 구조체의 간단한 예제이며, 생성자에서 구조체를 초기화하는 방법도 "
"보여줍니다::"

#: ../Doc/library/ctypes.rst:582
msgid ""
"You can, however, build much more complicated structures.  A structure "
"can itself contain other structures by using a structure as a field type."
msgstr "그러나, 훨씬 복잡한 구조를 만들 수 있습니다. 구조체는 필드형으로 구조체를 사용하여 다른 구조체를 포함할 수 있습니다."

#: ../Doc/library/ctypes.rst:585
msgid ""
"Here is a RECT structure which contains two POINTs named *upperleft* and "
"*lowerright*::"
msgstr "다음은 *upperleft* 및 *lowerright*\\라는 두 개의 POINT를 포함하는 RECT 구조체입니다::"

#: ../Doc/library/ctypes.rst:599
msgid ""
"Nested structures can also be initialized in the constructor in several "
"ways::"
msgstr "중첩된 구조체는 여러 가지 방법으로 생성자에서 초기화할 수 있습니다::"

#: ../Doc/library/ctypes.rst:604
msgid ""
"Field :term:`descriptor`\\s can be retrieved from the *class*, they are "
"useful for debugging because they can provide useful information::"
msgstr ""
"필드 :term:`디스크립터 <descriptor>`\\는 *클래스*\\에서 조회할 수 있습니다. 유용한 정보를 제공할 수 있으므로 "
"디버깅에 유용합니다::"

#: ../Doc/library/ctypes.rst:618
msgid ""
":mod:`ctypes` does not support passing unions or structures with bit-"
"fields to functions by value.  While this may work on 32-bit x86, it's "
"not guaranteed by the library to work in the general case.  Unions and "
"structures with bit-fields should always be passed to functions by "
"pointer."
msgstr ""
":mod:`ctypes`\\는 비트 필드가 있는 공용체나 구조체를 값으로 함수에 전달할 수 없습니다. 32비트 x86에서 작동할 수 "
"있지만, 일반적으로 작동은 라이브러리가 보증하지 않습니다. 비트 필드가 있는 공용체와 구조체는 항상 포인터로 함수에 전달되어야 합니다."

#: ../Doc/library/ctypes.rst:624
msgid "Structure/union alignment and byte order"
msgstr "구조체/공용체 정렬과 바이트 순서"

#: ../Doc/library/ctypes.rst:626
msgid ""
"By default, Structure and Union fields are aligned in the same way the C "
"compiler does it. It is possible to override this behavior be specifying "
"a :attr:`_pack_` class attribute in the subclass definition. This must be"
" set to a positive integer and specifies the maximum alignment for the "
"fields. This is what ``#pragma pack(n)`` also does in MSVC."
msgstr ""
"기본적으로, Structure와 Union 필드는 C 컴파일러와 같은 방식으로 정렬됩니다. 서브 클래스 정의에서 "
":attr:`_pack_` 클래스 어트리뷰트를 지정하면, 이 동작을 재정의할 수 있습니다. 이 값은 양의 정수로 설정해야 하고, 필드의 "
"최대 정렬을 지정합니다. 이것은 MSVC에서 ``#pragma pack(n)``\\가 수행하는 것입니다."

#: ../Doc/library/ctypes.rst:632
msgid ""
":mod:`ctypes` uses the native byte order for Structures and Unions.  To "
"build structures with non-native byte order, you can use one of the "
":class:`BigEndianStructure`, :class:`LittleEndianStructure`, "
":class:`BigEndianUnion`, and :class:`LittleEndianUnion` base classes.  "
"These classes cannot contain pointer fields."
msgstr ""
":mod:`ctypes`\\는 구조체와 공용체에 기본(native) 바이트 순서를 사용합니다. 기본이 아닌 바이트 순서로 구조체를 "
"만들려면 :class:`BigEndianStructure`, :class:`LittleEndianStructure`, "
":class:`BigEndianUnion` 및 :class:`LittleEndianUnion` 베이스 클래스 중 하나를 사용할 수 "
"있습니다. 이러한 클래스들은 포인터 필드를 포함할 수 없습니다."

#: ../Doc/library/ctypes.rst:642
msgid "Bit fields in structures and unions"
msgstr "구조체와 공용체의 비트 필드"

#: ../Doc/library/ctypes.rst:644
msgid ""
"It is possible to create structures and unions containing bit fields. Bit"
" fields are only possible for integer fields, the bit width is specified "
"as the third item in the :attr:`_fields_` tuples::"
msgstr ""
"비트 필드를 포함하는 구조체와 공용체를 만드는 것이 가능합니다. 비트 필드는 정수 필드에만 가능하며, 비트 폭은 "
":attr:`_fields_` 튜플의 세 번째 항목으로 지정됩니다::"

#: ../Doc/library/ctypes.rst:662
msgid "Arrays"
msgstr "배열"

#: ../Doc/library/ctypes.rst:664
msgid ""
"Arrays are sequences, containing a fixed number of instances of the same "
"type."
msgstr "배열은 같은 형의 고정 된 수의 인스턴스를 포함하는 시퀀스입니다."

#: ../Doc/library/ctypes.rst:666
msgid ""
"The recommended way to create array types is by multiplying a data type "
"with a positive integer::"
msgstr "배열형을 만드는 데 권장되는 방법은 데이터형에 양의 정수를 곱하는 것입니다::"

#: ../Doc/library/ctypes.rst:671
msgid ""
"Here is an example of a somewhat artificial data type, a structure "
"containing 4 POINTs among other stuff::"
msgstr "다음은 다소 인공적인 데이터형의 예입니다. 다른 항목들과 함께 4개의 POINT를 포함하는 구조체입니다::"

#: ../Doc/library/ctypes.rst:687
msgid "Instances are created in the usual way, by calling the class::"
msgstr "인스턴스는 클래스를 호출하는 일반적인 방법으로 만들어집니다::"

#: ../Doc/library/ctypes.rst:693
msgid ""
"The above code print a series of ``0 0`` lines, because the array "
"contents is initialized to zeros."
msgstr "위 코드는 배열 내용이 0으로 초기화되기 때문에, 일련의 ``0 0`` 줄을 인쇄합니다."

#: ../Doc/library/ctypes.rst:696
msgid "Initializers of the correct type can also be specified::"
msgstr "올바른 형의 초기화자를 지정할 수도 있습니다::"

#: ../Doc/library/ctypes.rst:712
msgid "Pointers"
msgstr "포인터"

#: ../Doc/library/ctypes.rst:714
msgid ""
"Pointer instances are created by calling the :func:`pointer` function on "
"a :mod:`ctypes` type::"
msgstr "포인터 인스턴스는 :mod:`ctypes` 형에 :func:`pointer` 함수를 호출해서 만듭니다::"

#: ../Doc/library/ctypes.rst:722
msgid ""
"Pointer instances have a :attr:`~_Pointer.contents` attribute which "
"returns the object to which the pointer points, the ``i`` object above::"
msgstr ""
"포인터 인스턴스는 포인터가 가리키는 객체(위에서는 ``i`` 객체)를 반환하는 :attr:`~_Pointer.contents` "
"어트리뷰트를 가집니다::"

#: ../Doc/library/ctypes.rst:729
msgid ""
"Note that :mod:`ctypes` does not have OOR (original object return), it "
"constructs a new, equivalent object each time you retrieve an attribute::"
msgstr ""
":mod:`ctypes`\\에는 OOR(원래 객체 반환, original object return)이 없다는 것에 유의하십시오. "
"어트리뷰트를 가져올 때마다 (동등하지만) 새로운 객체를 만듭니다::"

#: ../Doc/library/ctypes.rst:738
msgid ""
"Assigning another :class:`c_int` instance to the pointer's contents "
"attribute would cause the pointer to point to the memory location where "
"this is stored::"
msgstr ""
"다른 :class:`c_int` 인스턴스를 포인터의 contents 어트리뷰트에 대입하면 포인터는 이 인스턴스가 저장되어있는 메모리 "
"위치를 가리키게 됩니다::"

#: ../Doc/library/ctypes.rst:750
msgid "Pointer instances can also be indexed with integers::"
msgstr "포인터 인스턴스는 정수로도 인덱싱할 수 있습니다.::"

#: ../Doc/library/ctypes.rst:756
msgid "Assigning to an integer index changes the pointed to value::"
msgstr "정수 인덱스에 대입하면 가리키고 있는 값이 바뀝니다::"

#: ../Doc/library/ctypes.rst:765
msgid ""
"It is also possible to use indexes different from 0, but you must know "
"what you're doing, just as in C: You can access or change arbitrary "
"memory locations. Generally you only use this feature if you receive a "
"pointer from a C function, and you *know* that the pointer actually "
"points to an array instead of a single item."
msgstr ""
"0이 아닌 인덱스를 사용할 수도 있지만, C에서와 마찬가지로 자신이 하는 일을 알아야 합니다: 임의의 메모리 위치를 액세스하거나 변경할 "
"수 있습니다. 일반적으로 C 함수에서 포인터를 받고, 포인터가 실제로 단일 항목 대신 배열을 가리키는 것을 *알* 때만 이 기능을 "
"사용합니다."

#: ../Doc/library/ctypes.rst:771
msgid ""
"Behind the scenes, the :func:`pointer` function does more than simply "
"create pointer instances, it has to create pointer *types* first. This is"
" done with the :func:`POINTER` function, which accepts any :mod:`ctypes` "
"type, and returns a new type::"
msgstr ""
"장막 뒤에서, :func:`pointer` 함수는 단순히 포인터 인스턴스를 만드는 것 이상을 수행합니다. 먼저 포인터 *형*\\을 "
"만들어야 합니다. 이것은 임의의 :mod:`ctypes` 형을 받아들이고, 새로운 형을 반환하는 :func:`POINTER` 함수로 "
"수행됩니다::"

#: ../Doc/library/ctypes.rst:787
msgid ""
"Calling the pointer type without an argument creates a ``NULL`` pointer. "
"``NULL`` pointers have a ``False`` boolean value::"
msgstr ""
"인자 없이 포인터형을 호출하면 ``NULL`` 포인터가 만들어집니다. ``NULL`` 포인터는 ``False`` 논릿값을 갖습니다::"

#: ../Doc/library/ctypes.rst:795
msgid ""
":mod:`ctypes` checks for ``NULL`` when dereferencing pointers (but "
"dereferencing invalid non-\\ ``NULL`` pointers would crash Python)::"
msgstr ""
":mod:`ctypes`\\는 포인터를 역참조(dereference)할 때 ``NULL``\\인지 확인합니다 (하지만 "
"``NULL``\\이 아닌 잘못된 포인터를 역참조하면 파이썬을 충돌시킵니다)::"

#: ../Doc/library/ctypes.rst:814
msgid "Type conversions"
msgstr "형 변환"

#: ../Doc/library/ctypes.rst:816
msgid ""
"Usually, ctypes does strict type checking.  This means, if you have "
"``POINTER(c_int)`` in the :attr:`argtypes` list of a function or as the "
"type of a member field in a structure definition, only instances of "
"exactly the same type are accepted.  There are some exceptions to this "
"rule, where ctypes accepts other objects.  For example, you can pass "
"compatible array instances instead of pointer types.  So, for "
"``POINTER(c_int)``, ctypes accepts an array of c_int::"
msgstr ""
"일반적으로, ctypes는 엄격한 형 검사를 수행합니다. 이는 함수의 :attr:`argtypes` 목록에 "
"``POINTER(c_int)``\\가 있거나, 구조체 멤버 필드의 형이 그런 형이라면, 정확히 같은 형의 인스턴스만 허용됨을 뜻합니다."
" 이 규칙에는 ctypes가 다른 객체를 허용하는 몇 가지 예외가 있습니다. 예를 들어, 포인터형 대신 호환 가능한 배열 인스턴스를 "
"전달할 수 있습니다. 따라서 ``POINTER(c_int)``\\의 경우, ctype은 c_int 배열을 허용합니다::"

#: ../Doc/library/ctypes.rst:837
msgid ""
"In addition, if a function argument is explicitly declared to be a "
"pointer type (such as ``POINTER(c_int)``) in :attr:`argtypes`, an object "
"of the pointed type (``c_int`` in this case) can be passed to the "
"function.  ctypes will apply the required :func:`byref` conversion in "
"this case automatically."
msgstr ""
"또한, 함수 인자가 :attr:`argtypes`\\에 포인터형(가령 ``POINTER(c_int)``)으로 명시적으로 선언되면, "
"대상형(이 경우 ``c_int``)의 객체를 함수에 전달할 수 있습니다. 이때 ctypes는 필요한 :func:`byref` 변환을 "
"자동으로 적용합니다."

#: ../Doc/library/ctypes.rst:842
msgid "To set a POINTER type field to ``NULL``, you can assign ``None``::"
msgstr "POINTER 형 필드를 ``NULL``\\로 설정하려면, ``None``\\을 대입할 수 있습니다::"

#: ../Doc/library/ctypes.rst:849
msgid ""
"Sometimes you have instances of incompatible types.  In C, you can cast "
"one type into another type.  :mod:`ctypes` provides a :func:`cast` "
"function which can be used in the same way.  The ``Bar`` structure "
"defined above accepts ``POINTER(c_int)`` pointers or :class:`c_int` "
"arrays for its ``values`` field, but not instances of other types::"
msgstr ""
"때에 따라 호환되지 않는 형의 인스턴스가 있을 수 있습니다. C에서는, 한 형을 다른 형으로 강제 변환(cast)할 수 있습니다. "
":mod:`ctypes`\\는 같은 방식으로 사용할 수 있는 :func:`cast` 함수를 제공합니다. 위에 정의된 ``Bar`` "
"구조체는 ``values`` 필드에 대해 ``POINTER(c_int)`` 포인터나 :class:`c_int` 배열을 받아들이지만 다른 "
"형의 인스턴스는 허용하지 않습니다::"

#: ../Doc/library/ctypes.rst:861
msgid "For these cases, the :func:`cast` function is handy."
msgstr "이럴 때, :func:`cast` 함수가 편리합니다."

#: ../Doc/library/ctypes.rst:863
msgid ""
"The :func:`cast` function can be used to cast a ctypes instance into a "
"pointer to a different ctypes data type.  :func:`cast` takes two "
"parameters, a ctypes object that is or can be converted to a pointer of "
"some kind, and a ctypes pointer type.  It returns an instance of the "
"second argument, which references the same memory block as the first "
"argument::"
msgstr ""
":func:`cast` 함수는 ctypes 인스턴스를 다른 ctypes 데이터형에 대한 포인터로 변환하는 데 사용할 수 있습니다. "
":func:`cast`\\는 두 개의 매개 변수, 어떤 종류의 포인터로 변환될 수 있는 ctypes 객체와 ctypes 포인터형을 "
"받아들입니다. 첫 번째 인자와 같은 메모리 블록을 참조하는 두 번째 인자의 인스턴스를 반환합니다::"

#: ../Doc/library/ctypes.rst:874
msgid ""
"So, :func:`cast` can be used to assign to the ``values`` field of ``Bar``"
" the structure::"
msgstr "따라서, :func:`cast`\\는 ``Bar`` 구조체의 ``values`` 필드에 대입하는 데 사용할 수 있습니다::"

#: ../Doc/library/ctypes.rst:887
msgid "Incomplete Types"
msgstr "불완전한 형"

#: ../Doc/library/ctypes.rst:889
msgid ""
"*Incomplete Types* are structures, unions or arrays whose members are not"
" yet specified. In C, they are specified by forward declarations, which "
"are defined later::"
msgstr ""
"*불완전한 형*\\은 멤버가 아직 지정되지 않은 구조체, 공용체 또는 배열입니다. C에서, 이것들은 나중에 정의되는 전방 "
"선언(forward declaration)으로 지정됩니다::"

#: ../Doc/library/ctypes.rst:900
msgid ""
"The straightforward translation into ctypes code would be this, but it "
"does not work::"
msgstr "ctypes 코드로 그대로 옮기면 이렇게 되지만, 작동하지는 않습니다::"

#: ../Doc/library/ctypes.rst:913
msgid ""
"because the new ``class cell`` is not available in the class statement "
"itself. In :mod:`ctypes`, we can define the ``cell`` class and set the "
":attr:`_fields_` attribute later, after the class statement::"
msgstr ""
"새 ``class cell``\\은 클래스 문 자체에서 사용할 수 없기 때문입니다. :mod:`ctypes`\\에서는, ``cell`` "
"클래스를 정의한 다음, class 문 뒤에서 :attr:`_fields_` 어트리뷰트를 설정할 수 있습니다::"

#: ../Doc/library/ctypes.rst:925
msgid ""
"Lets try it. We create two instances of ``cell``, and let them point to "
"each other, and finally follow the pointer chain a few times::"
msgstr ""
"해 봅시다. 우리는 두 개의 ``cell`` 인스턴스를 만들고, 서로를 가리키도록 한 다음, 마지막으로 포인터 체인을 몇 번 "
"따라갑니다::"

#: ../Doc/library/ctypes.rst:946
msgid "Callback functions"
msgstr "콜백 함수"

#: ../Doc/library/ctypes.rst:948
msgid ""
":mod:`ctypes` allows creating C callable function pointers from Python "
"callables. These are sometimes called *callback functions*."
msgstr ""
":mod:`ctypes`\\는 파이썬 콜러블로부터 C에서 호출 가능한 함수 포인터를 만들 수 있습니다. 이들은 때로 *콜백 "
"함수(callback functions)*\\라고 불립니다."

#: ../Doc/library/ctypes.rst:951
msgid ""
"First, you must create a class for the callback function. The class knows"
" the calling convention, the return type, and the number and types of "
"arguments this function will receive."
msgstr ""
"먼저, 콜백 함수를 위한 클래스를 만들어야 합니다. 클래스는 호출 규칙, 반환형 및 이 함수가 받는 인자의 수와 형을 알고 있습니다."

#: ../Doc/library/ctypes.rst:955
msgid ""
"The :func:`CFUNCTYPE` factory function creates types for callback "
"functions using the ``cdecl`` calling convention. On Windows, the "
":func:`WINFUNCTYPE` factory function creates types for callback functions"
" using the ``stdcall`` calling convention."
msgstr ""
":func:`CFUNCTYPE` 팩토리 함수는 ``cdecl`` 호출 규칙을 사용하여 콜백 함수의 형을 만듭니다. 윈도우에서, "
":func:`WINFUNCTYPE` 팩토리 함수는 ``stdcall`` 호출 규칙을 사용하여 콜백 함수 형을 만듭니다."

#: ../Doc/library/ctypes.rst:960
msgid ""
"Both of these factory functions are called with the result type as first "
"argument, and the callback functions expected argument types as the "
"remaining arguments."
msgstr "이러한 팩토리 함수는 모두 첫 번째 인자로 결과 형을, 나머지 인자로 콜백 함수가 기대하는 인자 형들로 호출됩니다."

#: ../Doc/library/ctypes.rst:964
msgid ""
"I will present an example here which uses the standard C library's "
":c:func:`qsort` function, that is used to sort items with the help of a "
"callback function.  :c:func:`qsort` will be used to sort an array of "
"integers::"
msgstr ""
"콜백 함수의 도움을 받아 항목을 정렬하는 데 사용되는 표준 C 라이브러리의 :c:func:`qsort` 함수를 사용하는 예제를 "
"제시합니다. :c:func:`qsort`\\는 정수 배열을 정렬하는 데 사용될 것입니다::"

#: ../Doc/library/ctypes.rst:974
msgid ""
":func:`qsort` must be called with a pointer to the data to sort, the "
"number of items in the data array, the size of one item, and a pointer to"
" the comparison function, the callback. The callback will then be called "
"with two pointers to items, and it must return a negative integer if the "
"first item is smaller than the second, a zero if they are equal, and a "
"positive integer otherwise."
msgstr ""
":func:`qsort`\\는 정렬 할 데이터에 대한 포인터, 데이터 배열의 항목 수, 항목 하나의 크기 및 비교 함수에 대한 포인터인 "
"콜백으로 호출해야 합니다. 콜백은 항목에 대한 두 개의 포인터로 호출되며, 첫 번째 항목이 두 번째 항목보다 작으면 음의 정수를, 같으면"
" 0을, 그렇지 않으면 양수 정수를 반환해야 합니다."

#: ../Doc/library/ctypes.rst:980
msgid ""
"So our callback function receives pointers to integers, and must return "
"an integer. First we create the ``type`` for the callback function::"
msgstr "따라서 콜백 함수는 정수에 대한 포인터들을 받고 정수를 반환해야 합니다. 먼저 콜백 함수를 위한 ``형``\\을 만듭니다::"

#: ../Doc/library/ctypes.rst:986
msgid ""
"To get started, here is a simple callback that shows the values it gets "
"passed::"
msgstr "시작하기 위해, 전달된 값을 보여주는 간단한 콜백이 있습니다::"

#: ../Doc/library/ctypes.rst:996
msgid "The result::"
msgstr "결과::"

#: ../Doc/library/ctypes.rst:1006
msgid "Now we can actually compare the two items and return a useful result::"
msgstr "이제 실제로 두 항목을 비교하여 유용한 결과를 반환할 수 있습니다::"

#: ../Doc/library/ctypes.rst:1021
msgid "As we can easily check, our array is sorted now::"
msgstr "쉽게 확인할 수 있듯이, 배열은 이제 정렬되었습니다::"

#: ../Doc/library/ctypes.rst:1028
msgid ""
"The function factories can be used as decorator factories, so we may as "
"well write::"
msgstr "함수 팩토리는 데코레이터 팩토리로 사용할 수 있으므로, 다음과 같이 작성할 수도 있습니다::"

#: ../Doc/library/ctypes.rst:1046
msgid ""
"Make sure you keep references to :func:`CFUNCTYPE` objects as long as "
"they are used from C code. :mod:`ctypes` doesn't, and if you don't, they "
"may be garbage collected, crashing your program when a callback is made."
msgstr ""
"C 코드에서 사용되는 동안 :func:`CFUNCTYPE` 객체에 대한 참조를 유지해야 합니다. :mod:`ctypes`\\가 참조를 "
"유지하지는 않으며, 여러분이 하지 않는다면 가비지 수집되어, 콜백이 발생할 때 프로그램이 충돌할 수 있습니다."

#: ../Doc/library/ctypes.rst:1050
msgid ""
"Also, note that if the callback function is called in a thread created "
"outside of Python's control (e.g. by the foreign code that calls the "
"callback), ctypes creates a new dummy Python thread on every invocation. "
"This behavior is correct for most purposes, but it means that values "
"stored with :class:`threading.local` will *not* survive across different "
"callbacks, even when those calls are made from the same C thread."
msgstr ""
"또한, 콜백 함수가 파이썬 제어 바깥에서 만들어진 스레드(예를 들어, 콜백을 호출하는 외부 코드)에서 호출되면, ctypes는 모든 "
"호출에 대해 새로운 더미 파이썬 스레드를 만듭니다. 이 동작은 대부분 적합하지만, :class:`threading.local`\\에 "
"저장된 값은, 같은 C 스레드에서 호출되는 여러 콜백에서 살아남을 수 *없음*\\을 뜻합니다."

#: ../Doc/library/ctypes.rst:1060
msgid "Accessing values exported from dlls"
msgstr "dll에서 내 보낸 값을 액세스하기"

#: ../Doc/library/ctypes.rst:1062
msgid ""
"Some shared libraries not only export functions, they also export "
"variables. An example in the Python library itself is the "
":c:data:`Py_OptimizeFlag`, an integer set to 0, 1, or 2, depending on the"
" :option:`-O` or :option:`-OO` flag given on startup."
msgstr ""
"일부 공유 라이브러리는 함수를 내보낼 뿐만 아니라 변수도 내보냅니다. 파이썬 라이브러리 자체에 있는 예는 "
":c:data:`Py_OptimizeFlag` 인데, 시작 시 주어진 :option:`-O`\\나 :option:`-OO` 플래그에 "
"따라, 0, 1 또는 2로 설정된 정수입니다."

#: ../Doc/library/ctypes.rst:1067
msgid ""
":mod:`ctypes` can access values like this with the :meth:`in_dll` class "
"methods of the type.  *pythonapi* is a predefined symbol giving access to"
" the Python C api::"
msgstr ""
":mod:`ctypes`\\는 형의 :meth:`in_dll` 클래스 메서드를 사용하여 이와 같은 값을 액세스할 수 있습니다. "
"*pythonapi*\\는 파이썬 C API에 대한 액세스를 제공하는 미리 정의된 심볼입니다::"

#: ../Doc/library/ctypes.rst:1076
msgid ""
"If the interpreter would have been started with :option:`-O`, the sample "
"would have printed ``c_long(1)``, or ``c_long(2)`` if :option:`-OO` would"
" have been specified."
msgstr ""
"인터프리터가 :option:`-O`\\로 시작되면, 예는 ``c_long(1)``\\를, :option:`-OO`\\가 지정되면 "
"``c_long(2)``\\를 인쇄합니다."

#: ../Doc/library/ctypes.rst:1080
msgid ""
"An extended example which also demonstrates the use of pointers accesses "
"the :c:data:`PyImport_FrozenModules` pointer exported by Python."
msgstr ""
"포인터의 사용법도 보여주는 확장 예제는 파이썬이 내 보낸 :c:data:`PyImport_FrozenModules` 포인터에 "
"액세스합니다."

#: ../Doc/library/ctypes.rst:1083
msgid "Quoting the docs for that value:"
msgstr "해당 값에 대한 문서를 인용하면:"

#: ../Doc/library/ctypes.rst:1085
msgid ""
"This pointer is initialized to point to an array of :c:type:`struct "
"_frozen` records, terminated by one whose members are all *NULL* or zero."
"  When a frozen module is imported, it is searched in this table.  Third-"
"party code could play tricks with this to provide a dynamically created "
"collection of frozen modules."
msgstr ""
"이 포인터는 멤버가 모두 *NULL* 이나 0인 것으로 끝나는 :c:type:`struct _frozen` 레코드 배열을 가리키도록 "
"초기화됩니다. 프로즌 모듈이 임포트될 때, 이 테이블에서 검색됩니다. 제삼자 코드는 동적으로 만들어진 프로즌 모듈의 컬렉션을 제공하기 "
"위해 이것을 조작할 수 있습니다."

#: ../Doc/library/ctypes.rst:1090
msgid ""
"So manipulating this pointer could even prove useful. To restrict the "
"example size, we show only how this table can be read with "
":mod:`ctypes`::"
msgstr ""
"따라서, 이 포인터를 조작하는 것이 유용할 수도 있습니다. 예제 크기를 제한하기 위해, :mod:`ctypes`\\로 이 테이블을 읽는 "
"방법만 보여줍니다::"

#: ../Doc/library/ctypes.rst:1102
msgid ""
"We have defined the :c:type:`struct _frozen` data type, so we can get the"
" pointer to the table::"
msgstr ":c:type:`struct _frozen` 데이터형을 정의했으므로, 테이블에 대한 포인터를 얻을 수 있습니다::"

#: ../Doc/library/ctypes.rst:1109
msgid ""
"Since ``table`` is a ``pointer`` to the array of ``struct_frozen`` "
"records, we can iterate over it, but we just have to make sure that our "
"loop terminates, because pointers have no size. Sooner or later it would "
"probably crash with an access violation or whatever, so it's better to "
"break out of the loop when we hit the NULL entry::"
msgstr ""
"``table``\\이 ``struct_frozen`` 레코드의 배열에 대한 ``포인터``\\이므로, 이터레이션할 수 있습니다. 하지만 "
"포인터는 크기가 없으므로 루프를 종료하는 방법이 필요합니다. 조만간 액세스 위반 등으로 인해 충돌이 발생할 수 있으므로, NULL "
"엔트리가 발견되자마자 루프에서 벗어나는 것이 좋습니다::"

#: ../Doc/library/ctypes.rst:1127
msgid ""
"The fact that standard Python has a frozen module and a frozen package "
"(indicated by the negative size member) is not well known, it is only "
"used for testing. Try it out with ``import __hello__`` for example."
msgstr ""
"표준 파이썬이 프로즌 모듈과 프로즌 패키지(음수 size 멤버로 표시됨)를 가지고 있다는 사실은 잘 알려지지 않았으며, 테스트용으로만 "
"사용됩니다. 예를 들어 ``import __hello__``\\를 시도해보십시오."

#: ../Doc/library/ctypes.rst:1135
msgid "Surprises"
msgstr "의외의 것들"

#: ../Doc/library/ctypes.rst:1137
msgid ""
"There are some edges in :mod:`ctypes` where you might expect something "
"other than what actually happens."
msgstr ":mod:`ctypes`\\에는 여러분이 기대하는 것과 실제로 일어나는 것이 다른 가장자리가 있습니다."

#: ../Doc/library/ctypes.rst:1140
msgid "Consider the following example::"
msgstr "다음 예제를 고려해보십시오::"

#: ../Doc/library/ctypes.rst:1160
msgid ""
"Hm. We certainly expected the last statement to print ``3 4 1 2``. What "
"happened? Here are the steps of the ``rc.a, rc.b = rc.b, rc.a`` line "
"above::"
msgstr ""
"흠. 아마도 마지막 문장이 ``3 4 1 2``\\를 인쇄할 것으로 기대했을 겁니다. 어떻게 된 걸까요? 위의 ``rc.a, rc.b ="
" rc.b, rc.a`` 줄의 단계는 다음과 같습니다::"

#: ../Doc/library/ctypes.rst:1168
msgid ""
"Note that ``temp0`` and ``temp1`` are objects still using the internal "
"buffer of the ``rc`` object above. So executing ``rc.a = temp0`` copies "
"the buffer contents of ``temp0`` into ``rc`` 's buffer.  This, in turn, "
"changes the contents of ``temp1``. So, the last assignment ``rc.b = "
"temp1``, doesn't have the expected effect."
msgstr ""
"``temp0`` 과 ``temp1``\\은 여전히 위의 ``rc`` 객체의 내부 버퍼를 사용하는 객체입니다. 따라서 ``rc.a = "
"temp0``\\를 실행하면 ``temp0``\\의 버퍼 내용이 ``rc``\\의 버퍼로 복사됩니다. 이것은, 결과적으로 "
"``temp1``\\의 내용을 변경합니다. 따라서 마지막 대입인 ``rc.b = temp1``\\은 기대하는 효과를 주지 못합니다."

#: ../Doc/library/ctypes.rst:1174
msgid ""
"Keep in mind that retrieving sub-objects from Structure, Unions, and "
"Arrays doesn't *copy* the sub-object, instead it retrieves a wrapper "
"object accessing the root-object's underlying buffer."
msgstr ""
"Structure, Union 및 Array에서 서브 객체를 가져오는 것은 서브 객체를 *복사*\\하지 않고, 대신 루트 객체의 하부 "
"버퍼에 액세스하는 래퍼 객체를 가져온다는 점에 유의하십시오."

#: ../Doc/library/ctypes.rst:1178
msgid ""
"Another example that may behave different from what one would expect is "
"this::"
msgstr "예상과 다른 행동을 하는 또 다른 예는 다음과 같습니다::"

#: ../Doc/library/ctypes.rst:1188
msgid ""
"Why is it printing ``False``?  ctypes instances are objects containing a "
"memory block plus some :term:`descriptor`\\s accessing the contents of "
"the memory. Storing a Python object in the memory block does not store "
"the object itself, instead the ``contents`` of the object is stored.  "
"Accessing the contents again constructs a new Python object each time!"
msgstr ""
"``False``\\를 인쇄하는 이유는 무엇일까요? ctypes 인스턴스는 메모리 블록과 메모리 내용에 액세스하는 어떤 "
":term:`디스크립터 <descriptor>`\\를 포함하는 객체입니다. 메모리 블록에 파이썬 객체를 저장하면 객체 자체를 저장하지 "
"않고, 대신 객체의 ``내용``\\을 저장합니다. 내용에 다시 액세스하면 매번 새로운 파이썬 객체가 생성됩니다!"

#: ../Doc/library/ctypes.rst:1198
msgid "Variable-sized data types"
msgstr "가변 크기 데이터형"

#: ../Doc/library/ctypes.rst:1200
msgid ""
":mod:`ctypes` provides some support for variable-sized arrays and "
"structures."
msgstr ":mod:`ctypes`\\는 가변 크기 배열과 구조체에 대한 일부 지원을 제공합니다."

#: ../Doc/library/ctypes.rst:1202
msgid ""
"The :func:`resize` function can be used to resize the memory buffer of an"
" existing ctypes object.  The function takes the object as first "
"argument, and the requested size in bytes as the second argument.  The "
"memory block cannot be made smaller than the natural memory block "
"specified by the objects type, a :exc:`ValueError` is raised if this is "
"tried::"
msgstr ""
":func:`resize` 함수는 기존 ctypes 객체의 메모리 버퍼 크기를 바꾸는 데 사용할 수 있습니다. 이 함수는 객체를 첫 번째"
" 인자로 가져오고, 바이트 단위의 요청 된 크기를 두 번째 인자로 가져옵니다. 메모리 블록을 객체 형이 지정하는 원래 메모리 블록보다 "
"작게 만들 수 없습니다. 시도하면 :exc:`ValueError`\\가 발생합니다::"

#: ../Doc/library/ctypes.rst:1222
msgid ""
"This is nice and fine, but how would one access the additional elements "
"contained in this array?  Since the type still only knows about 4 "
"elements, we get errors accessing other elements::"
msgstr ""
"훌륭합니다, 하지만 이 배열에 포함된 추가 요소에 어떻게 액세스할 수 있습니까? 형은 여전히 4개의 요소만 알고 있으므로, 다른 요소에 "
"액세스하면 에러가 발생합니다::"

#: ../Doc/library/ctypes.rst:1234
msgid ""
"Another way to use variable-sized data types with :mod:`ctypes` is to use"
" the dynamic nature of Python, and (re-)define the data type after the "
"required size is already known, on a case by case basis."
msgstr ""
":mod:`ctypes`\\에서 가변 크기 데이터형을 사용하는 또 다른 방법은, 파이썬의 동적 특성을 사용하고 필요한 크기가 이미 알려진"
" 후 매번 데이터형을 (재) 정의하는 것입니다."

#: ../Doc/library/ctypes.rst:1242
msgid "ctypes reference"
msgstr "ctypes 레퍼런스"

#: ../Doc/library/ctypes.rst:1248
msgid "Finding shared libraries"
msgstr "공유 라이브러리 찾기"

#: ../Doc/library/ctypes.rst:1250
msgid ""
"When programming in a compiled language, shared libraries are accessed "
"when compiling/linking a program, and when the program is run."
msgstr "컴파일 언어로 프로그래밍할 때, 공유 라이브러리는 프로그램을 컴파일/링크할 때와 프로그램을 실행할 때 액세스 됩니다."

#: ../Doc/library/ctypes.rst:1253
msgid ""
"The purpose of the :func:`find_library` function is to locate a library "
"in a way similar to what the compiler or runtime loader does (on "
"platforms with several versions of a shared library the most recent "
"should be loaded), while the ctypes library loaders act like when a "
"program is run, and call the runtime loader directly."
msgstr ""
":func:`find_library` 함수의 목적은 컴파일러나 실행 시간 로더가 하는 것과 비슷한 방식으로 라이브러리를 찾는 것입니다 "
"(여러 버전의 공유 라이브러리가 있는 플랫폼에서는 가장 최근의 것을 로드해야 합니다). 반면에 ctypes 라이브러리 로더는 프로그램이 "
"실행될 때처럼 동작하고, 실행 시간 로더를 직접 호출합니다."

#: ../Doc/library/ctypes.rst:1259
msgid ""
"The :mod:`ctypes.util` module provides a function which can help to "
"determine the library to load."
msgstr ":mod:`ctypes.util` 모듈은 로드할 라이브러리를 판별하는 데 도움이 되는 함수를 제공합니다."

#: ../Doc/library/ctypes.rst:1267
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like *lib*, suffix like ``.so``, ``.dylib`` or version"
" number (this is the form used for the posix linker option "
":option:`!-l`).  If no library can be found, returns ``None``."
msgstr ""
"라이브러리를 찾아서 경로명을 반환하려고 시도합니다. *name*\\은 *lib* 같은 접두사, ``.so``, ``.dylib`` 또는 "
"버전 번호와 같은 접미사가 없는 라이브러리 이름입니다 (이것은 posix 링커 옵션 :option:`!-l`\\에 사용되는 양식입니다)."
" 라이브러리를 찾을 수 없으면 ``None``\\을 반환합니다."

#: ../Doc/library/ctypes.rst:1272 ../Doc/library/ctypes.rst:1860
msgid "The exact functionality is system dependent."
msgstr "정확한 기능은 시스템에 따라 다릅니다."

#: ../Doc/library/ctypes.rst:1274
msgid ""
"On Linux, :func:`find_library` tries to run external programs "
"(``/sbin/ldconfig``, ``gcc``, ``objdump`` and ``ld``) to find the library"
" file. It returns the filename of the library file."
msgstr ""
"리눅스에서, :func:`find_library`\\는 외부 프로그램(``/sbin/ldconfig``, ``gcc``, "
"``objdump`` 및 ``ld``)을 실행하여 라이브러리 파일을 찾으려고 합니다. 라이브러리 파일의 파일명을 반환합니다."

#: ../Doc/library/ctypes.rst:1278
msgid ""
"On Linux, the value of the environment variable ``LD_LIBRARY_PATH`` is "
"used when searching for libraries, if a library cannot be found by any "
"other means."
msgstr ""
"리눅스에서, 다른 수단으로 라이브러리를 찾을 수 없으면, 라이브러리 검색 시 환경 변수 ``LD_LIBRARY_PATH``\\의 값이 "
"사용됩니다."

#: ../Doc/library/ctypes.rst:1282
msgid "Here are some examples::"
msgstr "여기 예제가 있습니다::"

#: ../Doc/library/ctypes.rst:1293
msgid ""
"On OS X, :func:`find_library` tries several predefined naming schemes and"
" paths to locate the library, and returns a full pathname if successful::"
msgstr ""
"OS X에서, :func:`find_library`\\는 라이브러리를 찾기 위해 미리 정의된 몇 가지 명명 체계와 경로를 시도하고 "
"성공하면 전체 경로명을 반환합니다::"

#: ../Doc/library/ctypes.rst:1307
msgid ""
"On Windows, :func:`find_library` searches along the system search path, "
"and returns the full pathname, but since there is no predefined naming "
"scheme a call like ``find_library(\"c\")`` will fail and return ``None``."
msgstr ""
"윈도우에서, :func:`find_library`\\는 시스템 검색 경로를 따라 검색하고 전체 경로명을 반환하지만, 미리 정의된 명명 "
"체계가 없으므로 ``find_library(\"c\")``\\와 같은 호출은 실패하고 ``None``\\을 반환합니다."

#: ../Doc/library/ctypes.rst:1311
msgid ""
"If wrapping a shared library with :mod:`ctypes`, it *may* be better to "
"determine the shared library name at development time, and hardcode that "
"into the wrapper module instead of using :func:`find_library` to locate "
"the library at runtime."
msgstr ""
"공유 라이브러리를 :mod:`ctypes`\\로 래핑하려면, 실행 시간에 라이브러리를 찾기 위해 "
":func:`find_library`\\를 사용하기보다, 개발 시점에 공유 라이브러리 이름을 확인하고 래퍼 모듈에 하드 코딩 하는 것이 "
"더 좋을 수 있습니다."

#: ../Doc/library/ctypes.rst:1319
msgid "Loading shared libraries"
msgstr "공유 라이브러리 로드하기"

#: ../Doc/library/ctypes.rst:1321
msgid ""
"There are several ways to load shared libraries into the Python process."
"  One way is to instantiate one of the following classes:"
msgstr ""
"공유 라이브러리를 파이썬 프로세스에 로드하는 방법에는 여러 가지가 있습니다. 한 가지 방법은 다음 클래스 중 하나의 인스턴스를 만드는 "
"것입니다:"

#: ../Doc/library/ctypes.rst:1327
msgid ""
"Instances of this class represent loaded shared libraries. Functions in "
"these libraries use the standard C calling convention, and are assumed to"
" return :c:type:`int`."
msgstr ""
"이 클래스의 인스턴스는 로드된 공유 라이브러리를 나타냅니다. 이 라이브러리의 함수는 표준 C 호출 규칙을 사용하며, "
":c:type:`int`\\를 반환한다고 가정합니다."

#: ../Doc/library/ctypes.rst:1334
msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and "
"are assumed to return the windows specific :class:`HRESULT` code.  "
":class:`HRESULT` values contain information specifying whether the "
"function call failed or succeeded, together with additional error code.  "
"If the return value signals a failure, an :class:`OSError` is "
"automatically raised."
msgstr ""
"윈도우 전용: 이 클래스의 인스턴스는 로드된 공유 라이브러리를 나타내며, 이 라이브러리의 함수는 ``stdcall`` 호출 규칙을 "
"사용하고, 윈도우 특정 :class:`HRESULT` 코드를 반환한다고 가정합니다. :class:`HRESULT` 값에는 함수 호출이 "
"실패했는지 또는 성공했는지와 추가 에러 코드를 지정하는 정보가 들어 있습니다. 반환 값이 실패를 알리면, "
":class:`OSError`\\가 자동으로 발생합니다."

#: ../Doc/library/ctypes.rst:1341
msgid ":exc:`WindowsError` used to be raised."
msgstr ":exc:`WindowsError`\\를 발생시켰었습니다."

#: ../Doc/library/ctypes.rst:1347
msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and "
"are assumed to return :c:type:`int` by default."
msgstr ""
"윈도우 전용: 이 클래스의 인스턴스는 로드된 공유 라이브러리를 나타내며, 이 라이브러리의 함수는 ``stdcall`` 호출 규칙을 "
"사용하고, 기본적으로 :c:type:`int`\\를 반환한다고 가정합니다."

#: ../Doc/library/ctypes.rst:1351
msgid ""
"On Windows CE only the standard calling convention is used, for "
"convenience the :class:`WinDLL` and :class:`OleDLL` use the standard "
"calling convention on this platform."
msgstr ""
"윈도우 CE에서는 오직 표준 호출 규칙만 사용됩니다. 편의상 :class:`WinDLL` 와 :class:`OleDLL`\\은, 이 "
"플랫폼에서 표준 호출 규칙을 사용합니다."

#: ../Doc/library/ctypes.rst:1355
msgid ""
"The Python :term:`global interpreter lock` is released before calling any"
" function exported by these libraries, and reacquired afterwards."
msgstr ""
"파이썬 :term:`전역 인터프리터 록 <global interpreter lock>`\\은, 이 라이브러리들이 내보낸 함수를 호출하기 "
"전에 해제되고 나중에 다시 획득됩니다."

#: ../Doc/library/ctypes.rst:1361
msgid ""
"Instances of this class behave like :class:`CDLL` instances, except that "
"the Python GIL is *not* released during the function call, and after the "
"function execution the Python error flag is checked. If the error flag is"
" set, a Python exception is raised."
msgstr ""
"이 클래스의 인스턴스는 :class:`CDLL` 인스턴스처럼 동작합니다. 단, 파이썬 GIL이 함수 호출 중에 릴리스 되지 *않고*, "
"함수 실행 후 파이썬 에러 플래그가 확인된다는 점만 다릅니다. 에러 플래그가 설정되면 파이썬 예외가 발생합니다."

#: ../Doc/library/ctypes.rst:1366
msgid "Thus, this is only useful to call Python C api functions directly."
msgstr "따라서, 이것은 파이썬 C API 함수를 직접 호출하는 경우에만 유용합니다."

#: ../Doc/library/ctypes.rst:1368
msgid ""
"All these classes can be instantiated by calling them with at least one "
"argument, the pathname of the shared library.  If you have an existing "
"handle to an already loaded shared library, it can be passed as the "
"``handle`` named parameter, otherwise the underlying platforms ``dlopen``"
" or ``LoadLibrary`` function is used to load the library into the "
"process, and to get a handle to it."
msgstr ""
"이러한 모든 클래스는 공유 라이브러리의 경로명인 적어도 하나의 인자를 사용하여 인스턴스를 만들 수 있습니다. 이미 로드된 공유 "
"라이브러리에 대한 기존 핸들이 있으면, 이를 ``handle`` 이라고 이름 붙은 매개 변수로 전달할 수 있습니다. 그렇지 않으면 하부 "
"플랫폼의 ``dlopen`` 이나 ``LoadLibrary`` 함수를 사용하여 라이브러리를 프로세스에 로드하고 이에 대한 핸들을 "
"확보합니다."

#: ../Doc/library/ctypes.rst:1375
msgid ""
"The *mode* parameter can be used to specify how the library is loaded.  "
"For details, consult the :manpage:`dlopen(3)` manpage.  On Windows, "
"*mode* is ignored.  On posix systems, RTLD_NOW is always added, and is "
"not configurable."
msgstr ""
"*mode* 매개 변수는 라이브러리가 로드되는 방법을 지정하는 데 사용될 수 있습니다. 자세한 내용은, "
":manpage:`dlopen(3)` 매뉴얼 페이지를 참조하십시오. 윈도우에서는, *mode*\\가 무시됩니다. posix 시스템에서는 "
"RTLD_NOW가 항상 추가되며 구성할 수 없습니다."

#: ../Doc/library/ctypes.rst:1380
msgid ""
"The *use_errno* parameter, when set to true, enables a ctypes mechanism "
"that allows accessing the system :data:`errno` error number in a safe "
"way. :mod:`ctypes` maintains a thread-local copy of the systems "
":data:`errno` variable; if you call foreign functions created with "
"``use_errno=True`` then the :data:`errno` value before the function call "
"is swapped with the ctypes private copy, the same happens immediately "
"after the function call."
msgstr ""
"*use_errno* 매개 변수를 참으로 설정하면 시스템 :data:`errno` 에러 번호에 안전하게 액세스할 수 있는 ctypes "
"메커니즘을 활성화합니다. :mod:`ctypes`\\는 시스템 :data:`errno` 변수의 스레드 로컬 사본을 유지합니다; "
"``use_errno=True``\\로 만든 외부 함수를 호출하면 함수 호출 전에 :data:`errno` 값이 ctypes 내부 "
"복사본과 스와프되며 함수 호출 직후에도 마찬가지 작업을 합니다."

#: ../Doc/library/ctypes.rst:1387
msgid ""
"The function :func:`ctypes.get_errno` returns the value of the ctypes "
"private copy, and the function :func:`ctypes.set_errno` changes the "
"ctypes private copy to a new value and returns the former value."
msgstr ""
":func:`ctypes.get_errno` 함수는 ctypes 내부 사본의 값을 반환하고, :func:`ctypes.set_errno`"
" 함수는 ctypes 내부 사본을 새 값으로 변경하고 이전 값을 반환합니다."

#: ../Doc/library/ctypes.rst:1391
msgid ""
"The *use_last_error* parameter, when set to true, enables the same "
"mechanism for the Windows error code which is managed by the "
":func:`GetLastError` and :func:`SetLastError` Windows API functions; "
":func:`ctypes.get_last_error` and :func:`ctypes.set_last_error` are used "
"to request and change the ctypes private copy of the windows error code."
msgstr ""
"*use_last_error* 매개 변수를 참으로 설정하면, :func:`GetLastError` 와 "
":func:`SetLastError` 윈도우 API 함수에서 관리하는 윈도우 에러 코드에 대해 같은 메커니즘을 활성화합니다. "
":func:`ctypes.get_last_error`\\와 :func:`ctypes.set_last_error`\\는 윈도우 에러 코드의"
" ctypes 내부 사본을 요청하고 변경하는 데 사용됩니다."

#: ../Doc/library/ctypes.rst:1400
msgid ""
"Flag to use as *mode* parameter.  On platforms where this flag is not "
"available, it is defined as the integer zero."
msgstr "*mode* 매개 변수에 사용하는 플래그. 이 플래그를 사용할 수 없는 플랫폼에서는, 정수 0으로 정의됩니다."

#: ../Doc/library/ctypes.rst:1407
msgid ""
"Flag to use as *mode* parameter.  On platforms where this is not "
"available, it is the same as *RTLD_GLOBAL*."
msgstr "*mode* 매개 변수에 사용하는 플래그. 이 플래그를 사용할 수 없는 플랫폼에서는, *RTLD_GLOBAL*\\과 같습니다."

#: ../Doc/library/ctypes.rst:1414
msgid ""
"The default mode which is used to load shared libraries.  On OSX 10.3, "
"this is *RTLD_GLOBAL*, otherwise it is the same as *RTLD_LOCAL*."
msgstr ""
"공유 라이브러리를 로드하는 데 사용되는 기본 모드. OSX 10.3에서는 *RTLD_GLOBAL*\\이고, 그렇지 않으면 "
"*RTLD_LOCAL*\\과 같습니다."

#: ../Doc/library/ctypes.rst:1417
msgid ""
"Instances of these classes have no public methods.  Functions exported by"
" the shared library can be accessed as attributes or by index.  Please "
"note that accessing the function through an attribute caches the result "
"and therefore accessing it repeatedly returns the same object each time."
"  On the other hand, accessing it through an index returns a new object "
"each time::"
msgstr ""
"이 클래스들의 인스턴스는 공개 메서드가 없습니다. 공유 라이브러리가 내보낸 함수는 어트리뷰트나 인덱스로 액세스할 수 있습니다. "
"어트리뷰트를 통해 함수에 액세스하면 결과가 캐시 되므로 반복적으로 액세스할 때 매번 같은 객체가 반환됨에 유의하십시오. 반면에 인덱스를 "
"통해 액세스하면 매번 새로운 객체가 반환됩니다::"

#: ../Doc/library/ctypes.rst:1430
msgid ""
"The following public attributes are available, their name starts with an "
"underscore to not clash with exported function names:"
msgstr "다음 공개 어트리뷰트를 사용할 수 있습니다. 내보낸 함수 이름과의 충돌을 피하고자 이름은 밑줄로 시작합니다:"

#: ../Doc/library/ctypes.rst:1436
msgid "The system handle used to access the library."
msgstr "라이브러리에 액세스하는 데 사용되는 시스템 핸들."

#: ../Doc/library/ctypes.rst:1441
msgid "The name of the library passed in the constructor."
msgstr "생성자에서 전달된 라이브러리의 이름."

#: ../Doc/library/ctypes.rst:1443
msgid ""
"Shared libraries can also be loaded by using one of the prefabricated "
"objects, which are instances of the :class:`LibraryLoader` class, either "
"by calling the :meth:`LoadLibrary` method, or by retrieving the library "
"as attribute of the loader instance."
msgstr ""
"공유 라이브러리는 :class:`LibraryLoader` 클래스의 인스턴스인 사전 작성된 객체 중 하나를 사용하여 로드 할 수도 "
"있습니다. 로더의 :meth:`LoadLibrary` 메서드를 호출하거나 로더 인스턴스의 어트리뷰트로 라이브러리를 조회합니다."

#: ../Doc/library/ctypes.rst:1451
msgid ""
"Class which loads shared libraries.  *dlltype* should be one of the "
":class:`CDLL`, :class:`PyDLL`, :class:`WinDLL`, or :class:`OleDLL` types."
msgstr ""
"공유 라이브러리를 로드하는 클래스. *dlltype*\\은 :class:`CDLL`, :class:`PyDLL`, "
":class:`WinDLL` 또는 :class:`OleDLL` 형 중 하나여야 합니다."

#: ../Doc/library/ctypes.rst:1454
msgid ""
":meth:`__getattr__` has special behavior: It allows loading a shared "
"library by accessing it as attribute of a library loader instance.  The "
"result is cached, so repeated attribute accesses return the same library "
"each time."
msgstr ""
":meth:`__getattr__`\\에는 특수한 동작이 있습니다: 라이브러리 로더 인스턴스의 어트리뷰트를 액세스하여 공유 라이브러리를 "
"로드 할 수 있게 합니다. 결과는 캐시 되므로 반복되는 어트리뷰트 액세스는 매번 같은 라이브러리를 반환합니다."

#: ../Doc/library/ctypes.rst:1460
msgid ""
"Load a shared library into the process and return it.  This method always"
" returns a new instance of the library."
msgstr "공유 라이브러리를 프로세스에 로드하고 반환합니다. 이 메서드는 항상 라이브러리의 새 인스턴스를 반환합니다."

#: ../Doc/library/ctypes.rst:1464
msgid "These prefabricated library loaders are available:"
msgstr "다음과 같은 사전 작성된 로더를 사용할 수 있습니다:"

#: ../Doc/library/ctypes.rst:1469
msgid "Creates :class:`CDLL` instances."
msgstr ":class:`CDLL` 인스턴스를 만듭니다."

#: ../Doc/library/ctypes.rst:1475
msgid "Windows only: Creates :class:`WinDLL` instances."
msgstr "윈도우 전용: :class:`WinDLL` 인스턴스를 만듭니다."

#: ../Doc/library/ctypes.rst:1481
msgid "Windows only: Creates :class:`OleDLL` instances."
msgstr "윈도우 전용: :class:`OleDLL` 인스턴스를 만듭니다."

#: ../Doc/library/ctypes.rst:1487
msgid "Creates :class:`PyDLL` instances."
msgstr ":class:`PyDLL` 인스턴스를 만듭니다."

#: ../Doc/library/ctypes.rst:1490
msgid ""
"For accessing the C Python api directly, a ready-to-use Python shared "
"library object is available:"
msgstr "C 파이썬 API에 직접 액세스하기 위해, 바로 사용할 수 있는 파이썬 공유 라이브러리 객체가 제공됩니다:"

#: ../Doc/library/ctypes.rst:1496
msgid ""
"An instance of :class:`PyDLL` that exposes Python C API functions as "
"attributes.  Note that all these functions are assumed to return C "
":c:type:`int`, which is of course not always the truth, so you have to "
"assign the correct :attr:`restype` attribute to use these functions."
msgstr ""
"파이썬 C API 함수를 어트리뷰트로 노출하는 :class:`PyDLL`\\의 인스턴스. 이 모든 함수는 C "
":c:type:`int`\\를 반환한다고 가정하는데, 물론 항상 옳지는 않습니다. 그런 함수를 사용하려면 올바른 "
":attr:`restype` 어트리뷰트를 대입해야 합니다."

#: ../Doc/library/ctypes.rst:1505
msgid "Foreign functions"
msgstr "외부 함수"

#: ../Doc/library/ctypes.rst:1507
msgid ""
"As explained in the previous section, foreign functions can be accessed "
"as attributes of loaded shared libraries.  The function objects created "
"in this way by default accept any number of arguments, accept any ctypes "
"data instances as arguments, and return the default result type specified"
" by the library loader. They are instances of a private class:"
msgstr ""
"이전 섹션에서 설명한 것처럼, 외부 함수는 로드된 공유 라이브러리의 어트리뷰트로 액세스할 수 있습니다. 이런 방식으로 만들어진 함수 "
"객체는 기본적으로 임의의 개수 인자를 허용하고, 임의의 ctypes 데이터 인스턴스를 인자로 받아들이고, 라이브러리 로더에 의해 지정된 "
"기본 결과형을 반환합니다. 이것들은 내부 클래스의 인스턴스입니다:"

#: ../Doc/library/ctypes.rst:1516
msgid "Base class for C callable foreign functions."
msgstr "C 호출 가능한 외부 함수의 베이스 클래스."

#: ../Doc/library/ctypes.rst:1518
msgid ""
"Instances of foreign functions are also C compatible data types; they "
"represent C function pointers."
msgstr "외부 함수의 인스턴스는 C 호환 데이터형이기도 합니다; C 함수 포인터를 나타냅니다."

#: ../Doc/library/ctypes.rst:1521
msgid ""
"This behavior can be customized by assigning to special attributes of the"
" foreign function object."
msgstr "이 동작은 외부 함수 객체의 특수 어트리뷰트에 대입하여 사용자 정의할 수 있습니다."

#: ../Doc/library/ctypes.rst:1526
msgid ""
"Assign a ctypes type to specify the result type of the foreign function. "
"Use ``None`` for :c:type:`void`, a function not returning anything."
msgstr ""
"ctypes 형을 대입하여 외부 함수의 결과형을 지정합니다. 아무것도 반환하지 않는 함수인 :c:type:`void`\\는 "
"``None``\\를 사용하십시오."

#: ../Doc/library/ctypes.rst:1529
msgid ""
"It is possible to assign a callable Python object that is not a ctypes "
"type, in this case the function is assumed to return a C :c:type:`int`, "
"and the callable will be called with this integer, allowing further "
"processing or error checking.  Using this is deprecated, for more "
"flexible post processing or error checking use a ctypes data type as "
":attr:`restype` and assign a callable to the :attr:`errcheck` attribute."
msgstr ""
"ctypes 형이 아닌 콜러블 파이썬 객체를 대입할 수 있습니다. 이때 함수는 C :c:type:`int`\\를 반환한다고 가정하고, 이"
" 콜러블 객체는 이 정수로 호출되어, 사후 처리나 에러 검사를 허용합니다. 이 기능을 사용하는 것은 폐지되었습니다. 더 유연한 사후 "
"처리나 에러 검사를 위해, ctypes 데이터형을 :attr:`restype`\\로 사용하고, 콜러블을 :attr:`errcheck` "
"어트리뷰트에 대입하십시오."

#: ../Doc/library/ctypes.rst:1538
msgid ""
"Assign a tuple of ctypes types to specify the argument types that the "
"function accepts.  Functions using the ``stdcall`` calling convention can"
" only be called with the same number of arguments as the length of this "
"tuple; functions using the C calling convention accept additional, "
"unspecified arguments as well."
msgstr ""
"ctypes 형의 튜플을 대입하여 함수가 받아들이는 인자 형을 지정합니다. ``stdcall`` 호출 규칙을 사용하는 함수는 이 튜플의 "
"길이와 같은 수의 인자로만 호출할 수 있습니다; C 호출 규칙을 사용하는 함수는 추가적인 지정되지 않은 인자도 허용합니다."

#: ../Doc/library/ctypes.rst:1544
msgid ""
"When a foreign function is called, each actual argument is passed to the "
":meth:`from_param` class method of the items in the :attr:`argtypes` "
"tuple, this method allows adapting the actual argument to an object that "
"the foreign function accepts.  For example, a :class:`c_char_p` item in "
"the :attr:`argtypes` tuple will convert a string passed as argument into "
"a bytes object using ctypes conversion rules."
msgstr ""
"외부 함수가 호출될 때, 각 실제 인자는 :attr:`argtypes` 튜플의 항목의 :meth:`from_param` 클래스 메서드에 "
"전달됩니다. 이 메서드는 실제 인자를 외부 함수가 받아들이는 객체에 맞출 수 있습니다. 예를 들어, :attr:`argtypes` 튜플의"
" :class:`c_char_p` 항목은 ctypes 변환 규칙을 사용하여 인자로 전달된 문자열을 바이트열 객체로 변환합니다."

#: ../Doc/library/ctypes.rst:1551
msgid ""
"New: It is now possible to put items in argtypes which are not ctypes "
"types, but each item must have a :meth:`from_param` method which returns "
"a value usable as argument (integer, string, ctypes instance).  This "
"allows defining adapters that can adapt custom objects as function "
"parameters."
msgstr ""
"새로운 기능: 이제 ctypes 형이 아닌 항목을 argtypes에 넣을 수 있습니다. 하지만 각 항목에는 인자로 사용할 수 있는 "
"값(정수, 문자열, ctypes 인스턴스)을 반환하는 :meth:`from_param` 메서드가 있어야 합니다. 이를 통해 사용자 정의 "
"객체를 함수 매개 변수로 맞출 수 있는 어댑터를 정의 할 수 있습니다."

#: ../Doc/library/ctypes.rst:1558
msgid ""
"Assign a Python function or another callable to this attribute. The "
"callable will be called with three or more arguments:"
msgstr "이 어트리뷰트에 파이썬 함수나 다른 콜러블을 대입합니다. 콜러블은 3개 이상의 인자로 호출됩니다:"

#: ../Doc/library/ctypes.rst:1565
msgid ""
"*result* is what the foreign function returns, as specified by the "
":attr:`restype` attribute."
msgstr "*result*\\는 :attr:`restype` 어트리뷰트에 지정된 대로 외부 함수가 반환하는 것입니다."

#: ../Doc/library/ctypes.rst:1568
msgid ""
"*func* is the foreign function object itself, this allows reusing the "
"same callable object to check or post process the results of several "
"functions."
msgstr ""
"*func*\\는 외부 함수 객체 자체이며, 같은 콜러블 객체를 재사용하여 여러 함수의 결과를 확인하거나 사후 처리할 수 있도록 합니다."

#: ../Doc/library/ctypes.rst:1572
msgid ""
"*arguments* is a tuple containing the parameters originally passed to the"
" function call, this allows specializing the behavior on the arguments "
"used."
msgstr ""
"*arguments*\\는 원래 함수 호출에 전달된 매개 변수를 포함하는 튜플입니다. 사용된 인자에 따라 동작을 특수화할 수 있도록 "
"합니다."

#: ../Doc/library/ctypes.rst:1576
msgid ""
"The object that this function returns will be returned from the foreign "
"function call, but it can also check the result value and raise an "
"exception if the foreign function call failed."
msgstr ""
"이 함수가 반환하는 객체는 외부 함수 호출에서 반환되지만, 결괏값을 확인하고 외부 함수 호출이 실패하면 예외를 발생시킬 수도 있습니다."

#: ../Doc/library/ctypes.rst:1583
msgid ""
"This exception is raised when a foreign function call cannot convert one "
"of the passed arguments."
msgstr "외부 함수 호출이 전달된 인자 중 하나를 변환할 수 없을 때 발생하는 예외."

#: ../Doc/library/ctypes.rst:1590
msgid "Function prototypes"
msgstr "함수 프로토타입"

#: ../Doc/library/ctypes.rst:1592
msgid ""
"Foreign functions can also be created by instantiating function "
"prototypes. Function prototypes are similar to function prototypes in C; "
"they describe a function (return type, argument types, calling "
"convention) without defining an implementation.  The factory functions "
"must be called with the desired result type and the argument types of the"
" function, and can be used as decorator factories, and as such, be "
"applied to functions through the ``@wrapper`` syntax. See :ref:`ctypes-"
"callback-functions` for examples."
msgstr ""
"함수 프로토타입의 인스턴스를 만들어서 외부 함수를 만들 수도 있습니다. 함수 프로토타입은 C의 함수 프로토타입과 비슷합니다; 구현을 "
"정의하지 않고 함수(반환형, 인자형, 호출 규칙)를 설명합니다. 팩토리 함수는 원하는 결과형과 함수의 인자형들로 호출되어야 하며, "
"데코레이터 팩토리로 사용되어 ``@wrapper`` 문법을 통해 함수에 적용될 수 있습니다. 예제는 :ref:`ctypes-"
"callback-functions`\\를 참조하십시오."

#: ../Doc/library/ctypes.rst:1603
msgid ""
"The returned function prototype creates functions that use the standard C"
" calling convention.  The function will release the GIL during the call."
"  If *use_errno* is set to true, the ctypes private copy of the system "
":data:`errno` variable is exchanged with the real :data:`errno` value "
"before and after the call; *use_last_error* does the same for the Windows"
" error code."
msgstr ""
"반환된 함수 프로토타입은 표준 C 호출 규칙을 사용하는 함수를 만듭니다. 이 함수는 호출 중에 GIL을 해제합니다. "
"*use_errno*\\를 참으로 설정하면, 시스템 :data:`errno` 변수의 ctypes 내부 복사본이 호출 전후에 실제 "
":data:`errno` 값과 교환됩니다; *use_last_error*\\는 윈도우 에러 코드에 대해 같은 일을 합니다."

#: ../Doc/library/ctypes.rst:1613
msgid ""
"Windows only: The returned function prototype creates functions that use "
"the ``stdcall`` calling convention, except on Windows CE where "
":func:`WINFUNCTYPE` is the same as :func:`CFUNCTYPE`.  The function will "
"release the GIL during the call.  *use_errno* and *use_last_error* have "
"the same meaning as above."
msgstr ""
"윈도우 전용: 반환된 함수 프로토타입은 ``stdcall`` 호출 규칙을 사용하는 함수를 만듭니다. 단 "
":func:`WINFUNCTYPE`\\이 :func:`CFUNCTYPE`\\과 같은 윈도우 CE는 예외입니다. 이 함수는 호출 중에 "
"GIL을 해제합니다. *use_errno* 와 *use_last_error*\\는 위에서와 같은 의미가 있습니다."

#: ../Doc/library/ctypes.rst:1622
msgid ""
"The returned function prototype creates functions that use the Python "
"calling convention.  The function will *not* release the GIL during the "
"call."
msgstr "반환된 함수 프로토타입은 파이썬 호출 규칙을 사용하는 함수를 만듭니다. 이 함수는 호출 도중 GIL을 해제하지 *않습니다*."

#: ../Doc/library/ctypes.rst:1625
msgid ""
"Function prototypes created by these factory functions can be "
"instantiated in different ways, depending on the type and number of the "
"parameters in the call:"
msgstr ""
"이러한 팩토리 함수로 만들어진 함수 프로토타입은 호출의 매개 변수 형과 수에 따라 다른 방법으로 인스턴스를 만들 수 있습니다:"

#: ../Doc/library/ctypes.rst:1633
msgid ""
"Returns a foreign function at the specified address which must be an "
"integer."
msgstr "지정된 정수 주소에 있는 외부 함수를 반환합니다."

#: ../Doc/library/ctypes.rst:1640
msgid ""
"Create a C callable function (a callback function) from a Python "
"*callable*."
msgstr "파이썬 *callable*\\로 C 호출 가능 함수(콜백 함수)를 만듭니다."

#: ../Doc/library/ctypes.rst:1647
msgid ""
"Returns a foreign function exported by a shared library. *func_spec* must"
" be a 2-tuple ``(name_or_ordinal, library)``. The first item is the name "
"of the exported function as string, or the ordinal of the exported "
"function as small integer.  The second item is the shared library "
"instance."
msgstr ""
"공유 라이브러리가 내보낸 외부 함수를 반환합니다. *func_spec*\\은 2-튜플 ``(name_or_ordinal, "
"library)`` 여야 합니다. 첫 번째 항목은 내보낸 함수의 문자열 이름이거나, 작은 정수로 표현된 내보낸 함수의 "
"서수(ordinal)입니다. 두 번째 항목은 공유 라이브러리 인스턴스입니다."

#: ../Doc/library/ctypes.rst:1657
msgid ""
"Returns a foreign function that will call a COM method. *vtbl_index* is "
"the index into the virtual function table, a small non-negative integer. "
"*name* is name of the COM method. *iid* is an optional pointer to the "
"interface identifier which is used in extended error reporting."
msgstr ""
"COM 메서드를 호출할 외부 함수를 반환합니다. *vtbl_index*\\는 가상 함수 테이블에 대한 인덱스이며, 작은 음이 아닌 "
"정수입니다. *name*\\은 COM 메서드의 이름입니다. *iid*\\는 확장 에러 보고에 사용되는 인터페이스 식별자를 가리키는 선택적"
" 포인터입니다."

#: ../Doc/library/ctypes.rst:1662
msgid ""
"COM methods use a special calling convention: They require a pointer to "
"the COM interface as first argument, in addition to those parameters that"
" are specified in the :attr:`argtypes` tuple."
msgstr ""
"COM 메서드는 특별한 호출 규칙을 사용합니다: :attr:`argtypes` 튜플에 지정된 매개 변수 외에, 첫 번째 인자로 COM "
"인터페이스에 대한 포인터가 필요합니다."

#: ../Doc/library/ctypes.rst:1666
msgid ""
"The optional *paramflags* parameter creates foreign function wrappers "
"with much more functionality than the features described above."
msgstr "선택적 *paramflags* 매개 변수는 위에 설명된 기능보다 훨씬 많은 기능을 갖는 외부 함수 래퍼를 만듭니다."

#: ../Doc/library/ctypes.rst:1669
msgid "*paramflags* must be a tuple of the same length as :attr:`argtypes`."
msgstr "*paramflags*\\는 :attr:`argtypes`\\와 같은 길이의 튜플이어야 합니다."

#: ../Doc/library/ctypes.rst:1671
msgid ""
"Each item in this tuple contains further information about a parameter, "
"it must be a tuple containing one, two, or three items."
msgstr ""
"이 튜플의 각 항목에는 매개 변수에 대한 추가 정보가 들어 있으며, 한 개, 두 개 또는 세 개의 항목이 들어있는 튜플이어야 합니다."

#: ../Doc/library/ctypes.rst:1674
msgid ""
"The first item is an integer containing a combination of direction flags "
"for the parameter:"
msgstr "첫 번째 항목은 매개 변수의 방향 플래그 조합을 포함하는 정수입니다:"

#: ../Doc/library/ctypes.rst:1678
msgid "1"
msgstr "1"

#: ../Doc/library/ctypes.rst:1678
msgid "Specifies an input parameter to the function."
msgstr "함수에 대한 입력 매개 변수를 지정합니다."

#: ../Doc/library/ctypes.rst:1681
msgid "2"
msgstr "2"

#: ../Doc/library/ctypes.rst:1681
msgid "Output parameter.  The foreign function fills in a value."
msgstr "출력 매개 변수. 외부 함수가 값을 채웁니다."

#: ../Doc/library/ctypes.rst:1684
msgid "4"
msgstr "4"

#: ../Doc/library/ctypes.rst:1684
msgid "Input parameter which defaults to the integer zero."
msgstr "기본값이 정수 0인 입력 매개 변수."

#: ../Doc/library/ctypes.rst:1686
msgid ""
"The optional second item is the parameter name as string.  If this is "
"specified, the foreign function can be called with named parameters."
msgstr ""
"선택적인 두 번째 항목은 문자열 매개 변수 이름입니다. 이것이 지정되면, 이름있는 매개 변수로 외부 함수를 호출할 수 있습니다."

#: ../Doc/library/ctypes.rst:1689
msgid "The optional third item is the default value for this parameter."
msgstr "선택적 세 번째 항목은 이 매개 변수의 기본값입니다."

#: ../Doc/library/ctypes.rst:1691
msgid ""
"This example demonstrates how to wrap the Windows ``MessageBoxW`` "
"function so that it supports default parameters and named arguments. The "
"C declaration from the windows header file is this::"
msgstr ""
"이 예제는 기본값이 있는 매개 변수와 이름있는 인자를 지원하도록 윈도우 ``MessageBoxW`` 함수를 래핑하는 방법을 보여줍니다. "
"윈도우 헤더 파일의 C 선언은 다음과 같습니다::"

#: ../Doc/library/ctypes.rst:1702 ../Doc/library/ctypes.rst:1725
msgid "Here is the wrapping with :mod:`ctypes`::"
msgstr "다음은 :mod:`ctypes`\\로 래핑하는 방법입니다::"

#: ../Doc/library/ctypes.rst:1710
msgid "The ``MessageBox`` foreign function can now be called in these ways::"
msgstr "이제 ``MessageBox`` 외부 함수를 다음과 같이 호출할 수 있습니다.::"

#: ../Doc/library/ctypes.rst:1716
msgid ""
"A second example demonstrates output parameters.  The win32 "
"``GetWindowRect`` function retrieves the dimensions of a specified window"
" by copying them into ``RECT`` structure that the caller has to supply.  "
"Here is the C declaration::"
msgstr ""
"두 번째 예제는 출력 매개 변수를 보여줍니다. win32 ``GetWindowRect`` 함수는 지정된 창의 크기를 조회하는데, 호출자가"
" 제공해야 하는 ``RECT`` 구조체로 복사합니다. 다음은 C 선언입니다::"

#: ../Doc/library/ctypes.rst:1734
msgid ""
"Functions with output parameters will automatically return the output "
"parameter value if there is a single one, or a tuple containing the "
"output parameter values when there are more than one, so the "
"GetWindowRect function now returns a RECT instance, when called."
msgstr ""
"출력 매개 변수가 있는 함수는, 하나뿐이면 자동으로 출력 매개 변숫값을 반환하고, 여러 개면 출력 매개 변숫값을 포함하는 튜플을 "
"반환하므로, GetWindowRect 함수는 이제 호출되면 RECT 인스턴스를 반환합니다."

#: ../Doc/library/ctypes.rst:1739
msgid ""
"Output parameters can be combined with the :attr:`errcheck` protocol to "
"do further output processing and error checking.  The win32 "
"``GetWindowRect`` api function returns a ``BOOL`` to signal success or "
"failure, so this function could do the error checking, and raises an "
"exception when the api call failed::"
msgstr ""
"출력 매개 변수는 :attr:`errcheck` 프로토콜과 결합하여 추가적인 출력 처리와 에러 검사를 수행할 수 있습니다. win32 "
"``GetWindowRect`` api 함수는 성공이나 실패를 알리기 위해 ``BOOL``\\을 반환하므로, 이 함수는 에러 검사를 "
"수행하고 API 호출이 실패했을 때 예외를 발생시킬 수 있습니다::"

#: ../Doc/library/ctypes.rst:1752
msgid ""
"If the :attr:`errcheck` function returns the argument tuple it receives "
"unchanged, :mod:`ctypes` continues the normal processing it does on the "
"output parameters.  If you want to return a tuple of window coordinates "
"instead of a ``RECT`` instance, you can retrieve the fields in the "
"function and return them instead, the normal processing will no longer "
"take place::"
msgstr ""
":attr:`errcheck` 함수가 수신한 인자 튜플을 변경 없이 반환하면, :mod:`ctypes`\\는 출력 매개 변수에 수행하는 "
"일반 처리를 계속합니다. ``RECT`` 인스턴스 대신 창 좌표의 튜플을 반환하려면, 함수에서 필드를 조회해서 대신 반환하면 됩니다, "
"이때는 일반 처리가 더는 수행되지 않습니다::"

#: ../Doc/library/ctypes.rst:1771
msgid "Utility functions"
msgstr "유틸리티 함수"

#: ../Doc/library/ctypes.rst:1775
msgid ""
"Returns the address of the memory buffer as integer.  *obj* must be an "
"instance of a ctypes type."
msgstr "메모리 버퍼의 주소를 정수로 반환합니다. *obj*\\는 ctypes 형의 인스턴스여야 합니다."

#: ../Doc/library/ctypes.rst:1781
msgid ""
"Returns the alignment requirements of a ctypes type. *obj_or_type* must "
"be a ctypes type or instance."
msgstr "ctypes 형의 정렬 요구 사항을 반환합니다. *obj_or_type*\\는 ctypes 형이나 인스턴스여야 합니다."

#: ../Doc/library/ctypes.rst:1787
msgid ""
"Returns a light-weight pointer to *obj*, which must be an instance of a "
"ctypes type.  *offset* defaults to zero, and must be an integer that will"
" be added to the internal pointer value."
msgstr ""
"*obj*\\에 대한 경량 포인터를 반환합니다. *obj*\\는 ctypes 형의 인스턴스여야 합니다. *offset*\\의 기본값은 "
"0이며, 내부 포인터 값에 더해질 정수여야 합니다."

#: ../Doc/library/ctypes.rst:1791
msgid "``byref(obj, offset)`` corresponds to this C code::"
msgstr "``byref(obj, offset)``\\는 이 C 코드에 해당합니다::"

#: ../Doc/library/ctypes.rst:1795
msgid ""
"The returned object can only be used as a foreign function call "
"parameter. It behaves similar to ``pointer(obj)``, but the construction "
"is a lot faster."
msgstr ""
"반환된 객체는 외부 함수 호출 매개 변수로만 사용할 수 있습니다. ``pointer(obj)``\\와 비슷하게 동작하지만, 훨씬 빨리 "
"만들어집니다."

#: ../Doc/library/ctypes.rst:1801
msgid ""
"This function is similar to the cast operator in C. It returns a new "
"instance of *type* which points to the same memory block as *obj*.  "
"*type* must be a pointer type, and *obj* must be an object that can be "
"interpreted as a pointer."
msgstr ""
"이 함수는 C의 형 변환 연산자와 유사합니다. *obj*\\와 같은 메모리 블록을 가리키는 *type* 형의 새 인스턴스를 반환합니다. "
"*type*\\은 포인터형이어야 하며, *obj*\\는 포인터로 해석될 수 있는 객체여야 합니다."

#: ../Doc/library/ctypes.rst:1809
msgid ""
"This function creates a mutable character buffer. The returned object is "
"a ctypes array of :class:`c_char`."
msgstr "이 함수는 가변 문자 버퍼를 만듭니다. 반환된 객체는 :class:`c_char`\\의 ctypes 배열입니다."

#: ../Doc/library/ctypes.rst:1812
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, "
"or a bytes object which will be used to initialize the array items."
msgstr "*init_or_size*\\는 배열의 크기를 지정하는 정수거나 배열 항목을 초기화하는 데 사용될 바이트열 객체여야 합니다."

#: ../Doc/library/ctypes.rst:1815
msgid ""
"If a bytes object is specified as first argument, the buffer is made one "
"item larger than its length so that the last element in the array is a "
"NUL termination character. An integer can be passed as second argument "
"which allows specifying the size of the array if the length of the bytes "
"should not be used."
msgstr ""
"바이트열 객체가 첫 번째 인자로 지정되면, 버퍼의 길이는 이 객체의 길이보다 한 항목만큼 길어져서, 배열의 마지막 요소가 NUL 종료 "
"문자가 됩니다. 두 번째 인자로 정수를 전달하면 바이트열의 길이를 사용하지 않고 배열의 크기를 지정할 수 있습니다."

#: ../Doc/library/ctypes.rst:1824
msgid ""
"This function creates a mutable unicode character buffer. The returned "
"object is a ctypes array of :class:`c_wchar`."
msgstr "이 함수는 가변 유니코드 문자 버퍼를 만듭니다. 반환된 객체는 :class:`c_wchar`\\의 ctypes 배열입니다."

#: ../Doc/library/ctypes.rst:1827
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, "
"or a string which will be used to initialize the array items."
msgstr "*init_or_size*\\는 배열의 크기를 지정하는 정수거나 배열 항목을 초기화하는 데 사용될 문자열이어야 합니다."

#: ../Doc/library/ctypes.rst:1830
msgid ""
"If a string is specified as first argument, the buffer is made one item "
"larger than the length of the string so that the last element in the "
"array is a NUL termination character. An integer can be passed as second "
"argument which allows specifying the size of the array if the length of "
"the string should not be used."
msgstr ""
"문자열이 첫 번째 인자로 지정되면, 버퍼의 길이는 문자열의 길이보다 한 항목만큼 길어져서, 배열의 마지막 요소가 NUL 종료 문자가 "
"됩니다. 두 번째 인자로 정수를 전달하면 문자열의 길이를 사용하지 않고 배열의 크기를 지정할 수 있습니다."

#: ../Doc/library/ctypes.rst:1840
msgid ""
"Windows only: This function is a hook which allows implementing in-"
"process COM servers with ctypes.  It is called from the DllCanUnloadNow "
"function that the _ctypes extension dll exports."
msgstr ""
"윈도우 전용: 이 함수는 ctypes로 프로세스 내부(in-process) COM 서버를 구현하게 하는 훅입니다. _ctypes 확장 "
"dll이 내보내는 DllCanUnloadNow 함수에서 호출됩니다."

#: ../Doc/library/ctypes.rst:1847
msgid ""
"Windows only: This function is a hook which allows implementing in-"
"process COM servers with ctypes.  It is called from the DllGetClassObject"
" function that the ``_ctypes`` extension dll exports."
msgstr ""
"윈도우 전용: 이 함수는 ctypes로 프로세스 내부(in-process) COM 서버를 구현하게 하는 훅입니다. ``_ctypes`` "
"확장 dll이 내보내는 DllGetClassObject 함수에서 호출됩니다."

#: ../Doc/library/ctypes.rst:1855
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like ``lib``, suffix like ``.so``, ``.dylib`` or "
"version number (this is the form used for the posix linker option "
":option:`!-l`).  If no library can be found, returns ``None``."
msgstr ""
"라이브러리를 찾아서 경로명을 반환하려고 시도합니다. *name*\\은 ``lib`` 같은 접두사, ``.so``, ``.dylib`` "
"또는 버전 번호와 같은 접미사가 없는 라이브러리 이름입니다 (이것은 posix 링커 옵션 :option:`!-l`\\에 사용되는 "
"양식입니다). 라이브러리를 찾을 수 없으면 ``None``\\을 반환합니다."

#: ../Doc/library/ctypes.rst:1866
msgid ""
"Windows only: return the filename of the VC runtime library used by "
"Python, and by the extension modules.  If the name of the library cannot "
"be determined, ``None`` is returned."
msgstr ""
"윈도우 전용: 파이썬과 확장 모듈이 사용하는 VC 런타임 라이브러리의 파일명을 반환합니다. 라이브러리의 이름을 판별할 수 없으면 "
"``None``\\이 반환됩니다."

#: ../Doc/library/ctypes.rst:1870
msgid ""
"If you need to free memory, for example, allocated by an extension module"
" with a call to the ``free(void *)``, it is important that you use the "
"function in the same library that allocated the memory."
msgstr ""
"예를 들어, ``free(void *)``\\에 대한 호출로 확장 모듈에 의해 할당된 메모리를 해제해야 하면, 메모리를 할당한 것과 같은"
" 라이브러리에 있는 함수를 사용하는 것이 중요합니다."

#: ../Doc/library/ctypes.rst:1877
msgid ""
"Windows only: Returns a textual description of the error code *code*.  If"
" no error code is specified, the last error code is used by calling the "
"Windows api function GetLastError."
msgstr ""
"윈도우 전용: 에러 코드 *code*\\의 텍스트 설명을 반환합니다. 에러 코드를 지정하지 않으면 윈도우 API 함수 "
"GetLastError를 호출하여 마지막 에러 코드가 사용됩니다."

#: ../Doc/library/ctypes.rst:1884
msgid ""
"Windows only: Returns the last error code set by Windows in the calling "
"thread. This function calls the Windows `GetLastError()` function "
"directly, it does not return the ctypes-private copy of the error code."
msgstr ""
"윈도우 전용: 호출 스레드에서 윈도우가 설정한 마지막 에러 코드를 반환합니다. 이 함수는 윈도우 `GetLastError()` 함수를 "
"직접 호출합니다. 에러 코드의 ctypes 내부 복사본을 반환하지 않습니다."

#: ../Doc/library/ctypes.rst:1890
msgid ""
"Returns the current value of the ctypes-private copy of the system "
":data:`errno` variable in the calling thread."
msgstr "호출하는 스레드에서 시스템 :data:`errno` 변수의 ctypes 내부 복사본의 현재 값을 반환합니다."

#: ../Doc/library/ctypes.rst:1895
msgid ""
"Windows only: returns the current value of the ctypes-private copy of the"
" system :data:`LastError` variable in the calling thread."
msgstr ""
"윈도우 전용: 호출 중인 스레드에서 시스템 :data:`LastError` 변수의 ctypes 내부 복사본의 현재 값을 반환합니다."

#: ../Doc/library/ctypes.rst:1900
msgid ""
"Same as the standard C memmove library function: copies *count* bytes "
"from *src* to *dst*. *dst* and *src* must be integers or ctypes instances"
" that can be converted to pointers."
msgstr ""
"표준 C memmove 라이브러리 함수와 같습니다: *count* 바이트를 *src*\\에서 *dst*\\로 복사합니다. *dst* 와 "
"*src*\\는 정수이거나 포인터로 변환할 수 있는 ctypes 인스턴스여야 합니다."

#: ../Doc/library/ctypes.rst:1907
msgid ""
"Same as the standard C memset library function: fills the memory block at"
" address *dst* with *count* bytes of value *c*. *dst* must be an integer "
"specifying an address, or a ctypes instance."
msgstr ""
"표준 C memset 라이브러리 함수와 같습니다: 주소 *dst*\\의 메모리 블록을 값 *c*\\의 *count* 바이트로 채웁니다. "
"*dst*\\는 주소를 지정하는 정수거나 ctypes 인스턴스여야 합니다."

#: ../Doc/library/ctypes.rst:1914
msgid ""
"This factory function creates and returns a new ctypes pointer type. "
"Pointer types are cached and reused internally, so calling this function "
"repeatedly is cheap. *type* must be a ctypes type."
msgstr ""
"이 팩토리 함수는 새로운 ctypes 포인터형을 만들고 반환합니다. 포인터형은 캐시 되고 내부적으로 재사용되므로, 이 함수를 반복적으로 "
"호출하는 것은 저렴합니다. *type*\\는 ctypes 형이어야 합니다."

#: ../Doc/library/ctypes.rst:1921
msgid ""
"This function creates a new pointer instance, pointing to *obj*. The "
"returned object is of the type ``POINTER(type(obj))``."
msgstr ""
"이 함수는 *obj*\\를 가리키는 새 포인터 인스턴스를 만듭니다. 반환된 객체는 형 ``POINTER(type(obj))``\\입니다."

#: ../Doc/library/ctypes.rst:1924
msgid ""
"Note: If you just want to pass a pointer to an object to a foreign "
"function call, you should use ``byref(obj)`` which is much faster."
msgstr "참고 사항: 객체에 대한 포인터를 단지 외부 함수 호출로 전달하려면 훨씬 빠른 ``byref(obj)``\\를 사용해야 합니다."

#: ../Doc/library/ctypes.rst:1930
msgid ""
"This function resizes the internal memory buffer of *obj*, which must be "
"an instance of a ctypes type.  It is not possible to make the buffer "
"smaller than the native size of the objects type, as given by "
"``sizeof(type(obj))``, but it is possible to enlarge the buffer."
msgstr ""
"이 함수는 *obj*\\의 내부 메모리 버퍼의 크기를 조정합니다. *obj*\\는 ctypes 형의 인스턴스여야 합니다. "
"``sizeof(type(obj))``\\로 주어지는 객체 형의 원래 크기보다 버퍼를 작게 만들 수는 없지만, 버퍼를 확대할 수 "
"있습니다."

#: ../Doc/library/ctypes.rst:1938
msgid ""
"Set the current value of the ctypes-private copy of the system "
":data:`errno` variable in the calling thread to *value* and return the "
"previous value."
msgstr ""
"호출 중인 스레드의 시스템 :data:`errno` 변수의 ctypes 내부 복사본의 현재 값을 *value*\\로 설정하고 이전 값을 "
"반환합니다."

#: ../Doc/library/ctypes.rst:1945
msgid ""
"Windows only: set the current value of the ctypes-private copy of the "
"system :data:`LastError` variable in the calling thread to *value* and "
"return the previous value."
msgstr ""
"윈도우 전용: 호출 중인 스레드의 시스템 :data:`LastError` 변수의 ctypes 내부 복사본의 현재 값을 *value*\\로"
" 설정하고 이전 값을 반환합니다."

#: ../Doc/library/ctypes.rst:1953
msgid ""
"Returns the size in bytes of a ctypes type or instance memory buffer. "
"Does the same as the C ``sizeof`` operator."
msgstr ""
"ctypes 형이나 인스턴스 메모리 버퍼의 크기를 바이트 단위로 반환합니다. C ``sizeof`` 연산자와 같은 일을 합니다."

#: ../Doc/library/ctypes.rst:1959
msgid ""
"This function returns the C string starting at memory address *address* "
"as a bytes object. If size is specified, it is used as size, otherwise "
"the string is assumed to be zero-terminated."
msgstr ""
"이 함수는 메모리 주소 *address*\\에서 시작하는 C 문자열을 바이트열 객체로 반환합니다. size가 지정되면 크기로 사용되며, "
"그렇지 않으면 문자열은 0으로 종료된다고 가정합니다."

#: ../Doc/library/ctypes.rst:1966
msgid ""
"Windows only: this function is probably the worst-named thing in ctypes. "
"It creates an instance of OSError.  If *code* is not specified, "
"``GetLastError`` is called to determine the error code. If *descr* is not"
" specified, :func:`FormatError` is called to get a textual description of"
" the error."
msgstr ""
"윈도우 전용: 이 함수는 아마도 ctypes에서 가장 이름을 잘못 붙인 것입니다. OSError의 인스턴스를 만듭니다. *code*\\를"
" 지정하지 않으면, 에러 코드를 판별하기 위해 ``GetLastError``\\가 호출됩니다. *descr*\\가 지정되지 않으면, "
"에러에 대한 텍스트 설명을 얻기 위해 :func:`FormatError`\\가 호출됩니다."

#: ../Doc/library/ctypes.rst:1972
msgid "An instance of :exc:`WindowsError` used to be created."
msgstr ":exc:`WindowsError`\\의 인스턴스를 만들어왔습니다."

#: ../Doc/library/ctypes.rst:1978
msgid ""
"This function returns the wide character string starting at memory "
"address *address* as a string.  If *size* is specified, it is used as the"
" number of characters of the string, otherwise the string is assumed to "
"be zero-terminated."
msgstr ""
"이 함수는 메모리 주소 *address*\\에서 시작하는 광폭(wide) 문자열을 문자열로 반환합니다. *size*\\가 지정되면, "
"문자열의 문자 수로 사용되며, 그렇지 않으면 문자열은 0으로 종료된다고 가정합니다."

#: ../Doc/library/ctypes.rst:1987
msgid "Data types"
msgstr "데이터형"

#: ../Doc/library/ctypes.rst:1992
msgid ""
"This non-public class is the common base class of all ctypes data types. "
"Among other things, all ctypes type instances contain a memory block that"
" hold C compatible data; the address of the memory block is returned by "
"the :func:`addressof` helper function. Another instance variable is "
"exposed as :attr:`_objects`; this contains other Python objects that need"
" to be kept alive in case the memory block contains pointers."
msgstr ""
"이 비공개 클래스는 모든 ctypes 데이터형의 공통 베이스 클래스입니다. 무엇보다도, 모든 ctypes 형 인스턴스에는 C 호환 "
"데이터를 보관하는 메모리 블록이 포함됩니다; 메모리 블록의 주소는 :func:`addressof` 도우미 함수에 의해 반환됩니다. 다른 "
"인스턴스 변수는 :attr:`_objects`\\로 노출됩니다; 여기에는 메모리 블록에 포인터가 포함되어있을 때, 살려둘 필요가 있는 "
"다른 파이썬 객체가 포함되어 있습니다."

#: ../Doc/library/ctypes.rst:1999
msgid ""
"Common methods of ctypes data types, these are all class methods (to be "
"exact, they are methods of the :term:`metaclass`):"
msgstr ""
"ctypes 데이터형의 공통 메서드, 이것들은 모두 클래스 메서드입니다 (정확히 말하면, :term:`메타 클래스 "
"<metaclass>`\\의 메서드입니다):"

#: ../Doc/library/ctypes.rst:2004
msgid ""
"This method returns a ctypes instance that shares the buffer of the "
"*source* object.  The *source* object must support the writeable buffer "
"interface.  The optional *offset* parameter specifies an offset into the "
"source buffer in bytes; the default is zero.  If the source buffer is not"
" large enough a :exc:`ValueError` is raised."
msgstr ""
"이 메서드는 *source* 객체의 버퍼를 공유하는 ctypes 인스턴스를 반환합니다. *source* 객체는 쓰기 가능한 버퍼 "
"인터페이스를 지원해야 합니다. 선택적 *offset* 매개 변수는 source 버퍼의 오프셋을 바이트 단위로 지정합니다; 기본값은 "
"0입니다. source 버퍼가 충분히 크지 않으면 :exc:`ValueError`\\가 발생합니다."

#: ../Doc/library/ctypes.rst:2013
msgid ""
"This method creates a ctypes instance, copying the buffer from the "
"*source* object buffer which must be readable.  The optional *offset* "
"parameter specifies an offset into the source buffer in bytes; the "
"default is zero.  If the source buffer is not large enough a "
":exc:`ValueError` is raised."
msgstr ""
"이 메서드는 읽을 수 있어야 하는 *source* 객체 버퍼에서 버퍼를 복사하여 ctypes 인스턴스를 만듭니다. 선택적 *offset*"
" 매개 변수는 원본 버퍼의 오프셋을 바이트 단위로 지정합니다. 기본값은 0입니다. 소스 버퍼가 충분히 크지 않으면 "
":exc:`ValueError`\\가 발생합니다."

#: ../Doc/library/ctypes.rst:2021
msgid ""
"This method returns a ctypes type instance using the memory specified by "
"*address* which must be an integer."
msgstr "이 메서드는 정수 *address*\\로 지정된 메모리를 사용하여 ctypes 형 인스턴스를 반환합니다."

#: ../Doc/library/ctypes.rst:2026
msgid ""
"This method adapts *obj* to a ctypes type.  It is called with the actual "
"object used in a foreign function call when the type is present in the "
"foreign function's :attr:`argtypes` tuple; it must return an object that "
"can be used as a function call parameter."
msgstr ""
"이 메서드는 *obj*\\를 ctypes 형에게 맞게 조정합니다. 형이 외부 함수의 :attr:`argtypes` 튜플에 존재할 때, "
"외부 함수 호출에 사용된 실제 객체로 호출됩니다; 함수 호출 매개 변수로 사용할 수 있는 객체를 반환 해야 합니다."

#: ../Doc/library/ctypes.rst:2031
msgid ""
"All ctypes data types have a default implementation of this classmethod "
"that normally returns *obj* if that is an instance of the type.  Some "
"types accept other objects as well."
msgstr ""
"모든 ctypes 데이터형은 이 클래스 메서드의 기본 구현을 갖는데, *obj* 가 이 형의 인스턴스면 *obj* 를 반환합니다. 일부 "
"형은 다른 객체도 허용합니다."

#: ../Doc/library/ctypes.rst:2037
msgid ""
"This method returns a ctypes type instance exported by a shared library. "
"*name* is the name of the symbol that exports the data, *library* is the "
"loaded shared library."
msgstr ""
"이 메서드는 공유 라이브러리가 내보낸 ctypes 형 인스턴스를 반환합니다. *name*\\은 데이터를 내보내는 심볼의 이름이고, "
"*library*\\는 로드된 공유 라이브러리입니다."

#: ../Doc/library/ctypes.rst:2041
msgid "Common instance variables of ctypes data types:"
msgstr "ctypes 데이터형의 공통 인스턴스 변수:"

#: ../Doc/library/ctypes.rst:2045
msgid ""
"Sometimes ctypes data instances do not own the memory block they contain,"
" instead they share part of the memory block of a base object.  The "
":attr:`_b_base_` read-only member is the root ctypes object that owns the"
" memory block."
msgstr ""
"때로 ctypes 데이터 인스턴스는 포함하는 메모리 블록을 소유하지 않고, 베이스 객체의 메모리 블록의 일부를 공유합니다. "
":attr:`_b_base_` 읽기 전용 멤버는 메모리 블록을 소유한 루트 ctypes 객체입니다."

#: ../Doc/library/ctypes.rst:2052
msgid ""
"This read-only variable is true when the ctypes data instance has "
"allocated the memory block itself, false otherwise."
msgstr "이 읽기 전용 변수는 ctypes 데이터 인스턴스가 메모리 블록을 스스로 할당했을 때 참이고, 그렇지 않으면 거짓입니다."

#: ../Doc/library/ctypes.rst:2057
msgid ""
"This member is either ``None`` or a dictionary containing Python objects "
"that need to be kept alive so that the memory block contents is kept "
"valid.  This object is only exposed for debugging; never modify the "
"contents of this dictionary."
msgstr ""
"이 멤버는 ``None`` 이거나 메모리 블록 내용이 계속 유효하도록 유지되어야 하는 파이썬 객체를 포함하는 딕셔너리입니다. 이 객체는 "
"디버깅을 위해서만 노출됩니다; 이 딕셔너리의 내용을 수정하지 마십시오."

#: ../Doc/library/ctypes.rst:2070
msgid ""
"This non-public class is the base class of all fundamental ctypes data "
"types. It is mentioned here because it contains the common attributes of "
"the fundamental ctypes data types.  :class:`_SimpleCData` is a subclass "
"of :class:`_CData`, so it inherits their methods and attributes. ctypes "
"data types that are not and do not contain pointers can now be pickled."
msgstr ""
"이 비공개 클래스는 모든 기본 ctypes 데이터형의 베이스 클래스입니다. 여기에는 기본 ctypes 데이터형의 공통 어트리뷰트가 들어 "
"있으므로 여기에서 언급합니다. :class:`_SimpleCData`\\는 :class:`_CData`\\의 서브 클래스이므로, 메서드와"
" 어트리뷰트를 상속받습니다. 포인터가 아니고 포인터를 포함하지 않는 ctypes 데이터형을 이제 피클 할 수 있습니다."

#: ../Doc/library/ctypes.rst:2076
msgid "Instances have a single attribute:"
msgstr "인스턴스에는 어트리뷰트가 하나 있습니다:"

#: ../Doc/library/ctypes.rst:2080
msgid ""
"This attribute contains the actual value of the instance. For integer and"
" pointer types, it is an integer, for character types, it is a single "
"character bytes object or string, for character pointer types it is a "
"Python bytes object or string."
msgstr ""
"이 어트리뷰트는 인스턴스의 실제 값을 포함합니다. 정수형과 포인터형에서는 정수고, 문자형에서는 단일 문자 바이트열 객체나 문자열이고, "
"문자 포인터형에서는 파이썬 바이트열 객체나 문자열입니다."

#: ../Doc/library/ctypes.rst:2085
msgid ""
"When the ``value`` attribute is retrieved from a ctypes instance, usually"
" a new object is returned each time.  :mod:`ctypes` does *not* implement "
"original object return, always a new object is constructed.  The same is "
"true for all other ctypes object instances."
msgstr ""
"ctypes 인스턴스에서 ``value`` 어트리뷰트를 조회하면, 대개 매번 새 객체가 반환됩니다. :mod:`ctypes`\\는 원래의"
" 객체 반환을 구현하지 *않습니다*. 항상 새로운 객체가 만들어집니다. 다른 모든 ctypes 객체 인스턴스에서도 마찬가지입니다."

#: ../Doc/library/ctypes.rst:2091
msgid ""
"Fundamental data types, when returned as foreign function call results, "
"or, for example, by retrieving structure field members or array items, "
"are transparently converted to native Python types.  In other words, if a"
" foreign function has a :attr:`restype` of :class:`c_char_p`, you will "
"always receive a Python bytes object, *not* a :class:`c_char_p` instance."
msgstr ""
"기본 데이터형은, 외부 함수 호출 결과로 반환되거나 (예를 들어) 구조체 필드 멤버나 배열 항목을 꺼낼 때, 원시(native) 파이썬 "
"형으로 투명하게 변환됩니다. 즉, 외부 함수가 :class:`c_char_p`\\인 :attr:`restype`\\을 가지면, 항상 "
":class:`c_char_p` 인스턴스가 *아니라* 파이썬 바이트열 객체를 받습니다."

#: ../Doc/library/ctypes.rst:2099
msgid ""
"Subclasses of fundamental data types do *not* inherit this behavior. So, "
"if a foreign functions :attr:`restype` is a subclass of "
":class:`c_void_p`, you will receive an instance of this subclass from the"
" function call. Of course, you can get the value of the pointer by "
"accessing the ``value`` attribute."
msgstr ""
"기본 데이터형의 서브 클래스는 이 동작을 상속하지 *않습니다*. 따라서 외부 함수의 :attr:`restype`\\가 "
":class:`c_void_p`\\의 서브 클래스면, 함수 호출에서 이 서브 클래스의 인스턴스를 받게 됩니다. 물론, ``value`` "
"어트리뷰트에 액세스해서 포인터 값을 가져올 수 있습니다."

#: ../Doc/library/ctypes.rst:2104
msgid "These are the fundamental ctypes data types:"
msgstr "다음은 기본 ctypes 데이터형입니다:"

#: ../Doc/library/ctypes.rst:2108
msgid ""
"Represents the C :c:type:`signed char` datatype, and interprets the value"
" as small integer.  The constructor accepts an optional integer "
"initializer; no overflow checking is done."
msgstr ""
"C :c:type:`signed char` 데이터형을 나타내고, 값을 작은 정수로 해석합니다. 생성자는 선택적 정수 초기화자를 "
"받아들입니다; 오버플로 검사는 수행되지 않습니다."

#: ../Doc/library/ctypes.rst:2115
msgid ""
"Represents the C :c:type:`char` datatype, and interprets the value as a "
"single character.  The constructor accepts an optional string "
"initializer, the length of the string must be exactly one character."
msgstr ""
"C :c:type:`char` 데이터형을 나타내고, 값을 단일 문자로 해석합니다. 생성자는 선택적 문자열 초기화자를 받아들입니다, "
"문자열의 길이는 정확히 한 문자여야 합니다."

#: ../Doc/library/ctypes.rst:2122
msgid ""
"Represents the C :c:type:`char *` datatype when it points to a zero-"
"terminated string.  For a general character pointer that may also point "
"to binary data, ``POINTER(c_char)`` must be used.  The constructor "
"accepts an integer address, or a bytes object."
msgstr ""
"0으로 끝나는 문자열을 가리킬 때, C :c:type:`char *` 데이터형을 나타냅니다. 바이너리 데이터를 가리킬 수도 있는 일반 "
"문자 포인터를 위해서는, ``POINTER(c_char)``\\를 사용해야 합니다. 생성자는 정수 주소나 바이트열 객체를 받아들입니다."

#: ../Doc/library/ctypes.rst:2130
msgid ""
"Represents the C :c:type:`double` datatype.  The constructor accepts an "
"optional float initializer."
msgstr "C :c:type:`double` 데이터형을 나타냅니다. 생성자는 선택적 float 초기화자를 받아들입니다."

#: ../Doc/library/ctypes.rst:2136
msgid ""
"Represents the C :c:type:`long double` datatype.  The constructor accepts"
" an optional float initializer.  On platforms where ``sizeof(long double)"
" == sizeof(double)`` it is an alias to :class:`c_double`."
msgstr ""
"C :c:type:`long double` 데이터형을 나타냅니다. 생성자는 선택적 float 초기화자를 받아들입니다. "
"``sizeof(long double) == sizeof(double)``\\인 플랫폼에서 :class:`c_double`\\의 "
"별칭입니다."

#: ../Doc/library/ctypes.rst:2142
msgid ""
"Represents the C :c:type:`float` datatype.  The constructor accepts an "
"optional float initializer."
msgstr "C :c:type:`float` 데이터형을 나타냅니다. 생성자는 선택적 float 초기화자를 받아들입니다."

#: ../Doc/library/ctypes.rst:2148
msgid ""
"Represents the C :c:type:`signed int` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done.  On "
"platforms where ``sizeof(int) == sizeof(long)`` it is an alias to "
":class:`c_long`."
msgstr ""
"C :c:type:`signed int` 데이터형을 나타냅니다. 생성자는 선택적 정수 초기화자를 받아들입니다. 오버플로 검사는 수행되지 "
"않습니다. ``sizeof(int) == sizeof(long)``\\인 플랫폼에서 :class:`c_long`\\의 별칭입니다."

#: ../Doc/library/ctypes.rst:2155
msgid ""
"Represents the C 8-bit :c:type:`signed int` datatype.  Usually an alias "
"for :class:`c_byte`."
msgstr "C 8비트 :c:type:`signed int` 데이터형을 나타냅니다. 보통 :class:`c_byte`\\의 별칭입니다."

#: ../Doc/library/ctypes.rst:2161
msgid ""
"Represents the C 16-bit :c:type:`signed int` datatype.  Usually an alias "
"for :class:`c_short`."
msgstr "C 16비트 :c:type:`signed int` 데이터형을 나타냅니다. 보통 :class:`c_short`\\의 별칭입니다."

#: ../Doc/library/ctypes.rst:2167
msgid ""
"Represents the C 32-bit :c:type:`signed int` datatype.  Usually an alias "
"for :class:`c_int`."
msgstr "C 32비트 :c:type:`signed int` 데이터형을 나타냅니다. 보통 :class:`c_int`\\의 별칭입니다."

#: ../Doc/library/ctypes.rst:2173
msgid ""
"Represents the C 64-bit :c:type:`signed int` datatype.  Usually an alias "
"for :class:`c_longlong`."
msgstr ""
"C 64비트 :c:type:`signed int` 데이터형을 나타냅니다. 보통 :class:`c_longlong`\\의 별칭입니다."

#: ../Doc/library/ctypes.rst:2179
msgid ""
"Represents the C :c:type:`signed long` datatype.  The constructor accepts"
" an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`signed long` 데이터형을 나타냅니다. 생성자는 선택적 정수 초기화자를 받아들입니다; 오버플로 검사는 수행되지"
" 않습니다."

#: ../Doc/library/ctypes.rst:2185
msgid ""
"Represents the C :c:type:`signed long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`signed long long` 데이터형을 나타냅니다. 생성자는 선택적 정수 초기화자를 받아들입니다; 오버플로 검사는"
" 수행되지 않습니다."

#: ../Doc/library/ctypes.rst:2191
msgid ""
"Represents the C :c:type:`signed short` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`signed short` 데이터형을 나타냅니다. 생성자는 선택적 정수 초기화자를 받아들입니다; 오버플로 검사는 "
"수행되지 않습니다."

#: ../Doc/library/ctypes.rst:2197
msgid "Represents the C :c:type:`size_t` datatype."
msgstr "C :c:type:`size_t` 데이터형을 나타냅니다."

#: ../Doc/library/ctypes.rst:2202
msgid "Represents the C :c:type:`ssize_t` datatype."
msgstr "C :c:type:`ssize_t` 데이터형을 나타냅니다."

#: ../Doc/library/ctypes.rst:2209
msgid ""
"Represents the C :c:type:`unsigned char` datatype, it interprets the "
"value as small integer.  The constructor accepts an optional integer "
"initializer; no overflow checking is done."
msgstr ""
"C :c:type:`unsigned char` 데이터형을 나타내고, 값을 작은 정수로 해석합니다. 생성자는 선택적 정수 초기화자를 "
"받아들입니다; 오버플로 검사는 수행되지 않습니다."

#: ../Doc/library/ctypes.rst:2216
msgid ""
"Represents the C :c:type:`unsigned int` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done.  "
"On platforms where ``sizeof(int) == sizeof(long)`` it is an alias for "
":class:`c_ulong`."
msgstr ""
"C :c:type:`unsigned int` 데이터형을 나타냅니다. 생성자는 선택적 정수 초기화자를 받아들입니다; 오버플로 검사는 "
"수행되지 않습니다. ``sizeof(int) == sizeof(long)``\\인 플랫폼에서 :class:`c_ulong`\\의 "
"별칭입니다."

#: ../Doc/library/ctypes.rst:2223
msgid ""
"Represents the C 8-bit :c:type:`unsigned int` datatype.  Usually an alias"
" for :class:`c_ubyte`."
msgstr "C 8비트 :c:type:`unsigned int` 데이터형을 나타냅니다. 보통 :class:`c_ubyte`\\의 별칭입니다."

#: ../Doc/library/ctypes.rst:2229
msgid ""
"Represents the C 16-bit :c:type:`unsigned int` datatype.  Usually an "
"alias for :class:`c_ushort`."
msgstr ""
"C 16비트 :c:type:`unsigned int` 데이터형을 나타냅니다. 보통 :class:`c_ushort`\\의 별칭입니다."

#: ../Doc/library/ctypes.rst:2235
msgid ""
"Represents the C 32-bit :c:type:`unsigned int` datatype.  Usually an "
"alias for :class:`c_uint`."
msgstr "C 32비트 :c:type:`unsigned int` 데이터형을 나타냅니다. 보통 :class:`c_uint`\\의 별칭입니다."

#: ../Doc/library/ctypes.rst:2241
msgid ""
"Represents the C 64-bit :c:type:`unsigned int` datatype.  Usually an "
"alias for :class:`c_ulonglong`."
msgstr ""
"C 64비트 :c:type:`unsigned int` 데이터형을 나타냅니다. 보통 :class:`c_ulonglong`\\의 별칭입니다."

#: ../Doc/library/ctypes.rst:2247
msgid ""
"Represents the C :c:type:`unsigned long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`unsigned long` 데이터형을 나타냅니다. 생성자는 선택적 정수 초기화자를 받아들입니다; 오버플로 검사는 "
"수행되지 않습니다."

#: ../Doc/library/ctypes.rst:2253
msgid ""
"Represents the C :c:type:`unsigned long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`unsigned long long` 데이터형을 나타냅니다. 생성자는 선택적 정수 초기화자를 받아들입니다; 오버플로 "
"검사는 수행되지 않습니다."

#: ../Doc/library/ctypes.rst:2259
msgid ""
"Represents the C :c:type:`unsigned short` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"C :c:type:`unsigned short` 데이터형을 나타냅니다. 생성자는 선택적 정수 초기화자를 받아들입니다; 오버플로 검사는 "
"수행되지 않습니다."

#: ../Doc/library/ctypes.rst:2265
msgid ""
"Represents the C :c:type:`void *` type.  The value is represented as "
"integer. The constructor accepts an optional integer initializer."
msgstr "C :c:type:`void *` 형을 나타냅니다. 값은 정수로 표시됩니다. 생성자는 선택적 정수 초기화자를 받아들입니다."

#: ../Doc/library/ctypes.rst:2271
msgid ""
"Represents the C :c:type:`wchar_t` datatype, and interprets the value as "
"a single character unicode string.  The constructor accepts an optional "
"string initializer, the length of the string must be exactly one "
"character."
msgstr ""
"C :c:type:`wchar_t` 데이터형을 나타내고, 값을 단일 문자 유니코드 문자열로 해석합니다. 생성자는 선택적 문자열 초기화자를"
" 받아들입니다, 문자열의 길이는 정확히 한 문자여야 합니다."

#: ../Doc/library/ctypes.rst:2278
msgid ""
"Represents the C :c:type:`wchar_t *` datatype, which must be a pointer to"
" a zero-terminated wide character string.  The constructor accepts an "
"integer address, or a string."
msgstr ""
"0으로 끝나는 광폭 문자 문자열을 가리키는 포인터여야 하는 C :c:type:`wchar_t *` 데이터형을 나타냅니다. 생성자는 정수 "
"주소나 문자열을 받아들입니다."

#: ../Doc/library/ctypes.rst:2285
msgid ""
"Represent the C :c:type:`bool` datatype (more accurately, :c:type:`_Bool`"
" from C99).  Its value can be ``True`` or ``False``, and the constructor "
"accepts any object that has a truth value."
msgstr ""
"C :c:type:`bool` 데이터형을 나타냅니다 (더욱 정확하게, C99의 :c:type:`_Bool`). 이 값은 "
"``True``\\나 ``False`` 일 수 있고, 생성자는 논릿값이 있는 임의의 객체를 받아들입니다."

#: ../Doc/library/ctypes.rst:2292
msgid ""
"Windows only: Represents a :c:type:`HRESULT` value, which contains "
"success or error information for a function or method call."
msgstr ""
"윈도우 전용: 함수 또는 메서드 호출에 대한 성공 또는 에러 정보가 들어있는, :c:type:`HRESULT` 값을 나타냅니다."

#: ../Doc/library/ctypes.rst:2298
msgid ""
"Represents the C :c:type:`PyObject *` datatype.  Calling this without an "
"argument creates a ``NULL`` :c:type:`PyObject *` pointer."
msgstr ""
"C :c:type:`PyObject *` 데이터형을 나타냅니다. 인자 없이 이것을 호출하면 ``NULL`` "
":c:type:`PyObject *` 포인터가 만들어집니다."

#: ../Doc/library/ctypes.rst:2301
msgid ""
"The :mod:`ctypes.wintypes` module provides quite some other Windows "
"specific data types, for example :c:type:`HWND`, :c:type:`WPARAM`, or "
":c:type:`DWORD`.  Some useful structures like :c:type:`MSG` or "
":c:type:`RECT` are also defined."
msgstr ""
":mod:`ctypes.wintypes` 모듈은 다른 윈도우 특정 데이터형을 제공합니다, 예를 들어, :c:type:`HWND`, "
":c:type:`WPARAM` 또는 :c:type:`DWORD`. :c:type:`MSG`\\나 :c:type:`RECT`\\와 같은 "
"유용한 구조체도 정의됩니다."

#: ../Doc/library/ctypes.rst:2309
msgid "Structured data types"
msgstr "구조화된 데이터형"

#: ../Doc/library/ctypes.rst:2314
msgid "Abstract base class for unions in native byte order."
msgstr "네이티브 바이트 순서의 공용체를 위한 추상 베이스 클래스."

#: ../Doc/library/ctypes.rst:2319
msgid "Abstract base class for structures in *big endian* byte order."
msgstr "*빅엔디안(big endian)* 바이트 순서의 구조체를 위한 추상 베이스 클래스."

#: ../Doc/library/ctypes.rst:2324
msgid "Abstract base class for structures in *little endian* byte order."
msgstr "*리틀엔디안(little endian)* 바이트 순서로의 구조체를 위한 추상 베이스 클래스."

#: ../Doc/library/ctypes.rst:2326
msgid ""
"Structures with non-native byte order cannot contain pointer type fields,"
" or any other data types containing pointer type fields."
msgstr "네이티브가 아닌 바이트 순서를 갖는 구조체는 포인터형 필드나 포인터형 필드를 포함하는 다른 데이터형을 포함할 수 없습니다."

#: ../Doc/library/ctypes.rst:2332
msgid "Abstract base class for structures in *native* byte order."
msgstr "*네이티브* 바이트 순서의 구조체를 위한 추상 베이스 클래스."

#: ../Doc/library/ctypes.rst:2334
msgid ""
"Concrete structure and union types must be created by subclassing one of "
"these types, and at least define a :attr:`_fields_` class variable. "
":mod:`ctypes` will create :term:`descriptor`\\s which allow reading and "
"writing the fields by direct attribute accesses.  These are the"
msgstr ""
"구상 구조체와 공용체 형은 이 형 중 하나를 서브 클래싱하고 적어도 :attr:`_fields_` 클래스 변수를 정의해서 만들어야 "
"합니다. :mod:`ctypes`\\는 직접 어트리뷰트 액세스로 필드를 읽고 쓸 수 있는 :term:`디스크립터 "
"<descriptor>`\\를 만듭니다. 이것들은"

#: ../Doc/library/ctypes.rst:2342
msgid ""
"A sequence defining the structure fields.  The items must be 2-tuples or "
"3-tuples.  The first item is the name of the field, the second item "
"specifies the type of the field; it can be any ctypes data type."
msgstr ""
"구조체 필드를 정의하는 시퀀스. 항목은 2-튜플이나 3-튜플이어야 합니다. 첫 번째 항목은 필드의 이름이고, 두 번째 항목은 필드의 형을"
" 지정합니다; 모든 ctypes 데이터형이 될 수 있습니다."

#: ../Doc/library/ctypes.rst:2346
msgid ""
"For integer type fields like :class:`c_int`, a third optional item can be"
" given.  It must be a small positive integer defining the bit width of "
"the field."
msgstr ""
":class:`c_int`\\와 같은 정수형 필드에서는, 세 번째 선택적 항목을 지정할 수 있습니다. 필드의 비트 폭을 정의하는 작은 "
"양의 정수여야 합니다."

#: ../Doc/library/ctypes.rst:2350
msgid ""
"Field names must be unique within one structure or union.  This is not "
"checked, only one field can be accessed when names are repeated."
msgstr ""
"필드 이름은 하나의 구조체나 공용체 내에서 고유해야 합니다. 이것은 검사되지 않습니다, 이름이 중복되면 하나의 필드만 액세스할 수 "
"있습니다."

#: ../Doc/library/ctypes.rst:2353
msgid ""
"It is possible to define the :attr:`_fields_` class variable *after* the "
"class statement that defines the Structure subclass, this allows creating"
" data types that directly or indirectly reference themselves::"
msgstr ""
":attr:`_fields_` 클래스 변수를, Structure 서브 클래스를 정의하는 클래스 문 *뒤에서* 정의할 수 있습니다. 직접 "
"또는 간접적으로 자신을 참조하는 데이터형을 만들 수 있게 합니다::"

#: ../Doc/library/ctypes.rst:2363
msgid ""
"The :attr:`_fields_` class variable must, however, be defined before the "
"type is first used (an instance is created, :func:`sizeof` is called on "
"it, and so on).  Later assignments to the :attr:`_fields_` class variable"
" will raise an AttributeError."
msgstr ""
"하지만, 형이 처음 사용되기 전에 :attr:`_fields_` 클래스 변수를 정의해야 합니다 (인스턴스가 만들어지고, "
":func:`sizeof`\\가 호출되는 등의 일이 일어납니다). 나중에 :attr:`_fields_` 클래스 변수에 대입하면 "
"AttributeError가 발생합니다."

#: ../Doc/library/ctypes.rst:2368
msgid ""
"It is possible to defined sub-subclasses of structure types, they inherit"
" the fields of the base class plus the :attr:`_fields_` defined in the "
"sub-subclass, if any."
msgstr ""
"구조체 형의 서브-서브 클래스를 정의할 수 있습니다. 베이스 클래스의 필드를 상속하고, 여기에 서브-서브 클래스에 정의된 "
":attr:`_fields_`\\의 필드가 추가됩니다."

#: ../Doc/library/ctypes.rst:2375
msgid ""
"An optional small integer that allows overriding the alignment of "
"structure fields in the instance.  :attr:`_pack_` must already be defined"
" when :attr:`_fields_` is assigned, otherwise it will have no effect."
msgstr ""
"인스턴스의 구조체 필드 정렬을 재정의할 수 있는 선택적 작은 정수입니다. :attr:`_fields_`\\가 대입될 때 "
":attr:`_pack_`\\는 이미 정의되어 있어야 합니다. 그렇지 않으면 아무 효과가 없습니다."

#: ../Doc/library/ctypes.rst:2382
msgid ""
"An optional sequence that lists the names of unnamed (anonymous) fields. "
":attr:`_anonymous_` must be already defined when :attr:`_fields_` is "
"assigned, otherwise it will have no effect."
msgstr ""
"이름 없는(익명) 필드의 이름을 나열하는 선택적 시퀀스. :attr:`_fields_`\\가 대입될 때 "
":attr:`_anonymous_`\\는 이미 정의되어 있어야 합니다. 그렇지 않으면 아무 효과가 없습니다."

#: ../Doc/library/ctypes.rst:2386
msgid ""
"The fields listed in this variable must be structure or union type "
"fields. :mod:`ctypes` will create descriptors in the structure type that "
"allows accessing the nested fields directly, without the need to create "
"the structure or union field."
msgstr ""
"이 변수에 나열된 필드는 구조체나 공용체 형 필드여야 합니다. :mod:`ctypes`\\는 구조체나 공용체 필드를 만들 필요 없이, "
"중첩된 필드에 직접 액세스할 수 있는 디스크립터를 구조체 형에 만듭니다."

#: ../Doc/library/ctypes.rst:2391
msgid "Here is an example type (Windows)::"
msgstr "다음은 예제 형입니다 (윈도우)::"

#: ../Doc/library/ctypes.rst:2404
msgid ""
"The ``TYPEDESC`` structure describes a COM data type, the ``vt`` field "
"specifies which one of the union fields is valid.  Since the ``u`` field "
"is defined as anonymous field, it is now possible to access the members "
"directly off the TYPEDESC instance. ``td.lptdesc`` and ``td.u.lptdesc`` "
"are equivalent, but the former is faster since it does not need to create"
" a temporary union instance::"
msgstr ""
"``TYPEDESC`` 구조체는 COM 데이터형을 설명합니다. ``vt`` 필드는 공용체 필드 중 어느 것이 유효한지 지정합니다. "
"``u`` 필드가 익명 필드로 정의되었으므로, 이제 TYPEDESC 인스턴스에서 멤버에 직접 액세스할 수 있습니다. "
"``td.lptdesc``\\와 ``td.u.lptdesc``\\는 동등하지만, 앞에 있는 것이 임시 공용체 인스턴스를 만들 필요가 "
"없으므로 더 빠릅니다::"

#: ../Doc/library/ctypes.rst:2416
msgid ""
"It is possible to defined sub-subclasses of structures, they inherit the "
"fields of the base class.  If the subclass definition has a separate "
":attr:`_fields_` variable, the fields specified in this are appended to "
"the fields of the base class."
msgstr ""
"구조체 형의 서브-서브 클래스를 정의할 수 있으며, 베이스 클래스의 필드를 상속합니다. 서브 클래스 정의에 별도의 "
":attr:`_fields_` 변수가 있으면, 여기에 지정된 필드가 베이스 클래스의 필드에 추가됩니다."

#: ../Doc/library/ctypes.rst:2421
msgid ""
"Structure and union constructors accept both positional and keyword "
"arguments.  Positional arguments are used to initialize member fields in "
"the same order as they are appear in :attr:`_fields_`.  Keyword arguments"
" in the constructor are interpreted as attribute assignments, so they "
"will initialize :attr:`_fields_` with the same name, or create new "
"attributes for names not present in :attr:`_fields_`."
msgstr ""
"구조체와 공용체 생성자는 위치와 키워드 인자를 모두 받아들입니다. 위치 인자는 :attr:`_fields_`\\에 나타나는 순서대로 멤버"
" 필드를 초기화하는 데 사용됩니다. 생성자의 키워드 인자는 어트리뷰트 대입으로 해석되므로, :attr:`_fields_`\\를 같은 "
"이름으로 초기화하거나, :attr:`_fields_`\\에 없는 이름에 대한 새 어트리뷰트를 만듭니다."

#: ../Doc/library/ctypes.rst:2432
msgid "Arrays and pointers"
msgstr "배열과 포인터"

#: ../Doc/library/ctypes.rst:2436
msgid "Abstract base class for arrays."
msgstr "배열의 추상 베이스 클래스."

#: ../Doc/library/ctypes.rst:2438
msgid ""
"The recommended way to create concrete array types is by multiplying any "
":mod:`ctypes` data type with a positive integer.  Alternatively, you can "
"subclass this type and define :attr:`_length_` and :attr:`_type_` class "
"variables. Array elements can be read and written using standard "
"subscript and slice accesses; for slice reads, the resulting object is "
"*not* itself an :class:`Array`."
msgstr ""
"구상 배열형을 만드는 데 권장되는 방법은, 임의의 :mod:`ctypes` 데이터형에 양의 정수를 곱하는 것입니다. 또는, 이 형의 서브"
" 클래스를 만들고, :attr:`_length_` 와 :attr:`_type_` 클래스 변수를 정의할 수 있습니다. 배열 요소는 표준 "
"서브 스크립트나 슬라이스 액세스를 사용해서 읽고 쓸 수 있습니다; 슬라이스 읽기의 경우, 결과 객체는 :class:`Array`\\가 "
"*아닙니다*."

#: ../Doc/library/ctypes.rst:2448
msgid ""
"A positive integer specifying the number of elements in the array. Out-"
"of-range subscripts result in an :exc:`IndexError`. Will be returned by "
":func:`len`."
msgstr ""
"배열의 요소 수를 지정하는 양의 정수. 범위를 벗어나는 서브 스크립트는 :exc:`IndexError`\\를 일으킵니다. "
":func:`len`\\에 의해 반환됩니다."

#: ../Doc/library/ctypes.rst:2455
msgid "Specifies the type of each element in the array."
msgstr "배열의 각 요소 형을 지정합니다."

#: ../Doc/library/ctypes.rst:2458
msgid ""
"Array subclass constructors accept positional arguments, used to "
"initialize the elements in order."
msgstr "Array 서브 클래스 생성자는 요소를 순서대로 초기화하는 데 사용되는 위치 인자를 받아들입니다."

#: ../Doc/library/ctypes.rst:2464
msgid "Private, abstract base class for pointers."
msgstr "포인터를 위한 내부 추상 베이스 클래스."

#: ../Doc/library/ctypes.rst:2466
msgid ""
"Concrete pointer types are created by calling :func:`POINTER` with the "
"type that will be pointed to; this is done automatically by "
":func:`pointer`."
msgstr ""
"구상 포인터형은 가리킬 형으로 :func:`POINTER`\\를 호출해서 만들어집니다; 이것은 :func:`pointer`\\에 의해 "
"자동으로 수행됩니다."

#: ../Doc/library/ctypes.rst:2470
msgid ""
"If a pointer points to an array, its elements can be read and written "
"using standard subscript and slice accesses.  Pointer objects have no "
"size, so :func:`len` will raise :exc:`TypeError`.  Negative subscripts "
"will read from the memory *before* the pointer (as in C), and out-of-"
"range subscripts will probably crash with an access violation (if you're "
"lucky)."
msgstr ""
"포인터가 배열을 가리키면, 그것의 요소는 표준 서브 스크립트 및 슬라이스 액세스를 사용하여 읽고 쓸 수 있습니다. 포인터 객체는 크기가 "
"없으므로, :func:`len`\\는 :exc:`TypeError`\\를 발생시킵니다. 음수 서브 스크립트는 (C처럼) 포인터 *앞의* "
"메모리를 읽을 것이고, 범위를 벗어나는 서브 스크립트는 (운이 좋다면) 액세스 위반으로 인해 충돌을 일으킬 것입니다."

#: ../Doc/library/ctypes.rst:2480
msgid "Specifies the type pointed to."
msgstr "가리키는 형을 지정합니다."

#: ../Doc/library/ctypes.rst:2484
msgid ""
"Returns the object to which to pointer points.  Assigning to this "
"attribute changes the pointer to point to the assigned object."
msgstr "포인터가 가리키는 객체를 반환합니다. 이 어트리뷰트에 대입하면 대입된 객체를 가리키도록 포인터가 변경됩니다."
