# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-13 22:32+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: KaHee, Yu <yuygh131@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../Doc/library/unittest.mock-examples.rst:2
msgid ":mod:`unittest.mock` --- getting started"
msgstr ":mod:`unittest.mock` --- 시작하기"

#: ../Doc/library/unittest.mock-examples.rst:13
msgid "Using Mock"
msgstr "Mock 사용하기"

#: ../Doc/library/unittest.mock-examples.rst:16
msgid "Mock Patching Methods"
msgstr "Mock Patching 메서드"

#: ../Doc/library/unittest.mock-examples.rst:18
msgid "Common uses for :class:`Mock` objects include:"
msgstr ":class:`Mock` 객체의 일반적인 용도는 다음과 같습니다.:"

#: ../Doc/library/unittest.mock-examples.rst:20
msgid "Patching methods"
msgstr "Patching 메서드"

#: ../Doc/library/unittest.mock-examples.rst:21
msgid "Recording method calls on objects"
msgstr "객체에 대한 메서드 호출 기록"

#: ../Doc/library/unittest.mock-examples.rst:23
msgid ""
"You might want to replace a method on an object to check that it is "
"called with the correct arguments by another part of the system:"
msgstr ""
"객체의 메서드를 대체하여 시스템의 다른부분에서 올바른 인수로 호출되었는지 확인 할 수 있습니다.:"

#: ../Doc/library/unittest.mock-examples.rst:31
msgid ""
"Once our mock has been used (``real.method`` in this example) it has "
"methods and attributes that allow you to make assertions about how it has"
" been used."
msgstr ""
"우선 mock을 사용하면 (이 예제의 ``real.method``) 메서드와 속성이 어떻게 사용되었는지에 대해 주장할 수 있습니다. "

#: ../Doc/library/unittest.mock-examples.rst:36
msgid ""
"In most of these examples the :class:`Mock` and :class:`MagicMock` "
"classes are interchangeable. As the ``MagicMock`` is the more capable "
"class it makes a sensible one to use by default."
msgstr ""
"대부분의 예제에서 :class:`Mock`과 :class:`MagicMock` 클래스들은 서로 바꿔 사용 할 수 있습니다."
"``MagicMock`은 좀 더 유능한 클래스이므로, 기본으로 사용하기에 합리적입니다."

#: ../Doc/library/unittest.mock-examples.rst:40
msgid ""
"Once the mock has been called its :attr:`~Mock.called` attribute is set "
"to ``True``. More importantly we can use the "
":meth:`~Mock.assert_called_with` or :meth:`~Mock.assert_called_once_with`"
" method to check that it was called with the correct arguments."
msgstr ""
"mock을 호출하면 :attr:`~Mock.called` 속성은 ``True``로 설정됩니다."
"더 중요한 건, 우리는 :meth:`~Mock.assert_called_with` 또는 :meth:`~Mock.assert_called_once_with`"
"메서드를 사용하여 올바른 인자로 호출되었는지 확인 할 수 있습니다."

#: ../Doc/library/unittest.mock-examples.rst:45
msgid ""
"This example tests that calling ``ProductionClass().method`` results in a"
" call to the ``something`` method:"
msgstr ""
"이 예제는 ``ProductionClass().method``를 호출하여 ``something`` 메서드를 호출하는지 테스트합니다.:"

#: ../Doc/library/unittest.mock-examples.rst:62
msgid "Mock for Method Calls on an Object"
msgstr "객체에 대한 메서드 호출 Mock"

#: ../Doc/library/unittest.mock-examples.rst:64
msgid ""
"In the last example we patched a method directly on an object to check "
"that it was called correctly. Another common use case is to pass an "
"object into a method (or some part of the system under test) and then "
"check that it is used in the correct way."
msgstr ""
"지난 예제에서 우리는 객체에 대한 메서드를 직접 패치하여 올바르게 호출되었는지 확인했습니다."
"또 다른 일반적인 사용 사례는 메서드(혹은 시스템 일부의 테스트)에 객체를 전달한 다음, "
"올바른 방법으로 전달된 객체가 사용되는지 확인하는 것입니다."

#: ../Doc/library/unittest.mock-examples.rst:69
msgid ""
"The simple ``ProductionClass`` below has a ``closer`` method. If it is "
"called with an object then it calls ``close`` on it."
msgstr ""
"아래의 간단한 ``ProductionClass``는 ``closer`` 메서드를 가지고 있습니다."
"이 객체와 함께 호출된 경우, ``close``를 호출합니다."

#: ../Doc/library/unittest.mock-examples.rst:77
msgid ""
"So to test it we need to pass in an object with a ``close`` method and "
"check that it was called correctly."
msgstr ""
"따라서 함께 호출 된것을 테스트하기 위해선 ``close`` 메서드를 사용하여 객체를 전달하고 "
"올바르게 호출되었는지 확인해야 합니다."

#: ../Doc/library/unittest.mock-examples.rst:85
msgid ""
"We don't have to do any work to provide the 'close' method on our mock. "
"Accessing close creates it. So, if 'close' hasn't already been called "
"then accessing it in the test will create it, but "
":meth:`~Mock.assert_called_with` will raise a failure exception."
msgstr ""
"우리는 mock에 'close' 메서드를 제공하기 위해 어떠한 노력도 하지 않아도 됩니다."
"close에 접근하면, 해당 메서드가 생성됩니다. 따라서 만약 'close'가 아직 호출되지 않았다면, "
"테스트에서 이것을 생성하기 위해 접근하면, :meth:`~Mock.assert_called_with`는 실패 예외가 발생됩니다."

#: ../Doc/library/unittest.mock-examples.rst:92
msgid "Mocking Classes"
msgstr "Mocking 클래스"

# TODO (2019. 5) mock out, mocked 해석 어색
#: ../Doc/library/unittest.mock-examples.rst:94
msgid ""
"A common use case is to mock out classes instantiated by your code under "
"test. When you patch a class, then that class is replaced with a mock. "
"Instances are created by *calling the class*. This means you access the "
"\"mock instance\" by looking at the return value of the mocked class."
msgstr ""
"일반적인 사용 사례는 테스트중인 코드에서 인스턴스화된 클래스를 mock으로 대체하는 것입니다."
"클래스를 패치할 때, 그 클래스는 mock으로 대체됩니다."
"인스턴스는 *클래스를 호출* 하여 생성됩니다."
"대체된 클래스의 반환 값을 보고 \"mock 인스턴스\" 에 접근한다는 것을 의미합니다."

#: ../Doc/library/unittest.`mock-examples.rst:99
msgid ""
"In the example below we have a function ``some_function`` that "
"instantiates ``Foo`` and calls a method on it. The call to :func:`patch` "
"replaces the class ``Foo`` with a mock. The ``Foo`` instance is the "
"result of calling the mock, so it is configured by modifying the mock "
":attr:`~Mock.return_value`."
msgstr ""
"아래 예제에서, ``Foo`` 를 인스턴스화하고 이를 호출하는 메서드를 가진 ``some_function`` 함수가 있습니다."
" :func:`patch` 호출하면, 클래스 ``Foo`` 가 mock 객체로 대체됩니다."
"``Foo`` 인스턴스는 mock을 호출한 결과로서 mock의 :attr:`~Mock.return_value` 를 수정하여 구성됩니다."

#: ../Doc/library/unittest.mock-examples.rst:116
msgid "Naming your mocks"
msgstr "mocks 이름 짓기"

#: ../Doc/library/unittest.mock-examples.rst:118
msgid ""
"It can be useful to give your mocks a name. The name is shown in the repr"
" of the mock and can be helpful when the mock appears in test failure "
"messages. The name is also propagated to attributes or methods of the "
"mock:"
msgstr ""
"mock에 이름을 짓는 것은 유용 할 수 있습니다. 이름은 mock의 repr에 표시되며"
"테스트 실패 메시지에 mock이 표시될 때 도움이 될 수 있습니다."
"또한 이름은 mock의 속성이나 메서드에도 전달됩니다."

#: ../Doc/library/unittest.mock-examples.rst:130
msgid "Tracking all Calls"
msgstr "모든 호출 트래킹하기"

#: ../Doc/library/unittest.mock-examples.rst:132
msgid ""
"Often you want to track more than a single call to a method. The "
":attr:`~Mock.mock_calls` attribute records all calls to child attributes "
"of the mock - and also to their children."
msgstr ""
"종종 메서드에 대한 단일 호출이상을 추적하려고 합니다."
" :attr:`~Mock.mock_calls` 속성은 모든 mock의 자식 속성에 대한 호출 기록합니다."
"- 또한 그들의 자식 속성도"

# TODO (2019. 5) assertion 해석 어색
#: ../Doc/library/unittest.mock-examples.rst:144
msgid ""
"If you make an assertion about ``mock_calls`` and any unexpected methods "
"have been called, then the assertion will fail. This is useful because as"
" well as asserting that the calls you expected have been made, you are "
"also checking that they were made in the right order and with no "
"additional calls:"
msgstr ""
"만약``mock_calls``에 대해 assertion 하고, 예상치 못한 메소드가 호출 된 경우, "
"그 assertion 은 실패 합니다. 이는 예상한 호출에 대한 확인(asserting) 뿐만 아니라,"
"올바른 순서로 추가적인 호출 없이 이루어졌는지 확인하기 때문에 유용합니다."

#: ../Doc/library/unittest.mock-examples.rst:149
msgid ""
"You use the :data:`call` object to construct lists for comparing with "
"``mock_calls``:"
msgstr ""
" ``mock_calls`` 과 비교하기 위한 리스트를 생성하기 위해 :data:`call` 객체를 사용합니다."

#: ../Doc/library/unittest.mock-examples.rst:156
msgid ""
"However, parameters to calls that return mocks are not recorded, which "
"means it is not possible to track nested calls where the parameters used "
"to create ancestors are important:"
msgstr ""
"그러나 mock을 반환하는 호출에 대한 매개 변수는 기록되지 않습니다. 따라서 조상을 만드는 데 사용된"
"매개 변수가 중요한 중첩 호출을 추적하는 것은 불가능합니다."

#: ../Doc/library/unittest.mock-examples.rst:167
msgid "Setting Return Values and Attributes"
msgstr "반환 값과 속성 설정하"

#: ../Doc/library/unittest.mock-examples.rst:169
msgid "Setting the return values on a mock object is trivially easy:"
msgstr "mock 객체에서 반환 값을 설정하는 것은 쉽습니다.:"

#: ../Doc/library/unittest.mock-examples.rst:176
msgid "Of course you can do the same for methods on the mock:"
msgstr "물론 mock 함수에서도 같은 설정을 할 수 있습니다.:"

#: ../Doc/library/unittest.mock-examples.rst:183
msgid "The return value can also be set in the constructor:"
msgstr "반환 값은 생성자에서도 설정할 수 있습니다."

#: ../Doc/library/unittest.mock-examples.rst:189
msgid "If you need an attribute setting on your mock, just do it:"
msgstr "만약 mock에서 속성 설정이 필요한 경우, 바로 설정하시면 됩니다."

# TODO (2019. 5) mockup
#: ../Doc/library/unittest.mock-examples.rst:196
msgid ""
"Sometimes you want to mock up a more complex situation, like for example "
"``mock.connection.cursor().execute(\"SELECT 1\")``. If we wanted this "
"call to return a list, then we have to configure the result of the nested"
" call."
msgstr ""
"``mock.connection.cursor().execute(\"SELECT 1\")`` 같은 예제처럼 "
"때로는 좀 더 복잡한 상황을 목업(mockup)하고 싶을 때가 있습니다."
"만약 이 호출을 리스트로 반환하려면, 중첩 호출의 결과를 구성해야합니다."

# TODO (2019. 5) assertion
#: ../Doc/library/unittest.mock-examples.rst:200
msgid ""
"We can use :data:`call` to construct the set of calls in a \"chained "
"call\" like this for easy assertion afterwards:"
msgstr ""
" :data:`call` 를 사용하여 나중에 쉽게 assertion 하기위해,"
" \"연결 된 호출\" 에서 호출 집합을 구성 할 수 있습니다."

# TODO (2019. 5) call 호출이라고 하는게 맞는가? 콜이라고 하는게 낫나?
#: ../Doc/library/unittest.mock-examples.rst:214
msgid ""
"It is the call to ``.call_list()`` that turns our call object into a list"
" of calls representing the chained calls."
msgstr ""
" ``.call_list()``를 호출하여 연결 된 호출을 나타내는 호출 리스트를 가진 호출 객체로 바뀝니다."

#: ../Doc/library/unittest.mock-examples.rst:219
msgid "Raising exceptions with mocks"
msgstr "mock으로 예외 발생시키기"

#: ../Doc/library/unittest.mock-examples.rst:221
msgid ""
"A useful attribute is :attr:`~Mock.side_effect`. If you set this to an "
"exception class or instance then the exception will be raised when the "
"mock is called."
msgstr ""
"유용한 속성은 :attr:`~Mock.side_effect` 입니다. 만약 클래스 또는 인스턴스 예외를 설정하면,"
"mock을 호출 했을 때, 예외가 발생됩니다."

#: ../Doc/library/unittest.mock-examples.rst:233
msgid "Side effect functions and iterables"
msgstr "부족용 함수와 이터러블"

#: ../Doc/library/unittest.mock-examples.rst:235
msgid ""
"``side_effect`` can also be set to a function or an iterable. The use "
"case for ``side_effect`` as an iterable is where your mock is going to be"
" called several times, and you want each call to return a different "
"value. When you set ``side_effect`` to an iterable every call to the mock"
" returns the next value from the iterable:"
msgstr ""
" ``side_effect`` 역시 함수 혹은 이터러블로 설정 할 수 있습니다."
"이터러블로 ``side_effect`` 를 사용하는 사례는 mock이 여러번 호출 되는 곳이며, 매 호출마다"
"다른 값을 반환하기를 원하는 경우입니다."
" ``side_effect`` 를 이터러블로 설정하면, mock을 호출 할때마다 다음 값을 반환합니다.:"

#: ../Doc/library/unittest.mock-examples.rst:250
msgid ""
"For more advanced use cases, like dynamically varying the return values "
"depending on what the mock is called with, ``side_effect`` can be a "
"function. The function will be called with the same arguments as the "
"mock. Whatever the function returns is what the call returns:"
msgstr ""
"mock이 호출되는 것에 따라 반환 값이 동적으로 바뀌는 고급 사용 사례의 경우, "
" ``side_effect`` 가 함수가 될 수 있습니다."
"이 함수는 mock과 같은 인수로 호출됩니다."
"어떠한 함수 반환이든 간에 호출이 반환하는 것입니다."

#: ../Doc/library/unittest.mock-examples.rst:267
msgid "Creating a Mock from an Existing Object"
msgstr "기존 객체에서 mock 생성하기"

#: ../Doc/library/unittest.mock-examples.rst:269
msgid ""
"One problem with over use of mocking is that it couples your tests to the"
" implementation of your mocks rather than your real code. Suppose you "
"have a class that implements ``some_method``. In a test for another "
"class, you provide a mock of this object that *also* provides "
"``some_method``. If later you refactor the first class, so that it no "
"longer has ``some_method`` - then your tests will continue to pass even "
"though your code is now broken!"
msgstr ""
"과도한 mocking 사용의 한 가지 문제점은 실제 코드가 아닌 mock로 구현된 테스트를 결합한다는 것입니다."
" ``some_method`` 를 구현하는 클래스가 있다고 가정해 봅시다."
" *또한* 이 객체의 mock이 제공하는 ``some_method`` 를  다른 클래스 테스트에서도 제공합니다."
"나중에 첫번재 클래스를 리팩토링하여 ``some_method`` 가 없어졌습니다."
"- 코드가 깨졌음에도 불구하고 테스트가 계속 통과될 것입니다."

# TODO (2019. 5) specification : 정의
#: ../Doc/library/unittest.mock-examples.rst:276
msgid ""
":class:`Mock` allows you to provide an object as a specification for the "
"mock, using the *spec* keyword argument. Accessing methods / attributes "
"on the mock that don't exist on your specification object will "
"immediately raise an attribute error. If you change the implementation of"
" your specification, then tests that use that class will start failing "
"immediately without you having to instantiate the class in those tests."
msgstr ""
" :class:`Mock` 은 *spec* 키워드 인수를 사용하여 mock 객체를 정의 할 수 있게 합니다."
"정의된 mock 객체에 존재하지 않는 메서드 / 속성에 접근하면, 속성 오류가 즉시 발생합니다."
"만약 정의을 변경하면, 해당 클래스를 사용하는 테스트는 해당 테스트에서 클래스를 인스턴스화하지 않다도 즉시 실패합니다."

#: ../Doc/library/unittest.mock-examples.rst:289
msgid ""
"Using a specification also enables a smarter matching of calls made to "
"the mock, regardless of whether some parameters were passed as positional"
" or named arguments::"
msgstr ""
"정의를 사용하면 일부 매개 변수가 위치 또는 이름있는 인자로 전달되었는지에 대한 여부와 관계없이"
"mock에 대한 호출을 좀 더 똑똑하게 일치시킬 수 있습니다.::"

#: ../Doc/library/unittest.mock-examples.rst:300
msgid ""
"If you want this smarter matching to also work with method calls on the "
"mock, you can use :ref:`auto-speccing <auto-speccing>`."
msgstr ""
"만약 좀 더 똑독한 매칭을 mock 메서드 호출과 함께 사용하려면,"
" :ref:`auto-speccing <auto-speccing>` 사용하면 됩니다."

#: ../Doc/library/unittest.mock-examples.rst:303
msgid ""
"If you want a stronger form of specification that prevents the setting of"
" arbitrary attributes as well as the getting of them then you can use "
"*spec_set* instead of *spec*."
msgstr ""
"만약 임의의 속성을 설정하는 것뿐만 아니라 설정하지 못하게 하는 더 강력한 규격을 원한다면,"
" *spec* 대신 *spec_set* 을 사용하면 됩니다."

#TODO (2019. 5. 17) 시작
#: ../Doc/library/unittest.mock-examples.rst:310
msgid "Patch Decorators"
msgstr "데코레이터 패치하기"

#: ../Doc/library/unittest.mock-examples.rst:314
msgid ""
"With :func:`patch` it matters that you patch objects in the namespace "
"where they are looked up. This is normally straightforward, but for a "
"quick guide read :ref:`where to patch <where-to-patch>`."
msgstr ""
" :func:`patch`를 사용하면 룩업된 네임스페이스의 객체들을 패치하는 것이 중요합니다."
"이것은 일반적으로 간단하지만, 빠른 안내 위해 :ref:`where to patch <where-to-patch>` 를 참고하세요."

#: ../Doc/library/unittest.mock-examples.rst:319
msgid ""
"A common need in tests is to patch a class attribute or a module "
"attribute, for example patching a builtin or patching a class in a module"
" to test that it is instantiated. Modules and classes are effectively "
"global, so patching on them has to be undone after the test or the patch "
"will persist into other tests and cause hard to diagnose problems."
msgstr ""
"테스트에서 공통적으로 필요한 것은 클래스 속성 또는 모듈 속성을 패치하는 것입니다."
"예를 들어, 모듈에 클래스를 내장하거나 패치하여 이것이 인스턴스화 되었는지 확인하는 테스트가 있습니다."
"모듈과 클래스는 실제로 전역적이므로, 테스트가 끝난 후에는 패치를 풀어줘야 합니다."
"그렇지 않은 경우, 패치가 다른 테스트에도 유지되어 문제를 판단하는데 어려질 수 있습니다."

#: ../Doc/library/unittest.mock-examples.rst:325
msgid ""
"mock provides three convenient decorators for this: :func:`patch`, "
":func:`patch.object` and :func:`patch.dict`. ``patch`` takes a single "
"string, of the form ``package.module.Class.attribute`` to specify the "
"attribute you are patching. It also optionally takes a value that you "
"want the attribute (or class or whatever) to be replaced with. "
"'patch.object' takes an object and the name of the attribute you would "
"like patched, plus optionally the value to patch it with."
msgstr ""
"mock은 3가지의 편리한 데코레이터를 제공합니다.: :func:`patch`, :func:`patch.object` 그리고 :func:`patch.dict`"
"``patch`` 는 ``package.module.Class.attribute`` 형식의 단일 문자열을 이용하여, "
"패치 할 속성을 지정합니다. 또한 선택적으로 대체하고 싶은 속성(또는 클래스 또는 아무거나) 값을 가질 수 있습니다."
"'patch.object'는 객체와 패치하고 싶은 속성의 이름, 그리고 패치할 값을 지정할 수 있습니다."

#: ../Doc/library/unittest.mock-examples.rst:333
msgid "``patch.object``:"
msgstr "``patch.object``:"

#: ../Doc/library/unittest.mock-examples.rst:350
msgid ""
"If you are patching a module (including :mod:`builtins`) then use "
":func:`patch` instead of :func:`patch.object`:"
msgstr ""
"만약 모듈 (:mod:`builtins`을 포함)을 패치하면, :func:`patch.object`"
"대신 :func:`patch` 를 사용하세요"

#: ../Doc/library/unittest.mock-examples.rst:360
msgid "The module name can be 'dotted', in the form ``package.module`` if needed:"
msgstr "필요한 경우 ``package.module`` 형식으로 모듈 이름을 '점'으로 구분 할 수 있습니다."

#: ../Doc/library/unittest.mock-examples.rst:369
msgid "A nice pattern is to actually decorate test methods themselves:"
msgstr "좋은 패턴은 실제로 테스트 메서드 자체를 데코레이트 하는 것입니다."

#: ../Doc/library/unittest.mock-examples.rst:380
msgid ""
"If you want to patch with a Mock, you can use :func:`patch` with only one"
" argument (or :func:`patch.object` with two arguments). The mock will be "
"created for you and passed into the test function / method:"
msgstr ""
"Mock으로 패치하고 싶다면, 하나의 인자 (혹은 두개의 인자가 있는 :func:`patch.object`)와 함께"
":func:`patch` 를 사용할 수 있습니다. mock가 생성되어 테스트 함수 / 메서드로 전달 됩니다.:"

#: ../Doc/library/unittest.mock-examples.rst:392
msgid "You can stack up multiple patch decorators using this pattern:"
msgstr "아래와 같은 패턴을 사용하여 여러개의 패치 데코레이터를 계속 쌓을 수 있습니다.:"

#: ../Doc/library/unittest.mock-examples.rst:403
msgid ""
"When you nest patch decorators the mocks are passed in to the decorated "
"function in the same order they applied (the normal *Python* order that "
"decorators are applied). This means from the bottom up, so in the example"
" above the mock for ``test_module.ClassName2`` is passed in first."
msgstr ""
"패치 데코레이터를 중첩하여 사용 할 때, mock은 데코레이터가 적용된 순서"
"(데코레이터가 적용된 일반적인 **파이썬**// 순서)대로 데코레이팅 된 함수에 전달됩니다."
"즉, 위에서 아래로 적용 되는 것을 의미합니다."
"위의 예제에서 ``test_module.ClassName2``\\가 먼저 mock에 전달됩니다."

#: ../Doc/library/unittest.mock-examples.rst:408
msgid ""
"There is also :func:`patch.dict` for setting values in a dictionary just "
"during a scope and restoring the dictionary to its original state when "
"the test ends:"
msgstr ""
"또한 범위 내에서 딕셔너리에 값을 설정하고, 테스트가 끝나면 딕셔너리를 원래 상태로 다시"
"되돌리는 :func:`patch.dict` 도 있습니다."

#: ../Doc/library/unittest.mock-examples.rst:419
msgid ""
"``patch``, ``patch.object`` and ``patch.dict`` can all be used as context"
" managers."
msgstr ""
"``patch``\\, ``patch.object`` 그리고 ``patch.dict``\\는 모두 컨텍스트 관리자로 사용할 수 있습니다."

#: ../Doc/library/unittest.mock-examples.rst:421
msgid ""
"Where you use :func:`patch` to create a mock for you, you can get a "
"reference to the mock using the \"as\" form of the with statement:"
msgstr ""
"mock을 생성하기 위해 :func:`patch` 를 사용하는 경우,"
"with 문에서 \"as\" 형식 사용하여 mock에 대한 참조를 얻을 수 있습니다.:"

#: ../Doc/library/unittest.mock-examples.rst:436
msgid ""
"As an alternative ``patch``, ``patch.object`` and ``patch.dict`` can be "
"used as class decorators. When used in this way it is the same as "
"applying the decorator individually to every method whose name starts "
"with \"test\"."
msgstr ""
"다른 ``patch`` 로, ``patch.object`` 그리고 ``patch.dict`` 를 클래스 데코레이터로"
"사용 할 수 있습니다. 이 방법을 이용하는 경우, 이름이 \"test\"로 시작하는 모든 메서드에"
"개별적으로 데코레이터를 적용하는 것과 같습니다."

#: ../Doc/library/unittest.mock-examples.rst:444
msgid "Further Examples"
msgstr "추가 예제"

#: ../Doc/library/unittest.mock-examples.rst:447
msgid "Here are some more examples for some slightly more advanced scenarios."
msgstr "조금 더 고급스러운 시나리오에 대한 몇가지 예시가 있습니다."

#: ../Doc/library/unittest.mock-examples.rst:451
msgid "Mocking chained calls"
msgstr "체이닝 된 호출 Mocking 하기"

#: ../Doc/library/unittest.mock-examples.rst:453
msgid ""
"Mocking chained calls is actually straightforward with mock once you "
"understand the :attr:`~Mock.return_value` attribute. When a mock is "
"called for the first time, or you fetch its ``return_value`` before it "
"has been called, a new :class:`Mock` is created."
msgstr ""
"체이닝 된 호출은 :attr:`~Mock.return_value` 속성을 이해하고 나면, mock이 좀 더 간단해집니다."
"mock을 처음 호출하거나, 호출되기 전 ``return_value`` 를 패치하면 새로운 :class:`Mock`이 생성됩니다."

#: ../Doc/library/unittest.mock-examples.rst:458
msgid ""
"This means that you can see how the object returned from a call to a "
"mocked object has been used by interrogating the ``return_value`` mock:"
msgstr ""
"즉, mock 된 객체 호출에서 반환된 객체가 ``return_value`` mock을 통해 어떻게 사용되었는지 확인할 수 있습니다.:"

#: ../Doc/library/unittest.mock-examples.rst:466
msgid ""
"From here it is a simple step to configure and then make assertions about"
" chained calls. Of course another alternative is writing your code in a "
"more testable way in the first place..."
msgstr ""
"여기에서 체이닝 된 호출에 대해 구성한 뒤, 어설션을 수행하는 간단한 단계입니다."
"물론 다른 대안은 처음부터 코드를 좀 더 테스트 가능한 방식으로 작성하는 것입니다."

#: ../Doc/library/unittest.mock-examples.rst:470
msgid "So, suppose we have some code that looks a little bit like this:"
msgstr "따라서 우리는 이 코드와 비슷한 코드를 가지고 있다고 가정해 봅시다."

#: ../Doc/library/unittest.mock-examples.rst:479
msgid ""
"Assuming that ``BackendProvider`` is already well tested, how do we test "
"``method()``? Specifically, we want to test that the code section ``# "
"more code`` uses the response object in the correct way."
msgstr ""
"``BackendProvider``\\의 테스트가 이미 잘 되었다고 가정하면, ``method()`` 를 테스트하는 방법은 무엇일까요?"
"특히 코드 섹션 ``# more code`` 가 응답 객체를 올바른 방법으로 사용하는지 테스트하고 싶습니다. "

#: ../Doc/library/unittest.mock-examples.rst:483
msgid ""
"As this chain of calls is made from an instance attribute we can monkey "
"patch the ``backend`` attribute on a ``Something`` instance. In this "
"particular case we are only interested in the return value from the final"
" call to ``start_call`` so we don't have much configuration to do. Let's "
"assume the object it returns is 'file-like', so we'll ensure that our "
"response object uses the builtin :func:`open` as its ``spec``."
msgstr ""
" ``Something`` 인스턴스에 ``backend`` 속성을 몽키패치(Monkey Patch) 할 수 있는"
"인스턴스 속성으로부터 호출 체인이 생성됩니다. "
"이러한 특별 케이스에서는 ``start_call``\\에 대한 최종 호출의 반환 값에만 관심이 있기 때문에"
"많은 구성이 필요하지 않습니다."
"반환하는 객체가 '파일형'이라고 가정하고, 응답 객체를 내장 된 :func:`open`을 ``spec`` 로 사용하도록 할 것 입니다."

#: ../Doc/library/unittest.mock-examples.rst:490
msgid ""
"To do this we create a mock instance as our mock backend and create a "
"mock response object for it. To set the response as the return value for "
"that final ``start_call`` we could do this::"
msgstr ""
"이를 위해 mock 백엔드로서 mock 인스턴스를 생성하고 이를 위한 mock 응답을 생성합니다."
"마지막 ``start_call`` 에 대한 응답을 반환 값으로 설정하기 위해선, 다음을 수행 해야 합니다.:"

#: ../Doc/library/unittest.mock-examples.rst:496
msgid ""
"We can do that in a slightly nicer way using the "
":meth:`~Mock.configure_mock` method to directly set the return value for "
"us:"
msgstr ""
":meth:`~Mock.configure_mock` 메서드를 사용하여 우리가 반환 값을"
"직접 설정하는 방식으로 좀 더 좋게 할 수 있습니다."

#: ../Doc/library/unittest.mock-examples.rst:505
msgid ""
"With these we monkey patch the \"mock backend\" in place and can make the"
" real call:"
msgstr ""
"이러한 \"mock backend\" 에서 몽키패치(Monkey patch)하고 실제 호출을 만들 수 있습니다.:"

#: ../Doc/library/unittest.mock-examples.rst:511
msgid ""
"Using :attr:`~Mock.mock_calls` we can check the chained call with a "
"single assert. A chained call is several calls in one line of code, so "
"there will be several entries in ``mock_calls``. We can use "
":meth:`call.call_list` to create this list of calls for us:"
msgstr ""
":attr:`~Mock.mock_calls` 을 이용하여 체인 된 호출을 단일 assert 으로 확인 할 수 있습니다."
"체인 된 호출은 한 줄의 코드에서 여러번 호출되기 때문에, ``mock_calls`` 에 여러 속성들이 있습니다."
":meth:`call.call_list`를 이용해서, 호출 목록을 만들 수 있습니다."

#: ../Doc/library/unittest.mock-examples.rst:522
msgid "Partial mocking"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:524
msgid ""
"In some tests I wanted to mock out a call to :meth:`datetime.date.today` "
"to return a known date, but I didn't want to prevent the code under test "
"from creating new date objects. Unfortunately :class:`datetime.date` is "
"written in C, and so I couldn't just monkey-patch out the static "
":meth:`date.today` method."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:529
msgid ""
"I found a simple way of doing this that involved effectively wrapping the"
" date class with a mock, but passing through calls to the constructor to "
"the real class (and returning real instances)."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:533
msgid ""
"The :func:`patch decorator <patch>` is used here to mock out the ``date``"
" class in the module under test. The :attr:`side_effect` attribute on the"
" mock date class is then set to a lambda function that returns a real "
"date. When the mock date class is called a real date will be constructed "
"and returned by ``side_effect``."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:548
msgid ""
"Note that we don't patch :class:`datetime.date` globally, we patch "
"``date`` in the module that *uses* it. See :ref:`where to patch <where-"
"to-patch>`."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:551
msgid ""
"When ``date.today()`` is called a known date is returned, but calls to "
"the ``date(...)`` constructor still return normal dates. Without this you"
" can find yourself having to calculate an expected result using exactly "
"the same algorithm as the code under test, which is a classic testing "
"anti-pattern."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:556
msgid ""
"Calls to the date constructor are recorded in the ``mock_date`` "
"attributes (``call_count`` and friends) which may also be useful for your"
" tests."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:559
msgid ""
"An alternative way of dealing with mocking dates, or other builtin "
"classes, is discussed in `this blog entry "
"<https://williambert.online/2011/07/how-to-unit-testing-in-django-with-"
"mocking-and-patching/>`_."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:565
msgid "Mocking a Generator Method"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:567
msgid ""
"A Python generator is a function or method that uses the :keyword:`yield`"
" statement to return a series of values when iterated over [#]_."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:570
msgid ""
"A generator method / function is called to return the generator object. "
"It is the generator object that is then iterated over. The protocol "
"method for iteration is :meth:`~container.__iter__`, so we can mock this "
"using a :class:`MagicMock`."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:575
msgid ""
"Here's an example class with an \"iter\" method implemented as a "
"generator:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:587
msgid "How would we mock this class, and in particular its \"iter\" method?"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:589
msgid ""
"To configure the values returned from the iteration (implicit in the call"
" to :class:`list`), we need to configure the object returned by the call "
"to ``foo.iter()``."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:597
msgid ""
"There are also generator expressions and more `advanced uses "
"<http://www.dabeaz.com/coroutines/index.html>`_ of generators, but we "
"aren't concerned about them here. A very good introduction to generators "
"and how powerful they are is: `Generator Tricks for Systems Programmers "
"<http://www.dabeaz.com/generators/>`_."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:605
msgid "Applying the same patch to every test method"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:607
msgid ""
"If you want several patches in place for multiple test methods the "
"obvious way is to apply the patch decorators to every method. This can "
"feel like unnecessary repetition. For Python 2.6 or more recent you can "
"use :func:`patch` (in all its various forms) as a class decorator. This "
"applies the patches to all test methods on the class. A test method is "
"identified by methods whose names start with ``test``:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:631
msgid ""
"An alternative way of managing patches is to use the :ref:`start-and-"
"stop`. These allow you to move the patching into your ``setUp`` and "
"``tearDown`` methods."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:647
msgid ""
"If you use this technique you must ensure that the patching is \"undone\""
" by calling ``stop``. This can be fiddlier than you might think, because "
"if an exception is raised in the setUp then tearDown is not called. "
":meth:`unittest.TestCase.addCleanup` makes this easier:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:665
msgid "Mocking Unbound Methods"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:667
msgid ""
"Whilst writing tests today I needed to patch an *unbound method* "
"(patching the method on the class rather than on the instance). I needed "
"self to be passed in as the first argument because I want to make asserts"
" about which objects were calling this particular method. The issue is "
"that you can't patch with a mock for this, because if you replace an "
"unbound method with a mock it doesn't become a bound method when fetched "
"from the instance, and so it doesn't get self passed in. The workaround "
"is to patch the unbound method with a real function instead. The "
":func:`patch` decorator makes it so simple to patch out methods with a "
"mock that having to create a real function becomes a nuisance."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:678
msgid ""
"If you pass ``autospec=True`` to patch then it does the patching with a "
"*real* function object. This function object has the same signature as "
"the one it is replacing, but delegates to a mock under the hood. You "
"still get your mock auto-created in exactly the same way as before. What "
"it means though, is that if you use it to patch out an unbound method on "
"a class the mocked function will be turned into a bound method if it is "
"fetched from an instance. It will have ``self`` passed in as the first "
"argument, which is exactly what I wanted:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:699
msgid ""
"If we don't use ``autospec=True`` then the unbound method is patched out "
"with a Mock instance instead, and isn't called with ``self``."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:704
msgid "Checking multiple calls with mock"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:706
msgid ""
"mock has a nice API for making assertions about how your mock objects are"
" used."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:713
msgid ""
"If your mock is only being called once you can use the "
":meth:`assert_called_once_with` method that also asserts that the "
":attr:`call_count` is one."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:724
msgid ""
"Both ``assert_called_with`` and ``assert_called_once_with`` make "
"assertions about the *most recent* call. If your mock is going to be "
"called several times, and you want to make assertions about *all* those "
"calls you can use :attr:`~Mock.call_args_list`:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:736
msgid ""
"The :data:`call` helper makes it easy to make assertions about these "
"calls. You can build up a list of expected calls and compare it to "
"``call_args_list``. This looks remarkably similar to the repr of the "
"``call_args_list``:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:746
msgid "Coping with mutable arguments"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:748
msgid ""
"Another situation is rare, but can bite you, is when your mock is called "
"with mutable arguments. ``call_args`` and ``call_args_list`` store "
"*references* to the arguments. If the arguments are mutated by the code "
"under test then you can no longer make assertions about what the values "
"were when the mock was called."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:753
msgid ""
"Here's some example code that shows the problem. Imagine the following "
"functions defined in 'mymodule'::"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:764
msgid ""
"When we try to test that ``grob`` calls ``frob`` with the correct "
"argument look what happens:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:779
msgid ""
"One possibility would be for mock to copy the arguments you pass in. This"
" could then cause problems if you do assertions that rely on object "
"identity for equality."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:783
msgid ""
"Here's one solution that uses the :attr:`side_effect` functionality. If "
"you provide a ``side_effect`` function for a mock then ``side_effect`` "
"will be called with the same args as the mock. This gives us an "
"opportunity to copy the arguments and store them for later assertions. In"
" this example I'm using *another* mock to store the arguments so that I "
"can use the mock methods for doing the assertion. Again a helper function"
" sets this up for me."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:812
msgid ""
"``copy_call_args`` is called with the mock that will be called. It "
"returns a new mock that we do the assertion on. The ``side_effect`` "
"function makes a copy of the args and calls our ``new_mock`` with the "
"copy."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:818
msgid ""
"If your mock is only going to be used once there is an easier way of "
"checking arguments at the point they are called. You can simply do the "
"checking inside a ``side_effect`` function."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:832
msgid ""
"An alternative approach is to create a subclass of :class:`Mock` or "
":class:`MagicMock` that copies (using :func:`copy.deepcopy`) the "
"arguments. Here's an example implementation:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:856
msgid ""
"When you subclass ``Mock`` or ``MagicMock`` all dynamically created "
"attributes, and the ``return_value`` will use your subclass "
"automatically. That means all children of a ``CopyingMock`` will also "
"have the type ``CopyingMock``."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:862
msgid "Nesting Patches"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:864
msgid ""
"Using patch as a context manager is nice, but if you do multiple patches "
"you can end up with nested with statements indenting further and further "
"to the right:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:882
msgid ""
"With unittest ``cleanup`` functions and the :ref:`start-and-stop` we can "
"achieve the same effect without the nested indentation. A simple helper "
"method, ``create_patch``, puts the patch in place and returns the created"
" mock for us:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:910
msgid "Mocking a dictionary with MagicMock"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:912
msgid ""
"You may want to mock a dictionary, or other container object, recording "
"all access to it whilst having it still behave like a dictionary."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:915
msgid ""
"We can do this with :class:`MagicMock`, which will behave like a "
"dictionary, and using :data:`~Mock.side_effect` to delegate dictionary "
"access to a real underlying dictionary that is under our control."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:919
msgid ""
"When the :meth:`__getitem__` and :meth:`__setitem__` methods of our "
"``MagicMock`` are called (normal dictionary access) then ``side_effect`` "
"is called with the key (and in the case of ``__setitem__`` the value "
"too). We can also control what is returned."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:923
msgid ""
"After the ``MagicMock`` has been used we can use attributes like "
":data:`~Mock.call_args_list` to assert about how the dictionary was used:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:939
msgid ""
"An alternative to using ``MagicMock`` is to use ``Mock`` and *only* "
"provide the magic methods you specifically want:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:946
msgid ""
"A *third* option is to use ``MagicMock`` but passing in ``dict`` as the "
"*spec* (or *spec_set*) argument so that the ``MagicMock`` created only "
"has dictionary magic methods available:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:954
msgid ""
"With these side effect functions in place, the ``mock`` will behave like "
"a normal dictionary but recording the access. It even raises a "
":exc:`KeyError` if you try to access a key that doesn't exist."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:973
msgid ""
"After it has been used you can make assertions about the access using the"
" normal mock methods and attributes:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:985
msgid "Mock subclasses and their attributes"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:987
msgid ""
"There are various reasons why you might want to subclass :class:`Mock`. "
"One reason might be to add helper methods. Here's a silly example:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1003
msgid ""
"The standard behaviour for ``Mock`` instances is that attributes and the "
"return value mocks are of the same type as the mock they are accessed on."
" This ensures that ``Mock`` attributes are ``Mocks`` and ``MagicMock`` "
"attributes are ``MagicMocks`` [#]_. So if you're subclassing to add "
"helper methods then they'll also be available on the attributes and "
"return value mock of instances of your subclass."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1019
msgid ""
"Sometimes this is inconvenient. For example, `one user "
"<https://code.google.com/archive/p/mock/issues/105>`_ is subclassing mock"
" to created a `Twisted adaptor "
"<https://twistedmatrix.com/documents/11.0.0/api/twisted.python.components.html>`_."
" Having this applied to attributes too actually causes errors."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1025
msgid ""
"``Mock`` (in all its flavours) uses a method called ``_get_child_mock`` "
"to create these \"sub-mocks\" for attributes and return values. You can "
"prevent your subclass being used for attributes by overriding this "
"method. The signature is that it takes arbitrary keyword arguments "
"(``**kwargs``) which are then passed onto the mock constructor:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1042
msgid ""
"An exception to this rule are the non-callable mocks. Attributes use the "
"callable variant because otherwise non-callable mocks couldn't have "
"callable methods."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1048
msgid "Mocking imports with patch.dict"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1050
msgid ""
"One situation where mocking can be hard is where you have a local import "
"inside a function. These are harder to mock because they aren't using an "
"object from the module namespace that we can patch out."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1054
msgid ""
"Generally local imports are to be avoided. They are sometimes done to "
"prevent circular dependencies, for which there is *usually* a much better"
" way to solve the problem (refactor the code) or to prevent \"up front "
"costs\" by delaying the import. This can also be solved in better ways "
"than an unconditional local import (store the module as a class or module"
" attribute and only do the import on first use)."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1061
msgid ""
"That aside there is a way to use ``mock`` to affect the results of an "
"import. Importing fetches an *object* from the :data:`sys.modules` "
"dictionary. Note that it fetches an *object*, which need not be a module."
" Importing a module for the first time results in a module object being "
"put in `sys.modules`, so usually when you import something you get a "
"module back. This need not be the case however."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1068
msgid ""
"This means you can use :func:`patch.dict` to *temporarily* put a mock in "
"place in :data:`sys.modules`. Any imports whilst this patch is active "
"will fetch the mock. When the patch is complete (the decorated function "
"exits, the with statement body is complete or ``patcher.stop()`` is "
"called) then whatever was there previously will be restored safely."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1074
msgid "Here's an example that mocks out the 'fooble' module."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1085
msgid ""
"As you can see the ``import fooble`` succeeds, but on exit there is no "
"'fooble' left in :data:`sys.modules`."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1088
msgid "This also works for the ``from module import name`` form:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1098
msgid "With slightly more work you can also mock package imports:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1111
msgid "Tracking order of calls and less verbose call assertions"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1113
msgid ""
"The :class:`Mock` class allows you to track the *order* of method calls "
"on your mock objects through the :attr:`~Mock.method_calls` attribute. "
"This doesn't allow you to track the order of calls between separate mock "
"objects, however we can use :attr:`~Mock.mock_calls` to achieve the same "
"effect."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1118
msgid ""
"Because mocks track calls to child mocks in ``mock_calls``, and accessing"
" an arbitrary attribute of a mock creates a child mock, we can create our"
" separate mocks from a parent one. Calls to those child mock will then "
"all be recorded, in order, in the ``mock_calls`` of the parent:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1135
msgid ""
"We can then assert about the calls, including the order, by comparing "
"with the ``mock_calls`` attribute on the manager mock:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1142
msgid ""
"If ``patch`` is creating, and putting in place, your mocks then you can "
"attach them to a manager mock using the :meth:`~Mock.attach_mock` method."
" After attaching calls will be recorded in ``mock_calls`` of the manager."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1162
msgid ""
"If many calls have been made, but you're only interested in a particular "
"sequence of them then an alternative is to use the "
":meth:`~Mock.assert_has_calls` method. This takes a list of calls "
"(constructed with the :data:`call` object). If that sequence of calls are"
" in :attr:`~Mock.mock_calls` then the assert succeeds."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1176
msgid ""
"Even though the chained call ``m.one().two().three()`` aren't the only "
"calls that have been made to the mock, the assert still succeeds."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1179
msgid ""
"Sometimes a mock may have several calls made to it, and you are only "
"interested in asserting about *some* of those calls. You may not even "
"care about the order. In this case you can pass ``any_order=True`` to "
"``assert_has_calls``:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1191
msgid "More complex argument matching"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1193
msgid ""
"Using the same basic concept as :data:`ANY` we can implement matchers to "
"do more complex assertions on objects used as arguments to mocks."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1196
msgid ""
"Suppose we expect some object to be passed to a mock that by default "
"compares equal based on object identity (which is the Python default for "
"user defined classes). To use :meth:`~Mock.assert_called_with` we would "
"need to pass in the exact same object. If we are only interested in some "
"of the attributes of this object then we can create a matcher that will "
"check these attributes for us."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1203
msgid ""
"You can see in this example how a 'standard' call to "
"``assert_called_with`` isn't sufficient:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1218
msgid ""
"A comparison function for our ``Foo`` class might look something like "
"this:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1230
msgid ""
"And a matcher object that can use comparison functions like this for its "
"equality operation would look something like this:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1241
msgid "Putting all this together:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1246
msgid ""
"The ``Matcher`` is instantiated with our compare function and the ``Foo``"
" object we want to compare against. In ``assert_called_with`` the "
"``Matcher`` equality method will be called, which compares the object the"
" mock was called with against the one we created our matcher with. If "
"they match then ``assert_called_with`` passes, and if they don't an "
":exc:`AssertionError` is raised:"
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1259
msgid ""
"With a bit of tweaking you could have the comparison function raise the "
":exc:`AssertionError` directly and provide a more useful failure message."
msgstr ""

#: ../Doc/library/unittest.mock-examples.rst:1262
msgid ""
"As of version 1.5, the Python testing library `PyHamcrest "
"<https://pyhamcrest.readthedocs.io/>`_ provides similar functionality, "
"that may be useful here, in the form of its equality matcher "
"(`hamcrest.library.integration.match_equality "
"<https://pyhamcrest.readthedocs.io/en/release-1.8/integration/#module-"
"hamcrest.library.integration.match_equality>`_)."
msgstr ""