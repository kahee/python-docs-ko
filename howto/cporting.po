# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-25 10:27+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../Doc/howto/cporting.rst:7
msgid "Porting Extension Modules to Python 3"
msgstr "확장 모듈을 파이썬 3에 이식하기"

#: ../Doc/howto/cporting.rst
msgid "author"
msgstr "저자"

#: ../Doc/howto/cporting.rst:9
msgid "Benjamin Peterson"
msgstr "Benjamin Peterson"

msgid "Abstract"
msgstr "요약"

#: ../Doc/howto/cporting.rst:14
msgid ""
"Although changing the C-API was not one of Python 3's objectives, the "
"many Python-level changes made leaving Python 2's API intact impossible."
"  In fact, some changes such as :func:`int` and :func:`long` unification "
"are more obvious on the C level.  This document endeavors to document "
"incompatibilities and how they can be worked around."
msgstr ""
"C-API를 변경하는 것이 파이썬 3의 목표 중 하나는 아니었지만, 파이썬 수준의 많은 변경으로 인해 파이썬 2의 API를 그대로 "
"남겨두는 것은 불가능했습니다. 사실, :func:`int`\\와 :func:`long` 통합과 같은 일부 변경 사항은 C 수준에서 더 "
"분명합니다. 이 문서는 비 호환성을 기록으로 남기고 그 문제를 해결하는 방법을 설명합니다."

#: ../Doc/howto/cporting.rst:23
msgid "Conditional compilation"
msgstr "조건부 컴파일"

#: ../Doc/howto/cporting.rst:25
msgid ""
"The easiest way to compile only some code for Python 3 is to check if "
":c:macro:`PY_MAJOR_VERSION` is greater than or equal to 3. ::"
msgstr ""
"어떤 코드를 파이썬 3에서만 컴파일하는 가장 쉬운 방법은 :c:macro:`PY_MAJOR_VERSION`\\이 3 이상인지 확인하는 "
"것입니다. ::"

#: ../Doc/howto/cporting.rst:32
msgid ""
"API functions that are not present can be aliased to their equivalents "
"within conditional blocks."
msgstr "존재하지 않는 API 함수는 조건 블록 내에서 동등한 것으로 별칭을 만들 수 있습니다."

#: ../Doc/howto/cporting.rst:37
msgid "Changes to Object APIs"
msgstr "객체 API의 변경 사항"

#: ../Doc/howto/cporting.rst:39
msgid ""
"Python 3 merged together some types with similar functions while cleanly "
"separating others."
msgstr "파이썬 3은 비슷한 기능을 가진 일부 형을 병합하면서 다른 것들은 깨끗하게 분리합니다."

#: ../Doc/howto/cporting.rst:44
msgid "str/unicode Unification"
msgstr "str/unicode 통합"

#: ../Doc/howto/cporting.rst:46
msgid ""
"Python 3's :func:`str` type is equivalent to Python 2's :func:`unicode`; "
"the C functions are called ``PyUnicode_*`` for both.  The old 8-bit "
"string type has become :func:`bytes`, with C functions called "
"``PyBytes_*``.  Python 2.6 and later provide a compatibility header, "
":file:`bytesobject.h`, mapping ``PyBytes`` names to ``PyString`` ones.  "
"For best compatibility with Python 3, :c:type:`PyUnicode` should be used "
"for textual data and :c:type:`PyBytes` for binary data.  It's also "
"important to remember that :c:type:`PyBytes` and :c:type:`PyUnicode` in "
"Python 3 are not interchangeable like :c:type:`PyString` and "
":c:type:`PyUnicode` are in Python 2.  The following example shows best "
"practices with regards to :c:type:`PyUnicode`, :c:type:`PyString`, and "
":c:type:`PyBytes`. ::"
msgstr ""
"파이썬 3의 :func:`str` 형은 파이썬 2의 :func:`unicode`\\와 동등합니다; C 함수는 모두 "
"``PyUnicode_*``\\입니다. 이전의 8비트 문자열형은 :func:`bytes`\\가 되었고, C 함수는 "
"``PyBytes_*``\\가 되었습니다. 파이썬 2.6 이상은 호환성 헤더 :file:`bytesobject.h`\\를 제공하며, "
"``PyBytes`` 이름을 ``PyString`` 으로 매핑합니다. 파이썬 3과의 최상의 호환성을 위해, 텍스트 데이터에는 "
":c:type:`PyUnicode`\\를, 바이너리 데이터에는 :c:type:`PyBytes`\\를 사용해야 합니다. 파이썬 3의 "
":c:type:`PyBytes`\\와 :c:type:`PyUnicode`\\가 파이썬 2의 :c:type:`PyString`\\과 "
":c:type:`PyUnicode`\\처럼 교환할 수 없다는 것을 기억하는 것도 중요합니다. 다음 예는 "
":c:type:`PyUnicode`, :c:type:`PyString` 및 :c:type:`PyBytes`\\에 대한 모범 사례를 "
"보여줍니다. ::"

#: ../Doc/howto/cporting.rst:95
msgid "long/int Unification"
msgstr "long/int 통합"

#: ../Doc/howto/cporting.rst:97
msgid ""
"Python 3 has only one integer type, :func:`int`.  But it actually "
"corresponds to Python 2's :func:`long` type—the :func:`int` type used in "
"Python 2 was removed.  In the C-API, ``PyInt_*`` functions are replaced "
"by their ``PyLong_*`` equivalents."
msgstr ""
"파이썬 3은 오직 하나의 정수형 :func:`int`\\만을 가집니다. 그러나 이것은 실제로 파이썬 2의 :func:`long` 형에 "
"해당합니다 - 파이썬 2에서 사용된 :func:`int` 형은 제거되었습니다. C-API에서, ``PyInt_*`` 함수는 동등한 "
"``PyLong_*`` 함수로 대체됩니다."

#: ../Doc/howto/cporting.rst:104
msgid "Module initialization and state"
msgstr "모듈 초기화와 상태"

#: ../Doc/howto/cporting.rst:106
msgid ""
"Python 3 has a revamped extension module initialization system.  (See "
":pep:`3121`.)  Instead of storing module state in globals, they should be"
" stored in an interpreter specific structure.  Creating modules that act "
"correctly in both Python 2 and Python 3 is tricky.  The following simple "
"example demonstrates how. ::"
msgstr ""
"파이썬 3에는 개선된 확장 모듈 초기화 시스템이 있습니다. (:pep:`3121`\\를 참조하십시오.) 모듈 상태를 전역에 저장하는 "
"대신, 인터프리터별 구조체에 저장해야 합니다. 파이썬 2와 파이썬 3 모두에서 올바르게 동작하는 모듈을 만드는 것은 까다 롭습니다. "
"다음의 간단한 예제는 방법을 보여줍니다. ::"

#: ../Doc/howto/cporting.rst:197
msgid "CObject replaced with Capsule"
msgstr "캡슐로 대체된 CObject"

#: ../Doc/howto/cporting.rst:199
msgid ""
"The :c:type:`Capsule` object was introduced in Python 3.1 and 2.7 to "
"replace :c:type:`CObject`.  CObjects were useful, but the "
":c:type:`CObject` API was problematic: it didn't permit distinguishing "
"between valid CObjects, which allowed mismatched CObjects to crash the "
"interpreter, and some of its APIs relied on undefined behavior in C. (For"
" further reading on the rationale behind Capsules, please see "
":issue:`5630`.)"
msgstr ""
":c:type:`Capsule` 객체는 :c:type:`CObject`\\를 대체하기 위해 파이썬 3.1과 2.7에 도입되었습니다. "
"CObject는 유용했지만, :c:type:`CObject` API는 문제가 있었습니다: 유효한 CObject를 구분할 수 없어서 "
"불일치한 CObject가 인터프리터에 충돌을 일으킬 수 있도록 했고, 일부 API는 C의 정의되지 않은 동작에 의존했습니다. (캡슐을 "
"뒷받침하는 이유에 대한 자세한 내용은 :issue:`5630`\\를 참조하십시오.)"

#: ../Doc/howto/cporting.rst:206
msgid ""
"If you're currently using CObjects, and you want to migrate to 3.1 or "
"newer, you'll need to switch to Capsules. :c:type:`CObject` was "
"deprecated in 3.1 and 2.7 and completely removed in Python 3.2.  If you "
"only support 2.7, or 3.1 and above, you can simply switch to "
":c:type:`Capsule`.  If you need to support Python 3.0, or versions of "
"Python earlier than 2.7, you'll have to support both CObjects and "
"Capsules. (Note that Python 3.0 is no longer supported, and it is not "
"recommended for production use.)"
msgstr ""
"현재 CObject를 사용하고 있고, 3.1 이상으로 이전하려고 한다면, 캡슐로 전환해야 합니다. :c:type:`CObject`\\는 "
"3.1과 2.7에서 폐지되었고, 파이썬 3.2에서 완전히 제거되었습니다. 2.7이나 3.1 이상만 지원한다면, 단순히 "
":c:type:`Capsule`\\로 전환할 수 있습니다. 파이썬 3.0이나 2.7 이전의 파이썬 버전을 지원해야 한다면, "
"CObject와 캡슐을 모두 지원해야 합니다. (파이썬 3.0은 더는 지원되지 않으며 프로덕션 용도로 권장되지 않음에 유의하십시오.)"

#: ../Doc/howto/cporting.rst:216
msgid ""
"The following example header file :file:`capsulethunk.h` may solve the "
"problem for you.  Simply write your code against the :c:type:`Capsule` "
"API and include this header file after :file:`Python.h`.  Your code will "
"automatically use Capsules in versions of Python with Capsules, and "
"switch to CObjects when Capsules are unavailable."
msgstr ""
"다음 예제 헤더 파일 :file:`capsulethunk.h`\\는 문제를 해결할 수 있습니다. :c:type:`Capsule` API로"
" 코드를 작성하고, :file:`Python.h` 다음에 이 헤더 파일을 포함하십시오. 여러분의 코드는 자동으로 캡슐이 있는 파이썬 "
"버전에서 캡슐을 사용하고, 캡슐을 사용할 수 없을 때 CObject로 전환합니다."

#: ../Doc/howto/cporting.rst:223
msgid ""
":file:`capsulethunk.h` simulates Capsules using CObjects.  However, "
":c:type:`CObject` provides no place to store the capsule's \"name\".  As "
"a result the simulated :c:type:`Capsule` objects created by "
":file:`capsulethunk.h` behave slightly differently from real Capsules.  "
"Specifically:"
msgstr ""
":file:`capsulethunk.h`\\는 CObject를 사용하여 캡슐을 시뮬레이션합니다. 그러나, "
":c:type:`CObject`\\는 캡슐의 \"이름(name)\"을 저장할 장소를 제공하지 않습니다. 결과적으로 "
":file:`capsulethunk.h`\\가 만든 시뮬레이트 된 :c:type:`Capsule` 객체는 실제 캡슐과 약간 다르게 "
"동작합니다. 구체적으로:"

#: ../Doc/howto/cporting.rst:228
msgid "The name parameter passed in to :c:func:`PyCapsule_New` is ignored."
msgstr ":c:func:`PyCapsule_New`\\에 전달된 name 매개 변수는 무시됩니다."

#: ../Doc/howto/cporting.rst:230
msgid ""
"The name parameter passed in to :c:func:`PyCapsule_IsValid` and "
":c:func:`PyCapsule_GetPointer` is ignored, and no error checking of the "
"name is performed."
msgstr ""
":c:func:`PyCapsule_IsValid` 와 :c:func:`PyCapsule_GetPointer`\\에 전달된 name 매개 "
"변수는 무시되며, name에 대한 에러 검사는 수행되지 않습니다."

#: ../Doc/howto/cporting.rst:234
msgid ":c:func:`PyCapsule_GetName` always returns NULL."
msgstr ":c:func:`PyCapsule_GetName`\\은 항상 NULL을 반환합니다."

#: ../Doc/howto/cporting.rst:236
msgid ""
":c:func:`PyCapsule_SetName` always raises an exception and returns "
"failure.  (Since there's no way to store a name in a CObject, noisy "
"failure of :c:func:`PyCapsule_SetName` was deemed preferable to silent "
"failure here.  If this is inconvenient, feel free to modify your local "
"copy as you see fit.)"
msgstr ""
":c:func:`PyCapsule_SetName`\\은 항상 예외를 발생시키고 실패를 반환합니다. (CObject에 이름을 저장할 수 "
"있는 방법이 없으므로, 여기서 조용한 실패보다 요란한 :c:func:`PyCapsule_SetName`\\의 실패를 선호합니다. 이것이 "
"불편하다면, 적절하다고 생각하는 대로 로컬 복사본을 자유롭게 수정하십시오.)"

#: ../Doc/howto/cporting.rst:243
msgid ""
"You can find :file:`capsulethunk.h` in the Python source distribution as "
":source:`Doc/includes/capsulethunk.h`.  We also include it here for your "
"convenience:"
msgstr ""
":file:`capsulethunk.h`\\는 파이썬 소스 배포판의 "
":source:`Doc/includes/capsulethunk.h`\\에서 찾을 수 있습니다. 여러분의 편의를 위해 여기에도 포함합니다:"

#: ../Doc/howto/cporting.rst:252
msgid "Other options"
msgstr "다른 옵션"

#: ../Doc/howto/cporting.rst:254
msgid ""
"If you are writing a new extension module, you might consider `Cython "
"<http://cython.org/>`_.  It translates a Python-like language to C.  The "
"extension modules it creates are compatible with Python 3 and Python 2."
msgstr ""
"새 확장 모듈을 작성하고 있다면, `Cython <http://cython.org/>`_\\을 고려하십시오. 파이썬과 비슷한 언어를 C로"
" 변환합니다. 만들어진 확장 모듈은 파이썬 3과 파이썬 2 모두와 호환됩니다."
