# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-26 18:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (http://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/distutils/extending.rst:5
msgid "Extending Distutils"
msgstr "Distutils 확장하기"

#: ../Doc/distutils/extending.rst:7
msgid ""
"Distutils can be extended in various ways.  Most extensions take the form"
" of new commands or replacements for existing commands.  New commands may"
" be written to support new types of platform-specific packaging, for "
"example, while replacements for existing commands may be made to modify "
"details of how the command operates on a package."
msgstr ""
"Distutils는 다양한 방법으로 확장할 수 있습니다. 대부분 확장은 새로운 명령이나 기존 명령의 대체 형식을 취합니다. 예를 들어, "
"새로운 유형의 플랫폼 특정 패키징을 지원하기 위해 새로운 명령을 작성할 수 있습니다. 반면, 기존 명령을 대체하여 명령이 패키지에서 "
"작동하는 방식의 세부 사항을 수정할 수 있습니다."

#: ../Doc/distutils/extending.rst:13
msgid ""
"Most extensions of the distutils are made within :file:`setup.py` scripts"
" that want to modify existing commands; many simply add a few file "
"extensions that should be copied into packages in addition to :file:`.py`"
" files as a convenience."
msgstr ""
"distutils의 대부분 확장은 기존 명령을 수정하고자 하는 :file:`setup.py` 스크립트 내에서 이루어집니다; 많은 사람은 "
"편의상 :file:`.py` 파일 외에 패키지에 복사해야 하는 몇 가지 파일 확장자를 추가합니다."

#: ../Doc/distutils/extending.rst:18
msgid ""
"Most distutils command implementations are subclasses of the "
":class:`distutils.cmd.Command` class.  New commands may directly inherit "
"from :class:`Command`, while replacements often derive from "
":class:`Command` indirectly, directly subclassing the command they are "
"replacing.  Commands are required to derive from :class:`Command`."
msgstr ""
"대부분 distutils 명령 구현은 :class:`distutils.cmd.Command` 클래스의 서브 클래스입니다. 새 명령은 "
":class:`Command`\\를 직접 상속할 수 있지만, 대체 명령은 종종 대체할 명령을 직접 서브클래싱해서, 간접적으로 "
":class:`Command`\\를 상속합니다. 명령은 :class:`Command`\\에서 파생되어야 합니다."

#: ../Doc/distutils/extending.rst:33
msgid "Integrating new commands"
msgstr "새 명령 통합하기"

#: ../Doc/distutils/extending.rst:35
msgid ""
"There are different ways to integrate new command implementations into "
"distutils.  The most difficult is to lobby for the inclusion of the new "
"features in distutils itself, and wait for (and require) a version of "
"Python that provides that support.  This is really hard for many reasons."
msgstr ""
"새로운 명령 구현을 distutils에 통합하는 여러 방법이 있습니다. 가장 어려운 것은 distutils 자체에 새로운 기능을 넣기 "
"위해 로비를 하고, 그 지원을 제공하는 파이썬 버전을 기다리는 (그리고 요구하는) 것입니다. 이것은 여러 가지 이유로 정말 어렵습니다."

#: ../Doc/distutils/extending.rst:40
msgid ""
"The most common, and possibly the most reasonable for most needs, is to "
"include the new implementations with your :file:`setup.py` script, and "
"cause the :func:`distutils.core.setup` function use them::"
msgstr ""
"가장 흔한, 그리고 아마도 대부분 필요에 가장 합리적인 것은, :file:`setup.py` 스크립트에 새 구현을 넣고 "
":func:`distutils.core.setup` 함수에서 이를 사용하도록 하는 것입니다.::"

#: ../Doc/distutils/extending.rst:55
msgid ""
"This approach is most valuable if the new implementations must be used to"
" use a particular package, as everyone interested in the package will "
"need to have the new command implementation."
msgstr ""
"이 방법은 특정 패키지를 사용하기 위해 새로운 구현을 사용해야 할 때 가장 유용합니다. 패키지에 관심이 있는 모든 사람이 새로운 명령 "
"구현을 가질 필요가 있기 때문입니다."

#: ../Doc/distutils/extending.rst:59
msgid ""
"Beginning with Python 2.4, a third option is available, intended to allow"
" new commands to be added which can support existing :file:`setup.py` "
"scripts without requiring modifications to the Python installation.  This"
" is expected to allow third-party extensions to provide support for "
"additional packaging systems, but the commands can be used for anything "
"distutils commands can be used for.  A new configuration option, "
"``command_packages`` (command-line option :option:`!--command-packages`),"
" can be used to specify additional packages to be searched for modules "
"implementing commands.  Like all distutils options, this can be specified"
" on the command line or in a configuration file.  This option can only be"
" set in the ``[global]`` section of a configuration file, or before any "
"commands on the command line.  If set in a configuration file, it can be "
"overridden from the command line; setting it to an empty string on the "
"command line causes the default to be used.  This should never be set in "
"a configuration file provided with a package."
msgstr ""
"파이썬 2.4부터는, 세 번째 옵션을 사용할 수 있습니다. 파이썬 설치를 수정하지 않고도 기존 :file:`setup.py` 스크립트를 "
"지원할 수 있는 새로운 명령을 추가 할 수 있습니다. 이것은 제삼자 확장이 추가 패키징 시스템에 대한 지원을 제공토록 할 것으로 "
"기대되지만, 명령은 distutils 명령을 사용할 수 있는 모든 것에 사용할 수 있습니다. 새로운 구성 옵션, "
"``command_packages`` (명령 줄 옵션 :option:`!--command-packages`), 을 사용하여 명령을 "
"구현하는 모듈을 검색할 추가 패키지를 지정할 수 있습니다. 모든 distutils 옵션과 마찬가지로, 이것은 명령 줄이나 구성 파일에서 "
"지정할 수 있습니다. 이 옵션은 구성 파일의 ``[global]`` 섹션이나, 명령 줄의 모든 명령 앞에서만 설정할 수 있습니다. 구성 "
"파일에 설정하면, 명령 줄에서 재정의할 수 있습니다; 명령 줄에서 빈 문자열로 설정하면 기본값이 사용됩니다. 이것은 패키지와 함께 제공된"
" 구성 파일에서 절대로 설정해서는 안 됩니다."

#: ../Doc/distutils/extending.rst:74
msgid ""
"This new option can be used to add any number of packages to the list of "
"packages searched for command implementations; multiple package names "
"should be separated by commas.  When not specified, the search is only "
"performed in the :mod:`distutils.command` package.  When :file:`setup.py`"
" is run with the option ``--command-packages distcmds,buildcmds``, "
"however, the packages :mod:`distutils.command`, :mod:`distcmds`, and "
":mod:`buildcmds` will be searched in that order.  New commands are "
"expected to be implemented in modules of the same name as the command by "
"classes sharing the same name.  Given the example command line option "
"above, the command :command:`bdist_openpkg` could be implemented by the "
"class :class:`distcmds.bdist_openpkg.bdist_openpkg` or "
":class:`buildcmds.bdist_openpkg.bdist_openpkg`."
msgstr ""
"이 새로운 옵션은 명령 구현을 위해 검색되는 패키지 리스트에 원하는 만큼 패키지를 추가하는 데 사용할 수 있습니다; 여러 패키지 이름은 "
"쉼표로 구분해야 합니다. 지정하지 않으면, 검색은 :mod:`distutils.command` 패키지에서만 수행됩니다. 그러나, "
":file:`setup.py`\\가 옵션 ``--command-packages distcmds,buildcmds``\\로 실행되면, "
"패키지 :mod:`distutils.command`, :mod:`distcmds` 및 :mod:`buildcmds`\\가 이 순서로 "
"검색됩니다. 새 명령은 같은 이름의 모듈에, 같은 이름을 공유하는 클래스에 의해 구현될 것으로 기대됩니다. 위의 예제 명령 줄 옵션에서,"
" :command:`bdist_openpkg` 명령은 "
":class:`distcmds.bdist_openpkg.bdist_openpkg`\\나 "
":class:`buildcmds.bdist_openpkg.bdist_openpkg` 클래스로 구현될 수 있습니다."

#: ../Doc/distutils/extending.rst:88
msgid "Adding new distribution types"
msgstr "새 배포 유형 추가하기"

#: ../Doc/distutils/extending.rst:90
msgid ""
"Commands that create distributions (files in the :file:`dist/` directory)"
" need to add ``(command, filename)`` pairs to "
"``self.distribution.dist_files`` so that :command:`upload` can upload it "
"to PyPI.  The *filename* in the pair contains no path information, only "
"the name of the file itself.  In dry-run mode, pairs should still be "
"added to represent what would have been created."
msgstr ""
"배포본(:file:`dist/` 디렉터리의 파일)을 만드는 명령은 ``(command, filename)`` 쌍을 "
"``self.distribution.dist_files``\\에 추가하여 :command:`upload`\\가 PyPI에 올릴 수 있도록"
" 해야 합니다. 쌍의 *filename*\\에는 경로 정보가 없고, 파일 자체의 이름만 들어 있습니다. 드라이 런 모드에서, 생성될 것을"
" 나타내기 위해 쌍을 여전히 추가해야 합니다."
