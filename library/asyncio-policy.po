# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-26 14:46+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../Doc/library/asyncio-policy.rst:8
msgid "Policies"
msgstr "정책"

#: ../Doc/library/asyncio-policy.rst:10
msgid ""
"An event loop policy is a global per-process object that controls the "
"management of the event loop. Each event loop has a default policy, which"
" can be changed and customized using the policy API."
msgstr ""
"이벤트 루프 정책은 이벤트 루프의 관리를 제어하는 프로세스별 전역 객체입니다. 각 이벤트 루프는 기본 정책이 있는데, 정책 API를"
" 사용하여 변경하고 사용자 정의할 수 있습니다."

#: ../Doc/library/asyncio-policy.rst:14
msgid ""
"A policy defines the notion of *context* and manages a separate event "
"loop per context. The default policy defines *context* to be the current "
"thread."
msgstr ""
"정책은 *컨텍스트*\\의 개념을 정의하고 컨텍스트마다 별도의 이벤트 루프를 관리합니다. 기본 정책은 *컨텍스트*\\를 현재 스레드로"
" 정의합니다."

#: ../Doc/library/asyncio-policy.rst:18
msgid ""
"By using a custom event loop policy, the behavior of "
":func:`get_event_loop`, :func:`set_event_loop`, and "
":func:`new_event_loop` functions can be customized."
msgstr ""
"사용자 정의 이벤트 루프 정책을 사용하여, :func:`get_event_loop`, :func:`set_event_loop` 및 "
":func:`new_event_loop` 함수의 동작을 사용자 정의할 수 있습니다."

#: ../Doc/library/asyncio-policy.rst:22
msgid ""
"Policy objects should implement the APIs defined in the "
":class:`AbstractEventLoopPolicy` abstract base class."
msgstr "정책 객체는 :class:`AbstractEventLoopPolicy` 추상 베이스 클래스에 정의된 API를 구현해야 합니다."

#: ../Doc/library/asyncio-policy.rst:27
msgid "Getting and Setting the Policy"
msgstr "정책을 얻고 설정하기"

#: ../Doc/library/asyncio-policy.rst:29
msgid ""
"The following functions can be used to get and set the policy for the "
"current process:"
msgstr "다음 함수는 현재 프로세스의 정책을 가져오고 설정하는 데 사용할 수 있습니다:"

#: ../Doc/library/asyncio-policy.rst:34
msgid "Return the current process-wide policy."
msgstr "현재의 프로세스 전반의 정책을 돌려줍니다."

#: ../Doc/library/asyncio-policy.rst:38
msgid "Set the current process-wide policy to *policy*."
msgstr "현재 프로세스 전반의 정책을 *policy*\\로 설정합니다."

#: ../Doc/library/asyncio-policy.rst:40
msgid "If *policy* is set to ``None``, the default policy is restored."
msgstr "*policy*\\를 ``None``\\으로 설정하면, 기본 정책이 복원됩니다."

#: ../Doc/library/asyncio-policy.rst:44
msgid "Policy Objects"
msgstr "정책 객체"

#: ../Doc/library/asyncio-policy.rst:46
msgid "The abstract event loop policy base class is defined as follows:"
msgstr "추상 이벤트 루프 정책 베이스 클래스는 다음과 같이 정의됩니다:"

#: ../Doc/library/asyncio-policy.rst:50
msgid "An abstract base class for asyncio policies."
msgstr "asyncio 정책의 추상 베이스 클래스."

#: ../Doc/library/asyncio-policy.rst:54
msgid "Get the event loop for the current context."
msgstr "현재 컨텍스트의 이벤트 루프를 가져옵니다."

#: ../Doc/library/asyncio-policy.rst:56
msgid ""
"Return an event loop object implementing the :class:`AbstractEventLoop` "
"interface."
msgstr ":class:`AbstractEventLoop` 인터페이스를 구현하는 이벤트 루프 객체를 반환합니다."

#: ../Doc/library/asyncio-policy.rst:59 ../Doc/library/asyncio-policy.rst:71
msgid "This method should never return ``None``."
msgstr "이 메서드는 절대 ``None``\\을 반환해서는 안 됩니다."

#: ../Doc/library/asyncio-policy.rst:65
msgid "Set the event loop for the current context to *loop*."
msgstr "현재 컨텍스트에 대한 이벤트 루프를 *loop*\\로 설정합니다."

#: ../Doc/library/asyncio-policy.rst:69
msgid "Create and return a new event loop object."
msgstr "새 이벤트 루프 객체를 만들고 반환합니다."

#: ../Doc/library/asyncio-policy.rst:75
msgid "Get a child process watcher object."
msgstr "자식 프로세스 감시자 객체를 얻습니다."

#: ../Doc/library/asyncio-policy.rst:77
msgid ""
"Return a watcher object implementing the :class:`AbstractChildWatcher` "
"interface."
msgstr ":class:`AbstractChildWatcher` 인터페이스를 구현하고 있는 감시자 객체를 돌려줍니다."

#: ../Doc/library/asyncio-policy.rst:80 ../Doc/library/asyncio-policy.rst:86
msgid "This function is Unix specific."
msgstr "이 함수는 유닉스 전용입니다."

#: ../Doc/library/asyncio-policy.rst:84
msgid "Set the current child process watcher to *watcher*."
msgstr "현재의 자식 프로세스 감시자를 *watcher*\\로 설정합니다."

#: ../Doc/library/asyncio-policy.rst:89
msgid "asyncio ships with the following built-in policies:"
msgstr "asyncio에는 다음과 같은 내장 정책이 제공됩니다:"

#: ../Doc/library/asyncio-policy.rst:94
msgid ""
"The default asyncio policy.  Uses :class:`SelectorEventLoop` on both Unix"
" and Windows platforms."
msgstr "기본 asyncio 정책. 유닉스와 윈도우 플랫폼 모두에서 :class:`SelectorEventLoop`\\를 사용합니다."

#: ../Doc/library/asyncio-policy.rst:97
msgid ""
"There is no need to install the default policy manually. asyncio is "
"configured to use the default policy automatically."
msgstr "수동으로 기본 정책을 설치할 필요는 없습니다. asyncio는 기본 정책을 자동으로 사용하도록 구성됩니다."

#: ../Doc/library/asyncio-policy.rst:103
msgid ""
"An alternative event loop policy that uses the :class:`ProactorEventLoop`"
" event loop implementation."
msgstr ":class:`ProactorEventLoop` 이벤트 루프 구현을 사용하는 대안 이벤트 루프 정책."

#: ../Doc/library/asyncio-policy.rst:106
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`가용성 <availability>`: 윈도우."

#: ../Doc/library/asyncio-policy.rst:110
msgid "Process Watchers"
msgstr "프로세스 감시자"

#: ../Doc/library/asyncio-policy.rst:112
msgid ""
"A process watcher allows customization of how an event loop monitors "
"child processes on Unix. Specifically, the event loop needs to know when "
"a child process has exited."
msgstr ""
"프로세스 감시자는 이벤트 루프가 유닉스에서 자식 프로세스를 관찰하는 방법을 사용자 정의할 수 있도록 합니다. 특히, 이벤트 루프는 "
"자식 프로세스가 언제 종료했는지 알 필요가 있습니다."

#: ../Doc/library/asyncio-policy.rst:116
msgid ""
"In asyncio, child processes are created with "
":func:`create_subprocess_exec` and :meth:`loop.subprocess_exec` "
"functions."
msgstr ""
"asyncio에서, 자식 프로세스는 :func:`create_subprocess_exec` 와 "
":meth:`loop.subprocess_exec` 함수로 만들어집니다."

#: ../Doc/library/asyncio-policy.rst:120
msgid ""
"asyncio defines the :class:`AbstractChildWatcher` abstract base class, "
"which child watchers should implement, and has two different "
"implementations: :class:`SafeChildWatcher` (configured to be used by "
"default) and :class:`FastChildWatcher`."
msgstr ""
"asyncio는 자식 관찰자가 구현해야 하는 :class:`AbstractChildWatcher` 추상 베이스 클래스를 정의하며, "
":class:`SafeChildWatcher`\\(기본적으로 사용하도록 구성됩니다)와 "
":class:`FastChildWatcher`\\의 두 가지 구현이 있습니다."

#: ../Doc/library/asyncio-policy.rst:125
msgid ""
"See also the :ref:`Subprocess and Threads <asyncio-subprocess-threads>` "
"section."
msgstr ":ref:`서브 프로세스와 스레드 <asyncio-subprocess-threads>` 절도 참조하십시오."

#: ../Doc/library/asyncio-policy.rst:128
msgid ""
"The following two functions can be used to customize the child process "
"watcher implementation used by the asyncio event loop:"
msgstr "다음 두 함수를 사용하여 asyncio 이벤트 루프에서 사용되는 자식 프로세스 감시자 구현을 사용자 정의할 수 있습니다:"

#: ../Doc/library/asyncio-policy.rst:133
msgid "Return the current child watcher for the current policy."
msgstr "현재 정책에 대한 현재 자식 감시자를 반환합니다."

#: ../Doc/library/asyncio-policy.rst:137
msgid ""
"Set the current child watcher to *watcher* for the current policy.  "
"*watcher* must implement methods defined in the "
":class:`AbstractChildWatcher` base class."
msgstr ""
"현재 정책에 대한 현재 자식 관찰자를 *watcher*\\로 설정합니다. *watcher*\\는 "
":class:`AbstractChildWatcher` 베이스 클래스에 정의된 메서드를 구현해야 합니다."

#: ../Doc/library/asyncio-policy.rst:142
msgid ""
"Third-party event loops implementations might not support custom child "
"watchers.  For such event loops, using :func:`set_child_watcher` might be"
" prohibited or have no effect."
msgstr ""
"제삼자 이벤트 루프 구현은 사용자 정의 자식 관찰자를 지원하지 않을 수 있습니다. 이러한 이벤트 루프에서는, "
":func:`set_child_watcher` 사용은 금지되거나 효과가 없습니다."

#: ../Doc/library/asyncio-policy.rst:150
msgid "Register a new child handler."
msgstr "새로운 자식 처리기를 등록합니다."

#: ../Doc/library/asyncio-policy.rst:152
msgid ""
"Arrange for ``callback(pid, returncode, *args)`` to be called when a "
"process with PID equal to *pid* terminates.  Specifying another callback "
"for the same process replaces the previous handler."
msgstr ""
"PID가 *pid* 인 프로세스가 종료할 때 ``callback(pid, returncode, *args)``\\가 호출되도록 "
"배치합니다. 같은 프로세스에 대해 다른 콜백을 지정하면 이전 처리기가 교체됩니다."

#: ../Doc/library/asyncio-policy.rst:157
msgid "The *callback* callable must be thread-safe."
msgstr "*callback* 콜러블은 스레드 안전해야 합니다."

#: ../Doc/library/asyncio-policy.rst:161
msgid "Removes the handler for process with PID equal to *pid*."
msgstr "PID가 *pid* 인 프로세스의 처리기를 제거합니다."

#: ../Doc/library/asyncio-policy.rst:163
msgid ""
"The function returns ``True`` if the handler was successfully removed, "
"``False`` if there was nothing to remove."
msgstr "이 함수는 처리기가 성공적으로 제거되면 ``True``\\를, 제거할 것이 없으면 ``False``\\를 반환합니다."

#: ../Doc/library/asyncio-policy.rst:168
msgid "Attach the watcher to an event loop."
msgstr "감시자를 이벤트 루프에 연결합니다."

#: ../Doc/library/asyncio-policy.rst:170
msgid ""
"If the watcher was previously attached to an event loop, then it is first"
" detached before attaching to the new loop."
msgstr "감시자가 이전에 이벤트 루프에 연결되었으면, 새 루프에 연결하기 전에 먼저 제거됩니다."

#: ../Doc/library/asyncio-policy.rst:173
msgid "Note: loop may be ``None``."
msgstr "참고: loop는 ``None`` 일 수 있습니다."

#: ../Doc/library/asyncio-policy.rst:177
msgid "Close the watcher."
msgstr "감시자를 닫습니다."

#: ../Doc/library/asyncio-policy.rst:179
msgid ""
"This method has to be called to ensure that underlying resources are "
"cleaned-up."
msgstr "이 메서드는 하부 자원을 정리하기 위해 호출해야 합니다."

#: ../Doc/library/asyncio-policy.rst:184
msgid ""
"This implementation avoids disrupting other code spawning processes by "
"polling every process explicitly on a :py:data:`SIGCHLD` signal."
msgstr ""
"이 구현은 :py:data:`SIGCHLD` 시그널에 대해 명시적으로 모든 프로세스를 폴링하여 프로세스를 스포닝하는 다른 코드를 "
"방해하지 않습니다."

#: ../Doc/library/asyncio-policy.rst:187
msgid ""
"This is a safe solution but it has a significant overhead when handling a"
" big number of processes (*O(n)* each time a :py:data:`SIGCHLD` is "
"received)."
msgstr ""
"이것은 안전한 해법이지만 많은 수의 프로세스를 처리할 때 상당한 오버헤드가 있습니다 (:py:data:`SIGCHLD`\\가 수신될"
" 때마다 *O(n)*)."

#: ../Doc/library/asyncio-policy.rst:191
msgid "asyncio uses this safe implementation by default."
msgstr "asyncio는 기본적으로 이 안전한 구현을 사용합니다."

#: ../Doc/library/asyncio-policy.rst:195
msgid ""
"This implementation reaps every terminated processes by calling "
"``os.waitpid(-1)`` directly, possibly breaking other code spawning "
"processes and waiting for their termination."
msgstr ""
"이 구현은 ``os.waitpid(-1)``\\를 직접 호출하여 종료된 모든 프로세스를 거둡니다. 프로세스를 스포닝하는 다른 코드를"
" 망가뜨리고 그들의 종료를 기다릴 수 있습니다."

#: ../Doc/library/asyncio-policy.rst:199
msgid ""
"There is no noticeable overhead when handling a big number of children "
"(*O(1)* each time a child terminates)."
msgstr "많은 수의 자식을 처리할 때 눈에 띄는 오버헤드가 없습니다 (자식이 종료될 때마다 *O(1)*)."

#: ../Doc/library/asyncio-policy.rst:204
msgid "Custom Policies"
msgstr "사용자 정의 정책"

#: ../Doc/library/asyncio-policy.rst:206
msgid ""
"To implement a new event loop policy, it is recommended to subclass "
":class:`DefaultEventLoopPolicy` and override the methods for which custom"
" behavior is wanted, e.g.::"
msgstr ""
"새로운 이벤트 루프 정책을 구현하려면, :class:`DefaultEventLoopPolicy`\\의 서브 클래스를 만들고 사용자 "
"정의 동작이 필요한 메서드를 재정의하는 것이 좋습니다, 예를 들어::"

