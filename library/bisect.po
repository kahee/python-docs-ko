# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-26 18:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/library/bisect.rst:2
msgid ":mod:`bisect` --- Array bisection algorithm"
msgstr ":mod:`bisect` --- 배열 이진 분할 알고리즘"

#: ../Doc/library/bisect.rst:10
msgid "**Source code:** :source:`Lib/bisect.py`"
msgstr "**소스 코드:** :source:`Lib/bisect.py`"

#: ../Doc/library/bisect.rst:14
msgid ""
"This module provides support for maintaining a list in sorted order "
"without having to sort the list after each insertion.  For long lists of "
"items with expensive comparison operations, this can be an improvement "
"over the more common approach.  The module is called :mod:`bisect` "
"because it uses a basic bisection algorithm to do its work.  The source "
"code may be most useful as a working example of the algorithm (the "
"boundary conditions are already right!)."
msgstr ""
"이 모듈은 정렬된 리스트를 삽입 후에 다시 정렬할 필요 없도록 관리할 수 있도록 지원합니다. 값비싼 비교 연산이 포함된 항목의 긴 "
"리스트의 경우, 이는 일반적인 방법에 비해 개선된 것입니다. 이 모듈은 기본적인 이진 분할 알고리즘을 사용하기 때문에 "
":mod:`bisect`\\라고 불립니다. 소스 코드는 알고리즘의 실제 예로서 가장 유용할 수 있습니다 (경계 조건은 이미 옳습니다!)."

#: ../Doc/library/bisect.rst:21
msgid "The following functions are provided:"
msgstr "다음과 같은 함수가 제공됩니다:"

#: ../Doc/library/bisect.rst:26
msgid ""
"Locate the insertion point for *x* in *a* to maintain sorted order. The "
"parameters *lo* and *hi* may be used to specify a subset of the list "
"which should be considered; by default the entire list is used.  If *x* "
"is already present in *a*, the insertion point will be before (to the "
"left of) any existing entries.  The return value is suitable for use as "
"the first parameter to ``list.insert()`` assuming that *a* is already "
"sorted."
msgstr ""
"정렬된 순서를 유지하도록 *a*\\에 *x*\\를 삽입할 위치를 찾습니다. 매개 변수 *lo* 와 *hi*\\는 고려해야 할 리스트의 "
"부분집합을 지정하는 데 사용될 수 있습니다; 기본적으로 전체 리스트가 사용됩니다. *x*\\가 *a*\\에 이미 있으면, 삽입 위치는 "
"기존 항목 앞(왼쪽)이 됩니다. 반환 값은 *a*\\가 이미 정렬되었다고 가정할 때 ``list.insert()``\\의 첫 번째 매개 "
"변수로 사용하기에 적합합니다."

#: ../Doc/library/bisect.rst:33
msgid ""
"The returned insertion point *i* partitions the array *a* into two halves"
" so that ``all(val < x for val in a[lo:i])`` for the left side and "
"``all(val >= x for val in a[i:hi])`` for the right side."
msgstr ""
"반환된 삽입 위치 *i*\\는 배열 *a*\\를 이분하여, 왼쪽은 ``all(val < x for val in a[lo:i])``, "
"오른쪽은 ``all(val >= x for val in a[i:hi])``\\이 되도록 만듭니다."

#: ../Doc/library/bisect.rst:40
msgid ""
"Similar to :func:`bisect_left`, but returns an insertion point which "
"comes after (to the right of) any existing entries of *x* in *a*."
msgstr ""
":func:`bisect_left`\\와 비슷하지만, *a*\\에 있는 *x*\\의 기존 항목 뒤(오른쪽)에 오는 삽입 위치를 "
"반환합니다."

#: ../Doc/library/bisect.rst:43
msgid ""
"The returned insertion point *i* partitions the array *a* into two halves"
" so that ``all(val <= x for val in a[lo:i])`` for the left side and "
"``all(val > x for val in a[i:hi])`` for the right side."
msgstr ""
"반환된 삽입 위치 *i*\\는 배열 *a*\\를 이분하여, 왼쪽은 ``all(val <= x for val in a[lo:i])``, "
"오른쪽은 ``all(val > x for val in a[i:hi])``\\이 되도록 만듭니다."

#: ../Doc/library/bisect.rst:49
msgid ""
"Insert *x* in *a* in sorted order.  This is equivalent to "
"``a.insert(bisect.bisect_left(a, x, lo, hi), x)`` assuming that *a* is "
"already sorted.  Keep in mind that the O(log n) search is dominated by "
"the slow O(n) insertion step."
msgstr ""
"*a*\\에 *x*\\를 정렬된 순서로 삽입합니다. *a*\\가 이미 정렬되었다고 가정할 때 "
"``a.insert(bisect.bisect_left(a, x, lo, hi), x)``\\와 동등합니다. O(log n) 검색이 느린 "
"O(n) 삽입 단계에 가려짐에 유념하십시오."

#: ../Doc/library/bisect.rst:57
msgid ""
"Similar to :func:`insort_left`, but inserting *x* in *a* after any "
"existing entries of *x*."
msgstr ":func:`insort_left`\\와 비슷하지만, *a*\\에 *x*\\를 *x*\\의 기존 항목 다음에 삽입합니다."

#: ../Doc/library/bisect.rst:62
msgid ""
"`SortedCollection recipe "
"<https://code.activestate.com/recipes/577197-sortedcollection/>`_ that "
"uses bisect to build a full-featured collection class with straight-"
"forward search methods and support for a key-function.  The keys are "
"precomputed to save unnecessary calls to the key function during "
"searches."
msgstr ""
"bisect를 사용하여 직접적인 검색 메서드와 키 함수 지원을 포함하는 완전한 기능을 갖춘 컬렉션 클래스를 만드는 "
"`SortedCollection recipe "
"<https://code.activestate.com/recipes/577197-sortedcollection/>`_. 검색 중에 "
"불필요한 키 함수 호출을 피하고자 키는 미리 계산됩니다."

#: ../Doc/library/bisect.rst:70
msgid "Searching Sorted Lists"
msgstr "정렬된 리스트 검색하기"

#: ../Doc/library/bisect.rst:72
msgid ""
"The above :func:`bisect` functions are useful for finding insertion "
"points but can be tricky or awkward to use for common searching tasks. "
"The following five functions show how to transform them into the standard"
" lookups for sorted lists::"
msgstr ""
"위의 :func:`bisect` 함수는 삽입 위치를 찾는 데 유용하지만, 일반적인 검색 작업에 사용하기가 까다롭거나 어색할 수 있습니다."
" 다음 다섯 함수는 정렬된 리스트에 대한 표준 조회로 변환하는 방법을 보여줍니다::"

#: ../Doc/library/bisect.rst:114
msgid "Other Examples"
msgstr "다른 예제"

#: ../Doc/library/bisect.rst:118
msgid ""
"The :func:`bisect` function can be useful for numeric table lookups. This"
" example uses :func:`bisect` to look up a letter grade for an exam score "
"(say) based on a set of ordered numeric breakpoints: 90 and up is an 'A',"
" 80 to 89 is a 'B', and so on::"
msgstr ""
":func:`bisect` 함수는 숫자 테이블 조회에 유용할 수 있습니다. 이 예제는 :func:`bisect`\\를 사용하여 (가령) "
"시험 점수에 대한 문자 등급을 조회하는데, 정렬된 숫자 경계점 집합에 기반합니다: 90 이상은 'A', 80에서 89는 'B' "
"등입니다::"

#: ../Doc/library/bisect.rst:130
msgid ""
"Unlike the :func:`sorted` function, it does not make sense for the "
":func:`bisect` functions to have *key* or *reversed* arguments because "
"that would lead to an inefficient design (successive calls to bisect "
"functions would not \"remember\" all of the previous key lookups)."
msgstr ""
":func:`sorted` 함수와 달리, :func:`bisect` 함수는 *key* 나 *reversed* 인자를 갖는 것은 의미가 "
"없는데, 비효율적인 설계 (연속적인 bisect 함수 호출이 이전의 모든 키 조회를 \"기억\"하지 못합니다)를 초래하기 때문입니다."

#: ../Doc/library/bisect.rst:135
msgid ""
"Instead, it is better to search a list of precomputed keys to find the "
"index of the record in question::"
msgstr "대신, 해당 레코드의 인덱스를 찾기 위해 미리 계산된 키 리스트를 검색하는 것이 좋습니다::"
