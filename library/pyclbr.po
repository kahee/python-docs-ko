# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-10-23 06:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/library/pyclbr.rst:2
msgid ":mod:`pyclbr` --- Python class browser support"
msgstr ":mod:`pyclbr` --- 파이썬 클래스 브라우저 지원"

#: ../Doc/library/pyclbr.rst:9
msgid "**Source code:** :source:`Lib/pyclbr.py`"
msgstr "**소스 코드:** :source:`Lib/pyclbr.py`"

#: ../Doc/library/pyclbr.rst:13
msgid ""
"The :mod:`pyclbr` module provides limited information about the "
"functions, classes, and methods defined in a Python-coded module.  The "
"information is sufficient to implement a module browser.  The information"
" is extracted from the Python source code rather than by importing the "
"module, so this module is safe to use with untrusted code. This "
"restriction makes it impossible to use this module with modules not "
"implemented in Python, including all standard and optional extension "
"modules."
msgstr ""
":mod:`pyclbr` 모듈은 파이썬 코드 모듈에 정의된 함수, 클래스 및 메서드에 대한 제한된 정보를 제공합니다. 이 정보는 모듈 "
"브라우저를 구현하기에 충분합니다. 정보는 모듈을 임포트 하기보다는 파이썬 소스 코드에서 추출되므로 이 모듈은 신뢰할 수 없는 코드와 함께"
" 사용하는 것이 안전합니다. 이 제한으로 인해 이 모듈을 모든 표준 및 선택 확장 모듈을 포함하여 파이썬으로 구현되지 않은 모듈에 사용할"
" 수 없습니다."

#: ../Doc/library/pyclbr.rst:25
msgid ""
"Return a dictionary mapping module-level class names to class "
"descriptors.  If possible, descriptors for imported base classes are "
"included.  Parameter *module* is a string with the name of the module to "
"read; it may be the name of a module within a package.  If given, *path* "
"is a sequence of directory paths prepended to ``sys.path``, which is used"
" to locate the module source code."
msgstr ""
"모듈 수준의 클래스 이름을 클래스 설명자에 매핑하는 딕셔너리를 돌려줍니다. 가능하면, 임포트 된 베이스 클래스에 관한 설명자가 "
"포함됩니다. 매개 변수 *module*\\은 읽을 모듈 이름이 들어있는 문자열입니다; 패키지 내의 모듈 이름일 수 있습니다. 주어지면, "
"*path*\\는 ``sys.path`` 앞에 추가된 디렉터리 경로 시퀀스인데, 모듈 소스 코드의 위치를 찾는 데 사용됩니다."

#: ../Doc/library/pyclbr.rst:35
msgid ""
"Return a dictionary-based tree containing a function or class descriptors"
" for each function and class defined in the module with a ``def`` or "
"``class`` statement.  The returned dictionary maps module-level function "
"and class names to their descriptors.  Nested objects are entered into "
"the children dictionary of their parent.  As with readmodule, *module* "
"names the module to be read and *path* is prepended to sys.path.  If the "
"module being read is a package, the returned dictionary has a key "
"``'__path__'`` whose value is a list containing the package search path."
msgstr ""
"``def`` 나 ``class`` 문을 사용하여 모듈에 정의된 각 함수 및 클래스에 대한 함수나 클래스 설명자를 포함하는 딕셔너리 기반"
" 트리를 반환합니다. 반환된 딕셔너리는 모듈 수준의 함수와 클래스 이름을 해당 설명자에 대응합니다. 중첩된 객체는 그들의 parent의 "
"children 딕셔너리에 들어갑니다. readmodule과 마찬가지로, *module*\\은 읽을 모듈의 이름을 지정하고 "
"*path*\\는 sys.path의 앞에 추가됩니다. 읽히는 모듈이 패키지면, 반환된 딕셔너리는 키 ``'__path__'``\\를 "
"가지는데, 값은 패키지 검색 경로를 포함하는 리스트입니다."

#: ../Doc/library/pyclbr.rst:45
msgid ""
"Descriptors for nested definitions.  They are accessed through the new "
"children attibute.  Each has a new parent attribute."
msgstr ""
"중첩된 정의에 대한 설명자. 새로운 children 어트리뷰트를 통해 액세스할 수 있습니다. 각에는 새로운 parent 어트리뷰트가 "
"있습니다."

#: ../Doc/library/pyclbr.rst:49
msgid ""
"The descriptors returned by these functions are instances of Function and"
" Class classes.  Users are not expected to create instances of these "
"classes."
msgstr ""
"이러한 함수에 의해 반환되는 설명자는 Function과 Class 클래스의 인스턴스입니다. 사용자가 이러한 클래스의 인스턴스를 만들 "
"것으로 기대하지 않습니다."

#: ../Doc/library/pyclbr.rst:57
msgid "Function Objects"
msgstr "Function 객체"

#: ../Doc/library/pyclbr.rst:58
msgid ""
"Class :class:`Function` instances describe functions defined by def "
"statements.  They have the following attributes:"
msgstr ""
"클래스 :class:`Function` 인스턴스는 def 문으로 정의된 함수를 설명합니다. 다음과 같은 어트리뷰트를 가지고 있습니다 :"

#: ../Doc/library/pyclbr.rst:64
msgid "Name of the file in which the function is defined."
msgstr "함수가 정의된 파일의 이름."

#: ../Doc/library/pyclbr.rst:69
msgid "The name of the module defining the function described."
msgstr "설명된 함수를 정의하는 모듈의 이름."

#: ../Doc/library/pyclbr.rst:74
msgid "The name of the function."
msgstr "함수의 이름."

#: ../Doc/library/pyclbr.rst:79 ../Doc/library/pyclbr.rst:122
msgid "The line number in the file where the definition starts."
msgstr "정의가 시작되는 파일의 줄 번호."

#: ../Doc/library/pyclbr.rst:84
msgid "For top-level functions, None.  For nested functions, the parent."
msgstr "최상위 함수면, None. 중첩된 함수면, 부모."

#: ../Doc/library/pyclbr.rst:91 ../Doc/library/pyclbr.rst:134
msgid ""
"A dictionary mapping names to descriptors for nested functions and "
"classes."
msgstr "이름을 중첩된 함수와 클래스에 관한 설명자로 매핑하는 딕셔너리."

#: ../Doc/library/pyclbr.rst:100
msgid "Class Objects"
msgstr "Class 객체"

#: ../Doc/library/pyclbr.rst:101
msgid ""
"Class :class:`Class` instances describe classes defined by class "
"statements.  They have the same attributes as Functions and two more."
msgstr ""
"클래스 :class:`Class` 인스턴스는 class 문으로 정의된 클래스를 설명합니다. Function과 같은 어트리뷰트에 더해 두 "
"개의 어트리뷰트가 더 있습니다."

#: ../Doc/library/pyclbr.rst:107
msgid "Name of the file in which the class is defined."
msgstr "클래스가 정의된 파일의 이름."

#: ../Doc/library/pyclbr.rst:112
msgid "The name of the module defining the class described."
msgstr "설명된 클래스를 정의하는 모듈의 이름."

#: ../Doc/library/pyclbr.rst:117
msgid "The name of the class."
msgstr "클래스의 이름."

#: ../Doc/library/pyclbr.rst:127
msgid "For top-level classes, None.  For nested classes, the parent."
msgstr "최상위 클래스면, None. 중첩된 클래스면, 부모."

#: ../Doc/library/pyclbr.rst:142
msgid ""
"A list of :class:`Class` objects which describe the immediate base "
"classes of the class being described.  Classes which are named as "
"superclasses but which are not discoverable by :func:`readmodule_ex` are "
"listed as a string with the class name instead of as :class:`Class` "
"objects."
msgstr ""
"설명되는 클래스의 직접적인 베이스 클래스를 설명하는 :class:`Class` 객체의 리스트. 슈퍼 클래스로 명명되었지만 "
":func:`readmodule_ex`\\가 찾을 수 없는 클래스는 :class:`Class` 객체가 아니라 클래스 이름을 담은 문자열로"
" 나열됩니다."

#: ../Doc/library/pyclbr.rst:151
msgid ""
"A dictionary mapping method names to line numbers.  This can be derived "
"from the newer children dictionary, but remains for back-compatibility."
msgstr ""
"메서드 이름을 줄 번호에 매핑하는 딕셔너리. 최신 children 딕셔너리에서 파생될 수 있지만, 이전 버전과의 호환성을 위해 "
"남아있습니다."
